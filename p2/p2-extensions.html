<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">@import 'doc.css';</style>
<title>Perl5 on p2 - Language backwards-compatible Extensions</title>
</head><body>
<pre style="background: #AE6;width:25em">
         .ooo
          'OOOo
      ~ p ooOOOo 2 ~
          .OOO
           oO      %% a fast perl5
             Oo
            'O
             `
            (o)
        ___/ /          
       /`    \ 
      /v^  `  ,
     (...v/v^/
      \../::/
       \/::/ 
</pre>
<div id='central'>
<h1>Perl5 on p2 Language backwards-compatible Extensions</h1>
<p>With p2 I plan to parse and execute perl5 asis.</p>
<p>Problem will arise with XS code, since the VM is different, and not<br />
all XS <span class="caps">API</span> functions can be supported.  It should be much easier to<br />
use XS-like functionality with the new <span class="caps">FFI</span>, or by using extension<br />
libraries with native calls. See <code>lib/readline</code>. So we will loose 40% of<br />
<span class="caps">CPAN</span> code, but will win on performance, expressibility and<br />
compile-time error checking when binding libs.</p>
<h2>Perl5 Language Extensions</h2>
<h3>All data are objects, all declarations can be optionally typed</h3>
	<p>I.e. all core types are implictly blessed into the int, str, num
classes and mixins thereof.
See <a href="https://github.com/rurban/perl/blob/d1c07ab82fd3acf17803a9f7dbd8e3ab3c5d3903/pddtypes.pod">pddtypes.pod</a> and <a href="https://github.com/rurban/perl/blob/05514649c35a695734bc8e02911e7efef6ee4dde/pod/perltypes.pod">perltypes.pod</a> for more.</p>

<pre><code>
my int $i;
my const str $s = "string";
my const int $h = {foo =&gt; 1, bla =&gt; 0};
my const int @a = (0..9);
</code></pre>
<h3>const declarations for data, @ISA, classes and functions/methods</h3>
<p>method calls should be inlinable and compile-time optimizable.</p>

<h3>sized arrays</h3>
<pre><code>
    my $a[10];
    my int $a[10];
</code></pre>
<p>Sized arrays are are non-autovivifying and initialized with undef,<br />
resp. if typed 0, 0.0 or &quot;&quot;. This speeds up array access by factor 2-4.<br />
See <a href="http://blogs.perl.org/users/rurban/2012/10/optimizing-compiler-benchmarks-part-3.html">optimizing compiler benchmarks part 3</a></p>

<h3>no magic</h3>

<p>A new pragma &#8220;no magic&#8221; applies to all visible objects in scope.</p>
<pre><code>
     {
       no magic;
       use Config;
       print $Config{'ccflags'};
     }
</code></pre>
<p><code>=&gt; compile-time error: Invalid use of tie with no magic</code></p>
<p>use<br />
<pre><code>
     {
       no magic;
       use Config ();
       print $Config::Config{'ccflags'};
     }
</code></pre> instead.</p>
<p>See <a href="http://blogs.perl.org/users/rurban/2012/10/optimizing-compiler-benchmarks-part-3.html">optimizing compiler benchmarks part 3</a></p>

<h3>match operator</h3>

<p>The simple smartmatch is already taken and will just work, because all<br />
data is dynamically typed. smartmatch will use a user-defined <code>MATCH</code> method<br />
for objects. given/when is too limited and a bit broken.<br />
But we want to match structures to find structures in lists or trees<br />
(nested structures), not only strings, and we want to declare macros easily.<br />
See <a href="http://magpie.stuffwithstuff.com/patterns.html">magpie patterns</a></p>
<pre><code>
     my $s = "s";
     match /^s/, 123, 1 {
       case $s, $n is Int, $_: say "matched $s, $n, $_";
       else: say "no match";
     }
</code></pre>

<p><code>is Int</code> is a new Type Pattern, which matches a type or subtype. <br />
It calls the typeof() function.<br />
<code>is</code> is a new keyword to match types in patterns.<br />
$_ in patterns is always true and returns the given scalar value.<br />
Use @_ to match multiple expressions, the &#8220;rest&#8221;.</p>

<h3>flexible and efficient parser</h3>

<p>The current <a href="http://piumarta.com/software/peg/">leg</a> based p2 parser can handle complicated expressions and operator precedence much better than the simple recursive descent <span class="caps">LLAR</span> <code>yacc</code>
parser in <code>perly.y</code>.  Problematic syntax can be avoided, like previously
mandatory parenthesis. <code>if</code> or <code>while</code> boolean expressions don&#8217;t need parens.</p>

<pre><code>
     if $s say "$s";
     else say "else";
</code></pre>

<p><code>for</code> lists should not need parens, the expressions are evaluated in list<br />
context.</p>
<pre><code>
     for $_ qw(a b c) {
     }

     const int[] sub get_list {(0..9)}

     for my int $i get_list {
       say $i;
     }
</code></pre>

<p>The language should be extendable. Left or right assiocative keywords<br />
should be easily added to the parser description, with statically<br />
deterministic proper precedence rules. (run-time extendable<br />
associativity only with Pratt or marpa.)</p>
<p>The packrat parser based on <code>leg</code> is not quite as highly efficient and<br />
dynamically extendable as a <a href="http://journal.stuffwithstuff.com/2011/02/13/extending-syntax-from-within-a-language/">Pratt top-down<br />
parser</a><br />
with special operator precedence rules in the parser table<br />
declaration, but it does not backtrack as much as <code>yacc</code> in<br />
expressions due to memoizing, and precedence is statically defined in<br />
the rules.</p>
<p>But in the end I&#8217;ll need a dynamic parser to support macros.  The<br />
problem is that such a parser cannot be stolen yet, nobody has written<br />
so far one in C, only in <span class="caps">LISP</span>, java or javascript. The idea to base<br />
macros on the parser probably didn&#8217;t come to anyone yet outside the<br />
<span class="caps">LISP</span> community. Rob Pike recently presented a nice and easy-enough<br />
parser for <a href="https://www.youtube.com/watch?v=HxaD_trXwRE">Go templates</a><br />
So far <a href="http://jeffreykegler.github.com/Marpa-web-site/">marpa</a> seems<br />
to be the best dynamic parser library, there is a C library, extending<br />
it at run-time should be achievable easily, and the parser algorithm<br />
is pretty robust.</p>

<p><strong>marketing blurbs</strong>: <em>p2 will be the first implementation of any non-<span class="caps">LISP</span> language with proper macro support.</em></p>

<h3>macros</h3>
<p>macros expose the power of the parser to the language, as in <span class="caps">LISP</span>.<br />
They allow extending and simplifying the language.</p>
<p>macros are compile-time parser extensions, rules added after startup,<br />
which do not construct parse trees directy, but indirectly.  macro<br />
argument declarations have the same syntax as <code>leg</code>, and may use the<br />
same rules (i.e. non-terminal symbols) from the grammer, i.e. the left<br />
hand side of the grammar rules, but the body is written in native<br />
perl5, with a mix of compile-time and run-time expressions.</p>
<p>e.g. <br />
<pre><code>
  syntax-p5.g:
    block = '{' s:lineseq '}' { $$ = PN_AST(BLOCK, s); }
</code></pre><br />
<pre><code>
  macro ifdebug block {
    if $DEBUG `block`;
  }
</code></pre></p>
<p>A macro can use valid parser expressions, i.e. strings<br />
(i.e. terminals) or any valid parser rule (i.e. non-terminals) as argument,<br />
here the rule <code>block</code>, and even <code>b:block</code> to assign the variable <code>b</code><br />
for the matched block, esp.  when matching two rules, i.e. <code>b1:block
b2:block</code>.<br />
See the documentation of the parser for valid parser expressions. <br />
<code>leg</code> supports peg expressions like <code>* + ?</code>, backtracking lookahead assertions<br />
<code>! &amp;</code>, and grouping via <code>()</code>.<br />
<code>marpa</code> only supports sequences with a defined number of <code>min</code> and <code>max</code> sequences,<br />
<code>min=0</code> i.e. <code>*</code>, <code>min=1</code> i.e. <code>+</code>, optional <code>?</code> would be <code>min=0, max=1</code>.<br />
Syntax: <code>rule{min,max}</code> min defaults to 0, max to infinite,<br />
Later hopefully <code>rule+</code>, <code>rule*</code> and <code>rule?</code>. The <span class="caps">PEG</span> backtracking lookahead<br />
assertions <code>! &amp;</code> are not needed in marpa, because it embraces a bottom-up <span class="caps">BNF</span><br />
grammar.</p>
<p>Most keywords should be defined as macros.  E.g. <code>for</code>, <code>while</code> and<br />
<code>match</code> can be more easily defined as macros. Short circuiting and<br />
partial evaluation should be possible in macros.</p>
<p>Normal functions or methods do not need to be defined in the language,<br />
they are library calls. 90% of the ops previously defined in perl5 are<br />
moved to the standard library. Most syntax extending declarations are<br />
macros defined in the standard library.</p>
<p>With macros you can define your own compile-time optimizations.<br />
Every statement in a macro, which is not evaluated, is not compiled in,<br />
it is ignored. E.g. you can simplify all your <code>if $DEBUG</code> statements,<br />
and extend the expressibility of your code.</p>
<p><code>()</code> groups list in parse expressions, and does not match perl elements in lists.</p>
<pre><code>
      macro dbgprint ( s:stmt )* {
        if ($DEBUG) {
          print @`s`;
        }
      }
</code></pre>

<pre><code>
      macro while '('e:expr')' '{'b:block'}' {
          my $label = gensym('WHILE');
	  $label: if (`e`) {
	     @`b`;
	     goto $label;
          }
      }
</code></pre>
<p>&#8216;(&#8217; is to disambiguate a parse-time &#8216;(&#8217; from a grouping <code>(</code>.<br />
`` is taken to evaluate (=expand) expressions within macros.<br />
<code>@</code>`` splices expanded code in list context.<br />
Similar to perl6 <code>quasi</code> or <code>{{{ }}}</code> blocks, just simplier.</p>
<p>Note that the return value of this while is always <code>undef</code>, and<br />
the while construct needs the <code>()</code> and <code>{}</code>, contrary to the current keyword.<br />
But you can declare a while macro for the single block case without <code>{}</code>.</p>
</div></body></html>
