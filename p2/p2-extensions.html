<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">@import 'doc.css';</style>
<div id='potion'><img src='potion-1.png' /></div>
</head><body><div id='central'>
<h1>Perl5 on p2 Language backwards-compatible Extensions</h1>
<p>With p2 I plan to parse and execute perl5 asis.</p>
<p>Problem will arise with XS code, since the VM is different, and not<br />
all XS <span class="caps">API</span> functions can be supported.  It should be much easier to<br />
use XS-like functionality with the new <span class="caps">FFI</span>, or by using extension<br />
libraries with native calls. See <code>lib/readline</code>. So we will loose 40% of<br />
<span class="caps">CPAN</span> code, but will win on performance, expressibility and<br />
compile-time error checking when binding libs.</p>
<h2>Perl5 Language Extensions</h2>
<h3>All data are objects, all declarations can be optionally typed</h3>
<p>I.e. all core types are implictly blessed into the Int, Str, Num<br />
classes and mixins thereof.</p>
<pre><code>
my int $i;
my const str $s = "string";
my const int $h = {foo =&gt; 1, bla =&gt; 0};
my const int @a = (0..9);
</code></pre>
<h3>const declarations for data, @ISA, classes and functions/methods</h3>
<p>method calls should be inlinable and compile-time optimizable.</p>
<h3>sized arrays</h3>
<p>Sixed arrays are are non-autovivifying and initialized with undef,<br />
resp. if typed 0, 0.0, &quot;&quot;. This speeds up array access by factor 2-4.<br />
See <a href="http://blogs.perl.org/users/rurban/2012/10/optimizing-compiler-benchmarks-part-3.html">optimizing compiler benchmarks part 3</a></p>
<h3>no magic</h3>
<p>A new pragma &#8220;no magic&#8221; applies to all visible objects in scope.</p>
<pre><code>
     {
       no magic;
       use Config;
       print $Config{'ccflags'};
     }
</code></pre>
<p><code>=&gt; compile-time error: Invalid use of tie with no magic</code></p>
<p>use<br />
<pre><code>
     {
       no magic;
       use Config ();
       print $Config::Config{'ccflags'};
     }
</code></pre> instead.</p>
<p>See <a href="http://blogs.perl.org/users/rurban/2012/10/optimizing-compiler-benchmarks-part-3.html">optimizing compiler benchmarks part 3</a></p>
<h3>match operator</h3>
<p>The simple smartmatch is already taken and will just work, becaus1e all<br />
data is dynamically typed.  But we want to match structures, to find<br />
structures in trees (nested structures), not only strings, and we want<br />
to declare macros easily.<br />
See <a href="http://magpie.stuffwithstuff.com/patterns.html">magpie patterns</a></p>
<pre><code>
     my $s = "s";
     match /^s/, 123, 1 {
       case $s, $n is Int, $_: say "matched $s, $n, $_";
       else: say "no match";
     }
</code></pre>
<p><code>is Int</code> is a new Type Pattern, which matches a type or subtype. <br />
It calls the typeof() function.<br />
<code>is</code> is a new keyword to match types in patterns.<br />
$_ in patterns is always true and returns the given scalar value.<br />
Use @_ to match multiple expressions, the &#8220;rest&#8221;.</p>
<h3>flexible and efficient packrat parser</h3>
<p>The leg-based p2 parser can handle complicated expressions and operator<br />
precedence much better than the simple recursive descent <span class="caps">LLAR</span> <code>yacc</code><br />
parser in <code>perly.y</code>.  Problematic syntax can be avoided, like previously<br />
mandatory parenthesis. <code>if</code> or <code>while</code> boolean expressions don&#8217;t need<br />
parens.</p>
<pre><code>
     if $s say "$s;
     else say "else";
</code></pre>
<p><code>for</code> lists should not need parens, the expressions are evaluated in list<br />
context.</p>
<pre><code>
     for $_ qw(a b c) {
     }

     const int[] sub get_list {(0..9)}

     for my int $i get_list {
       say $i;
     }
</code></pre>
<p>The language should be extendable. Left or right assiocative keywords<br />
should be easily added to the parser description, with statically<br />
deterministic proper precedence rules.  (run-time extendable<br />
associativity only with Pratt)</p>
<p>The packrat parser based on <code>leg</code> is not quite a highly efficient and<br />
dynamically extendable Pratt top-down parser with special operator<br />
precedence rules in the parser table declaration, but it does not<br />
backtrack as much as <code>yacc</code> in expressions due to memoizing, and<br />
precedence is statically defined in the rules.</p>
<h3>macros</h3>
<p>Most keywords should be defined as macros.  E.g. for, while and<br />
match can be more easily defined as macros. Short circuiting and <br />
partial evaluation should be possible in macros.</p>
<p>Normal functions or methods do not need to be defined in the language,<br />
they are library calls. 90% of the ops previously defined in perl5 are<br />
moved to the standard library. Most syntax extending declarations are<br />
macros defined in the standard library.</p>
<p>With macros you can define your own compile-time optimizations,<br />
every statement in a macro, which is not evaluated is not compiled in,<br />
it is ignored. E.g. you can simplify all your <code>if $DEBUG</code> statements,<br />
and extend the expressibility of your code.</p>
<p>match patterns should be used to declare macro structures, to be <br />
able to define syntax on structures, not just simple statements. <br />
E.g. match itself should be definable as macro.</p>
<pre><code>
TODO: 
      macro while '('expr')' '{'block'}' {
          my $label = gensym('WHILE');
	  $label: if (`expr`) {
	     @`block`;
	     goto $label;
          }
      }
</code></pre>
<p>&#8216;(&#8217; is to disambiguate a parse-time &#8216;(&#8217; from a list definition.<br />
`` is taken to evaluate (=expand) expressions within macros.<br />
() and {} in the match (declaration) defines the context.<br />
<span class="caps">TODO</span>: scalar or list context? @``</p>
<p>Note that the return value of this while is always <code>undef</code>, and<br />
the while construct needs the () and {}, contrary to the current keyword.<br />
But you can declare a while macro for the single block case without {}.</p>
</div></body></html>
