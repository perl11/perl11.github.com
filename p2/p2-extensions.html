<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">@import 'doc.css';</style>
<title>Perl5 on p2 - Language backwards-compatible Extensions</title>
</head><body>
<pre style="background: #AE6;width:25em">
         .ooo
          'OOOo
      ~ p ooOOOo 2 ~
          .OOO
           oO      %% a fast perl5
             Oo
            'O
             `
            (o)
        ___/ /          
       /`    \ 
      /v^  `  ,
     (...v/v^/
      \../::/
       \/::/ 
</pre>
<div id='central'>
<h1>Perl5 on p2 Language backwards-compatible Extensions</h1>
<p>With p2 I plan to parse and execute perl5 asis.</p>
<p>Problem will arise with XS code, since the VM is different, and not<br />
all XS <span class="caps">API</span> functions can be supported.  It should be much easier to<br />
use XS-like functionality with the new <span class="caps">FFI</span>, or by using extension<br />
libraries with native calls. See <code>lib/readline</code>. So we will loose 40% of<br />
<span class="caps">CPAN</span> code, but will win on performance, expressibility and<br />
compile-time error checking when binding libs.</p>
<h2>Perl5 Language Extensions</h2>
<h3>All data are objects, all declarations can be optionally typed</h3>
<p>I.e. all core types are implictly blessed into the Int, Str, Num<br />
classes and mixins thereof.</p>
<pre><code>
my int $i;
my const str $s = "string";
my const int $h = {foo =&gt; 1, bla =&gt; 0};
my const int @a = (0..9);
</code></pre>
<h3>const declarations for data, @ISA, classes and functions/methods</h3>
<p>method calls should be inlinable and compile-time optimizable.</p>
<h3>sized arrays</h3>
<p>Sixed arrays are are non-autovivifying and initialized with undef,<br />
resp. if typed 0, 0.0, &quot;&quot;. This speeds up array access by factor 2-4.<br />
See <a href="http://blogs.perl.org/users/rurban/2012/10/optimizing-compiler-benchmarks-part-3.html">optimizing compiler benchmarks part 3</a></p>
<h3>no magic</h3>
<p>A new pragma &#8220;no magic&#8221; applies to all visible objects in scope.</p>
<pre><code>
     {
       no magic;
       use Config;
       print $Config{'ccflags'};
     }
</code></pre>
<p><code>=&gt; compile-time error: Invalid use of tie with no magic</code></p>
<p>use<br />
<pre><code>
     {
       no magic;
       use Config ();
       print $Config::Config{'ccflags'};
     }
</code></pre> instead.</p>
<p>See <a href="http://blogs.perl.org/users/rurban/2012/10/optimizing-compiler-benchmarks-part-3.html">optimizing compiler benchmarks part 3</a></p>
<h3>match operator</h3>
<p>The simple smartmatch is already taken and will just work, because all<br />
data is dynamically typed.  But we want to match structures, to find<br />
structures in trees (nested structures), not only strings, and we want<br />
to declare macros easily.<br />
See <a href="http://magpie.stuffwithstuff.com/patterns.html">magpie patterns</a></p>
<pre><code>
     my $s = "s";
     match /^s/, 123, 1 {
       case $s, $n is Int, $_: say "matched $s, $n, $_";
       else: say "no match";
     }
</code></pre>

<p><code>is Int</code> is a new Type Pattern, which matches a type or subtype. <br />
It calls the typeof() function.<br />
<code>is</code> is a new keyword to match types in patterns.<br />
$_ in patterns is always true and returns the given scalar value.<br />
Use @_ to match multiple expressions, the &#8220;rest&#8221;.</p>

<h3>flexible and efficient parser</h3>

<p>The current <a href="http://piumarta.com/software/peg/">leg</a> based p2 parser can handle complicated expressions and operator precedence much better than the simple recursive descent <span class="caps">LLAR</span> <code>yacc</code>
parser in <code>perly.y</code>.  Problematic syntax can be avoided, like previously
mandatory parenthesis. <code>if</code> or <code>while</code> boolean expressions don&#8217;t need parens.</p>

<pre><code>
     if $s say "$s";
     else say "else";
</code></pre>

<p><code>for</code> lists should not need parens, the expressions are evaluated in list<br />
context.</p>
<pre><code>
     for $_ qw(a b c) {
     }

     const int[] sub get_list {(0..9)}

     for my int $i get_list {
       say $i;
     }
</code></pre>

<p>The language should be extendable. Left or right assiocative keywords
should be easily added to the parser description, with statically
deterministic proper precedence rules. (run-time extendable
associativity only with Pratt)</p>

<p>The packrat parser based on <code>leg</code> is not quite as highly efficient and
dynamically extendable as a <a href="http://journal.stuffwithstuff.com/2011/02/13/extending-syntax-from-within-a-language/">Pratt top-down parser</a> with special
operator precedence rules in the parser table declaration, but it does
not backtrack as much as <code>yacc</code> in expressions due to memoizing, and
precedence is statically defined in the rules.</p>

<p>But in the end I&#8217;ll need such a dynamic top-down parser to support macros.
The problem is that such a parser cannot be stolen yet, nobody has
written so far one in C, only in <span class="caps">LISP</span> or javascript. 
The idea to base macros on the parser probably didn't come to anyone yet
outside the LISP community. Rob Pike recently presented a nice and easy-enough parser for 
<a href="https://www.youtube.com/watch?v=HxaD_trXwRE">Go templates</a>.</p>

<h3>macros</h3>

<p>macros expose the power of the parser to the language, as in <span class="caps">LISP</span>.
macros are compile-time parser extensions. macro argument declarations
have the same syntax as <code>leg</code>, and may use the same lexer symbols, but
the body is written in native perl5, with a mix of compile-time and
run-time expressions.</p>


e.g. 
<pre><code>
syntax-p5.g:

block = '{' s:lineseq '}' { $$ = PN_AST(BLOCK, s); }

</code></pre>

	<p>A macro can use any lexed symbol, lexed symbol <code>block</code>, and even
<code>b:block</code> to assign the variable <code>b</code> for the matched block.</p>


	<p>Most keywords should be defined as macros.  E.g. for, while and
match can be more easily defined as macros. Short circuiting and 
partial evaluation should be possible in macros.</p>


	<p>Normal functions or methods do not need to be defined in the language,
they are library calls. 90% of the ops previously defined in perl5 are
moved to the standard library. Most syntax extending declarations are
macros defined in the standard library.</p>


	<p>With macros you can define your own compile-time optimizations.
Every statement in a macro, which is not evaluated, is not compiled in,
it is ignored. E.g. you can simplify all your <code>if $DEBUG</code> statements,
and extend the expressibility of your code.</p>


	<p><span class="caps">MAYBE</span>: match patterns should be used to declare macro structures, to
be able to define syntax on structures, not just simple statements.
E.g. match itself should be definable as macro.</p>


<pre><code>
      macro while '('e:expr')' '{'b:block'}' {
          my $label = gensym('WHILE');
      $label: if (`e`) {
         @`b`;
         goto $label;
          }
      }
</code></pre>

	<p>&#8216;(&#8217; is to disambiguate a parse-time &#8216;(&#8217; from a group.
`` is taken to evaluate (=expand) expressions within macros.
@`` expands into list context.
Similar to perl6 <code>quasi</code> or <code>{{{ }}}</code> blocks, just simplier.</p>


	<p>Note that the return value of this while is always <code>undef</code>, and
the while construct needs the () and {}, contrary to the current keyword.
But you can declare a while macro for the single block case without {}.</p>


	<p>{} in the match (declaration) would define a hash context,
a structure to match against.</p>


<span class="caps">MAYBE</span>: Such as:
<pre><code>
      # match a leaf hash key, without kids
      macro leaf h:hash { n:name } {
      `$h{n}` if exists $h{n} and !@$h{n};
      }

      $INC{leaf} =&gt; ...
</code></pre>

	<p>But () needs to be reserved for lexical list grouping,
and not to match perl elements in lists.</p>


<pre><code>
      macro dbgprint ( s:stmt )* {
        if ($DEBUG) {
          print @`s`;
        }
      }
</code></pre>
</div></body></html>
