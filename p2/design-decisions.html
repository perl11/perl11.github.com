<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">@import 'doc.css';</style>
</head><body>
<pre style="background:#AE6;width:25em;float:right;padding-right:2em">
         .ooo
          'OOOo
      ~ p ooOOOo 2 ~
          .OOO
           oO      %% a fast perl5
             Oo
            'O
             `
            (o)
        ___/ /          
       /`    \ 
      /v^  `  ,
     (...v/v^/
      \../::/
       \/::/ 
</pre>
<div id='central'>
<h1>design decisions on p2</h1>


	<p>With p2 I plan to parse and execute perl5 asis.
libp2, the compiler and vm based on potion, should be a good target
for perl6.</p>


	<p>But I will not be able to run 100% of <span class="caps">CPAN</span>. I could, but then there
would be no progress.
I plan significant enhancements in perl performance and features.</p>


	<h2>Generally</h2>


	<p>I go along with _why and every lisp coder.  Good software should be
beautiful. But not too beautiful. Code is also art not only technology.
Short, precise, readable. No one wants to work with a big and ugly
mess, not even companies. Too much code smells.  Rather restrict the
usage to those who know and can be taught, than sacrifice your system
for it. On the other hand too beautiful code rarely gets out of a niche.
Worse is better.</p>


	<p>Support 90% but do not sacrifice for the rest.
gmake and gcc/clang are available everywhere, even on pure bsd&#8217;s.</p>


	<p>Examples:
no support for MS cl/nmake. people should use mingw with gmake and gcc instead.
no support for BSDmakefile syntax. see the <code>bsd</code> branch.
no support for pure strict c++ compilers. see the <code>p2-c++</code> branch.
no vax, hpux, aix without gnu tools.</p>


	<h1>Incompatibilities</h1>


	<p>Some functionality will change, some annoying bugs fixed, 
and some functionality might get removed, or not yet supported.</p>


	<h2>XS</h2>


	<p>Problem will arise with XS code, since the VM is different, and not
all <span class="caps">XS API</span> functions can be supported.  It should be much easier to
use XS-like functionality with the new <span class="caps">FFI</span>, or by using extension
libraries with native calls. See <code>lib/readline</code>. So we will loose
40% of <span class="caps">CPAN</span> code, but will win on performance, expressibility and
compile-time error checking when binding libs.</p>


	<p>There should be a translator of old XS code to check the stack
(argument + return values) handling macros and convert them to direct
calls.</p>


	<h2>functional programming</h2>


	<p>p2 is pretty obscene in being a pure functional language, certainly more functional
than <span class="caps">LISP</span>.
Internally any non-lexical variable (GV in perl5) is a function, a closure, which means
it is an object, which means getting the value is done by sending it a message with
an empty name,
and setting the value is done by sending it the &#8220;def&#8221; message.</p>


	<pre><code>(msg %ENV) =&gt; return value of %ENV
(msg %ENV "def" &#38;env) =&gt; set new value of %ENV</code></pre>


	<p>same for keys (accessor support):</p>


	<pre><code>(msg %ENV key) =&gt; return a %ENV element
(msg %ENV "def" key value) =&gt; set new value of a %ENV element</code></pre>


	<p>Yes, you smell Smalltalk.
This is needed to be able to support a proper object system, types and esp.
proper multi-threading. There are special <span class="caps">MOP</span> methods for default
readers and writers, type_call_is: key, type_callset_is: key+value.</p>


	<p>On the user-side some side-effect-only functions will be changed to return the
changed argument.
E.g. chop, chomp, ...
return $s =~ s///r as default if the left hand side (wantarray) is no list.</p>


	<p>The parser simplier and different. All statements return values. Everything can be on a
right hand side of something.
E.g. <strong>if</strong> returns the value of the executed branch or
<strong>undef</strong> if no branch is choosen.</p>


	<p>bc. {
    $a = if (1) { $c }; #same as: $a = $c;
}</p>


	<h2>order of destruction</h2>


	<p>If you don&#8217;t use explicit <span class="caps">DESTROY</span> calls at the end of blocks, the compiler 
might miss some <span class="caps">DESTROY</span> calls of untyped objects. <span class="caps">DESTROY</span> might be called
later then, as in other GC&#8217;d languages. get over it.</p>


	<p>reference counted objects are too dangerous, too hard and too slow.
cyclic data structures do not play well with refcounts.
use-after-free bugs are by factor 10 the most exploited security problems
nowadays, and perl5 is full of them.</p>


	<h2>lexical hash iterators</h2>


	<p>iterating a hash twice in lexically scoped blocks does not work in the second, 
outer iterator, as the iterator in p5p perl is stored in the data. 
This will be changed to be stored in the scope (block).</p>


	<p>i.e. using Data::Dumper inside a each %hash loop will restore the position after 
Data::Dumper dumped the hash.</p>


	<h1>New features (planned)</h1>


	<h3>All data are objects, all declarations can be optionally typed.</h3>


	<p>extendability, maintainance</p>


	<p>efficient oo and dynamic type system, with compiler support for static types.</p>


	<h3>const declarations for lexical data, @ISA, classes and functions/methods</h3>


	<p>efficiency</p>


	<p>Also needed for threads and oo to avoid generating writer methods.
Define immutable and final classes.</p>


	<h3>optional function signatures and type declarations</h3>


	<p>efficiency and safety, compile-time checks</p>


	<h3>efficient meta-object system, with classes, methods, roles</h3>


	<p>like Moose (i.e. <span class="caps">CLOS</span>), but ~800x faster and with native type support.
i.e. compile-time checks.</p>


	<h3>sized arrays</h3>


	<p>efficiency</p>


	<h3>no magic</h3>


	<p>efficiency</p>


	<h3>match operator</h3>


	<p>expressibility</p>


	<p>A proper matcher should be able to match structures and types, and to
bind result variables.</p>


	<h3>dynamic and cleaned up parser</h3>


	<p>maintainability.
new technology (risc and code maintainability), but needed for macros.</p>


	<p>allow sensible language features, disallowed by p5p or the old yacc
parser.  the parser grammar needs to be expressive, even for perl,
which is known to be hard to parse, and dynamic at parse-time
(prototypes).</p>


	<p>new syntactic constructs needs to added to the grammar, not elsewhere
in the code.  the parser needs to be accessible and extendable at
compile-time, maybe even run-time, but we cannot use a non-optimized
pure top-down parser as e.g. lua to enable this.</p>


	<p>we need to precompile the base grammar, bootstrap system macros and
allow user macros. expose the parser <span class="caps">API</span> to the user. query and
insert rules. use custom rules to parse ffi declarations (c headers)
templates, ... or even basic, ruby, python or perl6.</p>


	<p>bc. {
  use v6;
  # perl6 syntax&#8230;
}</p>


	<p><em>(this will need a pre-compiled <code>syntax-p6.g</code> and scoped syntax)</em></p>


	<p>Either done by extending packrat greg (ie leg) by with a parser
interpreter to add rules at run-time, &#8211; from precompiled rules and
user-added rules &#8211; or by extending marpa to be extensible.</p>


	<h3>macros as parser extensions</h3>


	<p>expressibility (lisp-like)
keep the vm small, do not prototype everything in the C library.
use the existing parser engine.</p>


	<p>macro args are rules (non-terminals) and terminals (strings) to be
added to the parser, the macro block is evaluated at compile-time,
with `...` expanded at run-time.</p>


	<p>so perl will be the first non-lisp like language with a proper macro
system, i.e. extending parser grammars. perl6 has similar ideas using peg
at run-time, but their syntactic macros are too complicated for me.
maybe using the perl6 <rule> syntax looks ok. <em>(i.e. <block> below)</em></p>


	<p>There are some similar non-mainstream approaches, on mono or java or
haskell, but none on fast, compiled to C scripting languages.</p>


	<p>bc. syntax-p5.g:
    block = &#8216;{&#8217; s:statements* &#8216;}&#8217; { $$ = PN_AST(BLOCK, s); }</p>


	<p>bc.  macro ifdebug block &#8216;ifdebug&#8217; {
  if ($DEBUG) `block`;
}
{ call() } ifdebug;</p>


	<h3>auto-threads</h3>


	<p>the p2/potion data-structures, compiler, vm, gc, interpreter are
thread-safe.</p>


	<p>with a OO task and scheduler interface as in parrot (pre-create,
useful esp. for windows alarms),
or as in Go (similar),
or maybe only non-autothreaded as in lua, with just first-class
  coroutines, methods: create, status, resume, yield, wrap</p>


	<h3>ffi</h3>


	<p>builtin
extendability, maintainance</p>


	<p>maybe ctypes alike, maybe something simplier or more advanced.
(i.e. import parses header files and generates all ffi functions
and types, or on the hand only support the bare cc types:
signed/unsigned, void/byte/short/long/ptr float/double/long double)</p>
</div></body></html>
