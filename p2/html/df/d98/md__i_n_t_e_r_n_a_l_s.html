<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>p2: ~ the nature of potion&#39;s insides ~</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">p2
   &#160;<span id="projectnumber">0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('df/d98/md__i_n_t_e_r_n_a_l_s.html','../../');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">~ the nature of potion's insides ~ </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Potion's internals are based around the idea that things that happen frequently should be given the greater attention.</p>
<p>For example, code execution happens more often than code parsing and loading. Therefore, the VM is larger and faster than the parser and compiler.</p>
<p>Other things that happen frequently:</p>
<ul>
<li>Math.</li>
<li>Conditionals.</li>
<li>Method dispatch.</li>
<li>Local variables.</li>
<li>Strings, to build and compare.</li>
<li>Memory allocation.</li>
</ul>
<p>More sporadic things likely include:</p>
<ul>
<li>New methods.</li>
<li>Creation of classes.</li>
<li>Very deep scoping situations.</li>
<li>Altering the inheritance tree.</li>
<li>Evals.</li>
<li>Code allocation.</li>
</ul>
<p>So understand that often the choices made in Potion's VM are designed to accomodate the first set rather than the second.</p>
<h1>~</h1>
<p>This doc is going to touch quite a bit on the JIT, compiling straight to x86 and PowerPC instructions. So many languages are targetting the JVM and .Net these days, or try to use 30MB LLVM just for adding jit support. It made me wonder what the hurdles are to generating machine code directly.</p>
<p>Clearly, the biggest benefit of having a common runtime is garbage collection. The JVM and .Net have some wild GC algorithms built in. And that's actually a huge benefit. I only wish that more garbage collectors were available as libraries.</p>
<p>Anyways, my favorite language has been Ruby for many years, that's partially because I like how easy it is to script from C, for some efficiency where I need it. So Potion is my little attempt to make a language that feels easy, but compiles to machine code, to give me the speed of (un-optimized) C code and to use all the C function call conventions so that I can link to other C libs. I want to see if its still possible to encroach on C.</p>
<p>I should say that O'Caml and Haskell already do a fine job as C competitors, so it's not like anything here is that new.</p>
<h2>~ lua's influence ~</h2>
<p>Potion uses a register-based bytecode VM that is nearly a word-for-word copy of Lua's. The code is all different, but the bytecode is nearly identical. And Lua's 5.1 bytecode design is heavily inspired by the 1997 Inferno OS "Dis VM". <a href="http://doc.cat-v.org/inferno/4th_edition/dis_VM_specification">http://doc.cat-v.org/inferno/4th_edition/dis_VM_specification</a> which was Lucent's faster and smaller competitor of Sun's stack-based and GC-heavy JVM. Dis/Limbo/Inferno concepts only got a recent boost with Google adopting it as natively compiled Go.</p>
<p>I also spelunked Neko VM for some ideas and found this comparison very useful. <a href="http://nekovm.org/lua">http://nekovm.org/lua</a></p>
<p>I also took from the Lua the notion of using tables for everything. And, like Lua, lists and tables are interchangeable. But, in Potion, I kept their representations separate.</p>
<p>I also use immutable strings, like Lua.</p>
<p>However, my object representation is more like Neko or Ruby, where objects are all represented by a word (32-bit on x86 and 64-bit on x86-64).</p>
<h2>~ the parts of potion ~</h2>
<ol type="1">
<li>the parser<ul>
<li>written in peg (see <code>core/syntax.g</code>)</li>
<li>produces a syntax tree</li>
<li>the tree is a Potion object that can be traversed in the code</li>
<li>see <code><a class="el" href="../../dc/dc6/struct_p_n_source.html#a151e2c8be44d7a886347ca3f88b91755">potion_source_load()</a></code> in <code><a class="el" href="../../d2/d47/compile_8c.html" title="ast to bytecode.">core/compile.c</a></code></li>
</ul>
</li>
</ol>
<ol type="1">
<li>the compiler<ul>
<li>compiles a syntax tree into bytecode (see <code><a class="el" href="../../d2/d47/compile_8c.html" title="ast to bytecode.">core/compile.c</a></code> or <code>./potion -c -V code.pn</code>)</li>
<li>has its own file format (save to <code>.pnb</code> files)</li>
<li>interception of keywords happens here, rather than in the parser, to simplify parsing</li>
</ul>
</li>
</ol>
<ol type="1">
<li>the bytecode vm<ul>
<li>executes bytecode</li>
<li>used mostly to ensure correctness</li>
<li>helpful in debugging</li>
<li>run code on non jitted vm with performance penalty</li>
</ul>
</li>
</ol>
<ol type="1">
<li>the jit vm<ul>
<li>compiles bytecode into a function pointer</li>
<li>uses the same argument passing strategy as c functions</li>
</ul>
</li>
</ol>
<ol type="1">
<li>the garbage collector<ul>
<li>generational, copying, near exact</li>
<li>marks the stack, then uses a cheney loop to catch everything else</li>
<li>stack scanning is automatic (both the jit and the bytecode vm keep their registers on the call stack)</li>
<li>liberal use of volatile for object pointers, to allow them to move after any allocation</li>
<li>based on a collector called qish</li>
</ul>
</li>
</ol>
<h2>~ the jit ~</h2>
<p>potions jits intel x86 32+64-bit and ppc. arm jit is in preparation. ppc callcc/yield is buggy. The X86 JIT is in <code><a class="el" href="../../db/de5/vm-x86_8c.html" title="the x86 and x86_64 jit.">core/vm-x86.c</a></code>. The jit translates Potion bytecode into 32-bit or 64-bit machine code.</p>
<p>In the code: </p>
<pre class="fragment">add = (x, y): x + y.
</pre><p>The <code>add</code> closure is compiled into a c function pointer looking like this: </p>
<pre class="fragment">PN (*)(Potion *P, PN cl, PN self, PN x, PN y)
</pre><p>This means you can actually load this closure into C and call it directly. </p>
<pre class="fragment">Potion *P = potion_create();
PN add = potion_eval(P, "(x, y): x + y.");
PN_F addfn = PN_CLOSURE_F(add);
PN num = addfn(P, 0, 0, PN_NUM(3), PN_NUM(5));
printf("3 + 5 = %d\n", PN_INT(num));
</pre><p>The macros are there to allow bytecode to be wrapped in a function pointer, if needed. The inside story looks like this: </p>
<pre class="fragment">PN num = ((struct PNClosure *)add)-&gt;method(
           P, 0, 0, PN_NUM(3), PN_NUM(5));
</pre><h2>~ the jit's assembly ~</h2>
<p>Now, let's talk about the compiled code.</p>
<p>Earlier the example was, </p>
<pre class="fragment">add = (x, y): x + y.
</pre><p>So we have a function with two arguments and a math operation.</p>
<p>The C equivalent is, </p>
<pre class="fragment">PN add(Potion *P, PN cl, PN self, PN x, PN y) {
  PN reg1 = x;
  PN reg2 = y;
  reg1 = PN_NUM(PN_INT(reg1) + PN_INT(reg2));
  return reg1;
}
</pre><p>The arguments are moved to registers on the stack. Then converted to ints. Then added. And, lastly, the result is cast as a Potion object.</p>
<p>The machine code produced by the JIT will be very close to the code produced by a compiler with the optimizations turned off. (<em>At least for the present this is true.</em>)</p>
<p>Like C functions, Potion keeps local variables on the stack. The call stack is like a big tape measure that goes on and on. Since this function has two registers (reg1 and reg2,) we need two inches from the tape measure.</p>
<p><a href="http://en.wikipedia.org/wiki/Call_stack">http://en.wikipedia.org/wiki/Call_stack</a> (See the parts that say "Local data storage" and "Argument passing".)</p>
<p>Our machine code says _"give me two word-sized
slots in the stack"_ as the first order of business.</p>
<p>We store <code>x</code> and <code>y</code> in those two slots. (See the comment about C argument passing in the next section.)</p>
<p>Then we do the math. Even the <code>PN_INT</code> and <code>PN_NUM</code> macros are fundamentally math.</p>
<p>If you run potion with <code>-V</code> or <code>--verbose</code> on this script, you'll see a bytecode disassembly. </p>
<pre class="fragment">; function ; 16 bytes
; (x, y) 2 registers
.local "x" ; 0
.local "y" ; 1
[1] getlocal 0 0
[2] getlocal 1 1
[3] add 0 1
[4] return 0
</pre><p>Each of these lines corresponds to a line of C code inside that function a few paragraphs back. You see how they line up there?</p>
<h2>~ x86 and x86-64 ~</h2>
<p>64-bit CPU instructions are a superset of 32-bit CPU instructions. And many 32-bit instructions can be converted to 64-bit by prefixing them.</p>
<p>Take this code, </p>
<pre class="fragment">8b 55 f8  // mov %ebp[-1] %edx
8b 45 fc  // mov %ebp[-2] %eax
83 e8 04  // sub 0x4 %edx
89 50 04  // mov %edx %eax[1]
</pre><p>These are the 32-bit instructions for altering an upval. (<em>A variable in upper scope</em>.) Since a closure doesn't have access to the registers of another function, these variables are passed as pointers (the <code><a class="el" href="../../d2/d49/struct_p_n_weak_ref.html" title="a weak ref is used for upvals, it acts as a memory slot, non-volatile but mutable.">PNWeakRef</a></code> struct.)</p>
<p>This code loads the upval into <code>eax</code> and the new value into <code>edx</code>. To get the upval's actual struct pointer, we subtract 4 from <code>edx</code>. Finally, we move the new value into offset 4 in the struct pointed to by the upval.</p>
<p>In 64-bit code this would be, </p>
<pre class="fragment">48 8b 55 f0  // mov %rbp[-1] %rdx
48 8b 45 f8  // mov %rbp[-2] %rax
83 e8 04     // sub 0x4 %edx
48 89 50 08  // mov %rdx %rax[1]
</pre><p>All it took was adding the <code>0x48</code> prefix to our mov instructions and changing our offsets to measure 8 bytes rather than 4. The third instruction actually stays the same, since we're only doing math on the lower 32-bits of the upval.</p>
<p>We now call the registers <code>rax</code> and <code>rdx</code>. That's just what the CPU folks call <code>em</code>.</p>
<p>The only other technique that changes between 32-bit and 64-bit is function calling. On 32- bit, we keep all the function arguments on the stack. On 64-bit, some function arguments are passed through registers.</p>
<p>That's the purpose behind the function named <code>potion_x86_c_arg</code>. To shuttle the arguments in and out, depending on the architecture.</p>
<h2>~ using disassemblers ~</h2>
<p>I don't really know the x86 instruction set too well and most often I just write something in C and disassemble it. </p>
<pre class="fragment">$ gcc test.c -o test
$ objdump --disassemble-all test
</pre><p>However, <code>objdump</code> doesn't come with the OS X dev tools, so you can use the included <code>tools/machodis.pl</code> by Robert Kelp to inspect the binary. </p>
<pre class="fragment">$ ./tools/machodis.pl test
</pre><p>If you compile with <code>make DEBUG=1</code> and <code>config.mak</code> finds any of the following disassembly libraries <em>udis86</em>, <em>libdistorm64</em> or <em>libdisam</em>, they are used automatically. See <code><a class="el" href="../../d3/dea/vm-dis_8c.html" title="interface to various jit disassembler libs.">core/vm-dis.c</a></code> and <code>config.mak</code>.</p>
<h2>~ the garbage collector ~</h2>
<p>Potion's garbage collector is based on the work Basile Starynkevitch performed with his small generational GC entitled <em>Qish</em>. As with everything else in Potion, the goal isn't to be the best, but to experiment with what sort of advanced features can be squeezed into a language while keeping the code compact.</p>
<p>Since Potion interpreters are per-thread, each interpreter has its own GC heap. This allows interpreters to run in parallel and to start up and shut down independently. Perhaps one day the GC will run in parallel.</p>
<p>Qish is a two-finger generational collector. (Also called a <em>Cheney loop</em>.) This collector only has two generations. When the time for garbage collection arrives, everything from the call stack is scanned and moved from the young gen to the older gen. The insides of all those objects are then scanned and moved as well. The goal is simply to wipe out the birth region and replace it with another.</p>
<p>What about objects from the birth region that are stored off in some old hashtable somewhere? Or stuff added to a global object?</p>
<p>The birth region has a write barrier: an array of pointers to any object which has recently changed. If a new object is added to a tuple, it's the tuple's job to notify GC so that the tuple will get scanned on the next GC pass.</p>
<p>What happens when the old generation runs out of room? A new old generation is allocated and we do a major collection: the call stack is scanned and everything from the birth region AND the full-to-the-brim older region are both scanned and moved on to the new generation.</p>
<p>This all has some obvious pitfalls. First, that's a lot of memory moving around all the time &ndash; pointers moving around. And, second, that's a lot of scanning to do: does the entire heap have to be scanned every time there's a major collection?</p>
<p>Yes, it's a lot of work and I hope to get some real benchmarks and determine a new strategy to buy some speed: either through introducing a third generation or by defragmenting memory or by allowing pages to be partially unmapped. Probably the last one: I'll weight sections of the older generation and then clear out those sections as they become more sparse.</p>
<p>As for moving pointers around, that's why the volatile keyword is a part of the PN typedef.</p>
<p>Does Potion perform <em>exact GC</em>? Not strictly. During the stack scanning phase, Potion has no idea what pointers are legit. For now, this is resolved by investigating the header of each pointer's object for a valid type object. The type can then be compared with the contents of the object to be sure the object is real. To me, this feels exact enough. (If, in practice, it proves to be too messy, I may resort to using a macro to identify exact pointers, just as Qish does.)</p>
<h2>~ the volatile keyword ~</h2>
<p>Since objects move freely about, Potion requires use of the <em>volatile</em> keyword for all access to object ids (<code>PN</code>) from C. As most people don't readily understand the volatile keyword, let's go over it.</p>
<p>There are three common uses of the volatile keyword in Potion code: </p>
<pre class="fragment">PN string = potion_byte_str("...");
</pre><p>Since <code>volatile</code> is part of the PN typedef this code actually means: </p>
<pre class="fragment">volatile unsigned long string =
  potion_byte_str("...");
</pre><p>In this case, the <code>volatile</code> keyword will generally prevent the PN from being stored in a system register when the code is optimized. Even for caching purposes.</p>
<p>So any time the <code>string</code> variable is used, it'll be looked up directly on the stack. This means the code won't be optimized fully, but it also means the value will be looked up every time we use it, in case GC has changed the object's place on us. </p>
<pre class="fragment">struct PNObject * volatile string = ...;
</pre><p>If we cast the string to a <code><a class="el" href="../../da/dbb/struct_p_n_object.html" title="standard objects act like C structs the fields are defined by the type and it&#39;s a fixed size...">PNObject</a></code> pointer, we need to be sure to place the <code>volatile</code> keyword after the star. This tells the compiler that the <em>pointer</em> is the volatile one, not the struct itself. </p>
<pre class="fragment">struct PNUserType {
  PN_OBJECT_HEADER
  PN a, b, c;
};
</pre><p>Lastly, in any structs which are wrapped by a Potion object, you need to be sure that any object handles are marked volatile as well. In the above case, the PN typedef handles that.</p>
<p>This is a bit tedious to keep in mind, but is compensated for by Potion's automatic stack scanning (a technique which has brought easy C extensions to Ruby) and object convention (if your object pointers are all 8-byte aligned, you won't need to write a GC marking function.)</p>
<h2>~ the fixed memory section ~</h2>
<p>Potion does have one other section of memory: a permanent generation containing all of the objects that are used to bootstrap Potion's environment. The <a class="el" href="../../db/dd7/class_lobby.html" title="root namespace, the global environment and parent class of all builtins.">Lobby</a> object, the class lookup table, the GC structures, etc.</p>
<p>This section of memory is positioned at the beginning of the first birth area. After the birth area, fills that memory is detached (like the saucer section of the Enterprise) and lives its life independantly of the other regions, not to be moved or released until the Potion interpreter is destroyed.</p>
<h2>~ object overhead ~</h2>
<p>Primitives (such as numbers, booleans and nil) are immediate values in Potion, kept in registers.</p>
<p>Everything else is given a spot in memory. Every allocated object has a single word header specifying its type. Here's a breakdown of what each object looks like on 32-bit: </p>
<pre class="fragment">PNObject = 4 + (N * 4) bytes
  4 bytes (type = 0x250009)
  N * 4 bytes (each object field)

PNWeakRef = 8 bytes
  4 bytes (type = 0x250004)
  4 bytes (pointer to object)

PNString = 13 + N bytes
  4 bytes (type = 0x250003)
  4 bytes (length of string)
  4 bytes (an incremental id used as hash)
  N + 1 bytes (UTF-8 + '\0')

PNBytes = 9 + N bytes
  4 bytes (type = 0x25000c)
  4 bytes (length of string)
  N + 1 bytes (string + '\0')

PNTuple = 8 + (N * 4) bytes
  4 bytes (type = 0x250006)
  4 bytes (length of tuple)
  N * 4 bytes (each tuple item)

PNClosure = 16 + (N * 4) bytes
  4 bytes (type = 0x25005)
  4 bytes (function pointer)
  4 bytes (signature pointer)
  4 bytes (length of attached data)
  N * 4 bytes (attached data)

PNData = 8 + N bytes
  4 bytes (type = 0x250011)
  4 bytes (length of contained data)
  N bytes (data)
</pre><p>The smallest allocation unit in Potion is 16 bytes. Everything larger than 16 bytes is aligned to 8 bytes. This is true for both 32-bit and 64-bit platforms.</p>
<p>The reason for this figure is to allow room for the <code><a class="el" href="../../d4/d78/struct_p_n_fwd.html" title="forwarding pointer (in case of reallocation)">PNFwd</a></code> struct: </p>
<pre class="fragment">unsigned int  // POTION_FWD or POTION_COPIED
unsigned int  // allocated space in this slot
unsigned long // pointer to moved object
</pre><p>Any time an object is moved by GC or reallocated, a temporary <code><a class="el" href="../../d4/d78/struct_p_n_fwd.html" title="forwarding pointer (in case of reallocation)">PNFwd</a></code> is placed in the memory slot to redirect callers temporarily. In practice, you shouldn't ever need to deal with these values, since the stack scanning phase will rewrite them automatically.</p>
<p>The first type of <code><a class="el" href="../../d4/d78/struct_p_n_fwd.html" title="forwarding pointer (in case of reallocation)">PNFwd</a></code> is <code>POTION_FWD</code>. This type is used for reallocation. Potion only has four built-in types that are subject to reallocation: tuples, tables, byte strings, and internal buffers. (Internal buffers are used by the JIT to store machine code output and by the object model to keep an array of type classes in circulation.)</p>
<p>The <code>POTION_FWD</code> pointers will happen between GC cycles, so they stay in place for awhile. The API around those four built-ins is designed to check for forwarded pointers whenever they're passed in as an object. One the next GC cycle hits all the pointers will be updated to use the new objects (even if <code>POTION_FWD</code> occurs in the old generation, due to the write barrier.)</p>
<p>The other <code><a class="el" href="../../d4/d78/struct_p_n_fwd.html" title="forwarding pointer (in case of reallocation)">PNFwd</a></code> type is a <code>POTION_COPIED</code> pointer. This is used by the GC to denote an object which has moved to the old generation. These should not appear outside the GC cycle. The <code><a class="el" href="../../d4/d78/struct_p_n_fwd.html" title="forwarding pointer (in case of reallocation)">PNFwd</a></code> is placed immediately when the object is moved and is then used to rewrite pointers found on the stack or inside other objects. After the GC cycle, these pointers will disappear when the its outdated generation is discarded. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu May 09 2013 for p2 "0.0" (date="2013-05-09")
by <a href='http://www.doxygen.org/index.html'>doxygen</a> 1.8.1.2
</small></address></body></html>
