<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
<title>node</title>
<meta name='robots' content='noindex,nofollow' />
<meta name='generator' content='GLOBAL-6.2.8' />
<meta http-equiv='Content-Style-Type' content='text/css' />
<link rel='stylesheet' type='text/css' href='../style.css' />
</head>
<body>
<pre>
<span class='curline'><a href='../S/162.html#L177'>node</a>              177 syn/compile.c  static void callErrBlock(Node * node) {</span>
<span class='curline'><a href='../S/162.html#L178'>node</a>              178 syn/compile.c      fprintf(output, " { YY_XTYPE YY_XVAR = (YY_XTYPE) G-&gt;data; int yyindex = G-&gt;offset + G-&gt;pos; %s; }", ((struct Any*) node)-&gt;errblock);</span>
<span class='curline'><a href='../S/162.html#L181'>node</a>              181 syn/compile.c  static void Node_compile_c_ko(Node *node, int ko)</span>
<span class='curline'><a href='../S/162.html#L183'>node</a>              183 syn/compile.c    assert(node);</span>
<span class='curline'><a href='../S/162.html#L184'>node</a>              184 syn/compile.c    switch (node-&gt;type)</span>
<span class='curline'><a href='../S/162.html#L187'>node</a>              187 syn/compile.c        fprintf(stderr, "\ninternal error #1 (%s)\n", node-&gt;rule.name);</span>
<span class='curline'><a href='../S/162.html#L198'>node</a>              198 syn/compile.c        fprintf(output, "  if (!yy_%s(G)) ", node-&gt;name.rule-&gt;rule.name);</span>
<span class='curline'><a href='../S/162.html#L199'>node</a>              199 syn/compile.c        if(((struct Any*) node)-&gt;errblock) {</span>
<span class='curline'><a href='../S/162.html#L201'>node</a>              201 syn/compile.c  	callErrBlock(node);</span>
<span class='curline'><a href='../S/162.html#L208'>node</a>              208 syn/compile.c        if (node-&gt;name.variable) {</span>
<span class='curline'><a href='../S/162.html#L211'>node</a>              211 syn/compile.c  		node-&gt;name.variable-&gt;variable.offset, node-&gt;name.rule-&gt;rule.name);</span>
<span class='curline'><a href='../S/162.html#L219'>node</a>              219 syn/compile.c  	int len= strlen(node-&gt;string.value);</span>
<span class='curline'><a href='../S/162.html#L222'>node</a>              222 syn/compile.c  	    if ('\'' == node-&gt;string.value[0])</span>
<span class='curline'><a href='../S/162.html#L225'>node</a>              225 syn/compile.c  	      fprintf(output, "  if (!yymatchChar(G, '%s')) goto l%d;\n", node-&gt;string.value, ko);</span>
<span class='curline'><a href='../S/162.html#L228'>node</a>              228 syn/compile.c  	  if (2 == len &amp;&amp; '\\' == node-&gt;string.value[0])</span>
<span class='curline'><a href='../S/162.html#L229'>node</a>              229 syn/compile.c  	    fprintf(output, "  if (!yymatchChar(G, '%s')) goto l%d;\n", node-&gt;string.value, ko);</span>
<span class='curline'><a href='../S/162.html#L231'>node</a>              231 syn/compile.c  	    fprintf(output, "  if (!yymatchString(G, \"%s\")) goto l%d;\n", node-&gt;string.value, ko);</span>
<span class='curline'><a href='../S/162.html#L238'>node</a>              238 syn/compile.c  	char *tmp = yyqq((char*)node-&gt;cclass.value);</span>
<span class='curline'><a href='../S/162.html#L239'>node</a>              239 syn/compile.c  	fprintf(output, "  if (!yymatchClass(G, (unsigned char *)\"%s\", \"%s\")) goto l%d;\n", makeCharClass(node-&gt;cclass.value), tmp, ko);</span>
<span class='curline'><a href='../S/162.html#L240'>node</a>              240 syn/compile.c  	if (tmp != (char*)node-&gt;cclass.value) free(tmp);</span>
<span class='curline'><a href='../S/162.html#L246'>node</a>              246 syn/compile.c        fprintf(output, "  yyDo(G, yy%s, G-&gt;begin, G-&gt;end, \"yy%s\");\n", node-&gt;action.name, node-&gt;action.name);</span>
<span class='curline'><a href='../S/162.html#L251'>node</a>              251 syn/compile.c        fprintf(output, "  yyText(G, G-&gt;begin, G-&gt;end);\n  if (!(%s)) goto l%d;\n", node-&gt;action.text, ko);</span>
<span class='curline'><a href='../S/162.html#L259'>node</a>              259 syn/compile.c  	for (node= node-&gt;alternate.first;  node;  node= node-&gt;alternate.next)</span>
<span class='curline'><a href='../S/162.html#L260'>node</a>              260 syn/compile.c  	  if (node-&gt;alternate.next)</span>
<span class='curline'><a href='../S/162.html#L263'>node</a>              263 syn/compile.c  	      Node_compile_c_ko(node, next);</span>
<span class='curline'><a href='../S/162.html#L269'>node</a>              269 syn/compile.c  	    Node_compile_c_ko(node, ko);</span>
<span class='curline'><a href='../S/162.html#L276'>node</a>              276 syn/compile.c        for (node= node-&gt;sequence.first;  node;  node= node-&gt;sequence.next)</span>
<span class='curline'><a href='../S/162.html#L277'>node</a>              277 syn/compile.c  	Node_compile_c_ko(node, ko);</span>
<span class='curline'><a href='../S/162.html#L285'>node</a>              285 syn/compile.c  	Node_compile_c_ko(node-&gt;peekFor.element, ko);</span>
<span class='curline'><a href='../S/162.html#L296'>node</a>              296 syn/compile.c  	Node_compile_c_ko(node-&gt;peekFor.element, ok);</span>
<span class='curline'><a href='../S/162.html#L309'>node</a>              309 syn/compile.c  	Node_compile_c_ko(node-&gt;query.element, qko);</span>
<span class='curline'><a href='../S/162.html#L325'>node</a>              325 syn/compile.c  	Node_compile_c_ko(node-&gt;star.element, out);</span>
<span class='curline'><a href='../S/162.html#L336'>node</a>              336 syn/compile.c  	Node_compile_c_ko(node-&gt;plus.element, ko);</span>
<span class='curline'><a href='../S/162.html#L340'>node</a>              340 syn/compile.c  	Node_compile_c_ko(node-&gt;plus.element, out);</span>
<span class='curline'><a href='../S/162.html#L349'>node</a>              349 syn/compile.c        fprintf(stderr, "\nNode_compile_c_ko: illegal node type %d\n", node-&gt;type);</span>
<span class='curline'><a href='../S/162.html#L355'>node</a>              355 syn/compile.c  static int countVariables(Node *node)</span>
<span class='curline'><a href='../S/162.html#L358'>node</a>              358 syn/compile.c    while (node)</span>
<span class='curline'><a href='../S/162.html#L361'>node</a>              361 syn/compile.c        node= node-&gt;variable.next;</span>
<span class='curline'><a href='../S/162.html#L366'>node</a>              366 syn/compile.c  static void defineVariables(Node *node)</span>
<span class='curline'><a href='../S/162.html#L369'>node</a>              369 syn/compile.c    while (node)</span>
<span class='curline'><a href='../S/162.html#L372'>node</a>              372 syn/compile.c        fprintf(output, "  #define %s G-&gt;val[%d]\n", node-&gt;variable.name, --count);</span>
<span class='curline'><a href='../S/162.html#L373'>node</a>              373 syn/compile.c        node-&gt;variable.offset= count;</span>
<span class='curline'><a href='../S/162.html#L374'>node</a>              374 syn/compile.c        node= node-&gt;variable.next;</span>
<span class='curline'><a href='../S/162.html#L378'>node</a>              378 syn/compile.c  static void undefineVariables(Node *node)</span>
<span class='curline'><a href='../S/162.html#L380'>node</a>              380 syn/compile.c    while (node)</span>
<span class='curline'><a href='../S/162.html#L383'>node</a>              383 syn/compile.c        fprintf(output, "  #undef %s\n", node-&gt;variable.name);</span>
<span class='curline'><a href='../S/162.html#L384'>node</a>              384 syn/compile.c        node= node-&gt;variable.next;</span>
<span class='curline'><a href='../S/162.html#L389'>node</a>              389 syn/compile.c  static void Rule_compile_c2(Node *node)</span>
<span class='curline'><a href='../S/162.html#L391'>node</a>              391 syn/compile.c    assert(node);</span>
<span class='curline'><a href='../S/162.html#L392'>node</a>              392 syn/compile.c    assert(Rule == node-&gt;type);</span>
<span class='curline'><a href='../S/162.html#L394'>node</a>              394 syn/compile.c    if (!node-&gt;rule.expression)</span>
<span class='curline'><a href='../S/162.html#L395'>node</a>              395 syn/compile.c      fprintf(stderr, "rule '%s' used but not defined\n", node-&gt;rule.name);</span>
<span class='curline'><a href='../S/162.html#L400'>node</a>              400 syn/compile.c        if ((!(RuleUsed &amp; node-&gt;rule.flags)) &amp;&amp; (node != start))</span>
<span class='curline'><a href='../S/162.html#L401'>node</a>              401 syn/compile.c  	fprintf(stderr, "rule '%s' defined but not used\n", node-&gt;rule.name);</span>
<span class='curline'><a href='../S/162.html#L403'>node</a>              403 syn/compile.c        safe= ((Query == node-&gt;rule.expression-&gt;type) || (Star == node-&gt;rule.expression-&gt;type));</span>
<span class='curline'><a href='../S/162.html#L405'>node</a>              405 syn/compile.c        fprintf(output, "\nYY_RULE(int) yy_%s(GREG *G)\n{", node-&gt;rule.name);</span>
<span class='curline'><a href='../S/162.html#L407'>node</a>              407 syn/compile.c        if (node-&gt;rule.variables)</span>
<span class='curline'><a href='../S/162.html#L408'>node</a>              408 syn/compile.c  	fprintf(output, "  yyDo(G, yyPush, %d, 0, \"yyPush\");\n", countVariables(node-&gt;rule.variables));</span>
<span class='curline'><a href='../S/162.html#L409'>node</a>              409 syn/compile.c        fprintf(output, "  yyprintfv((stderr, \"%%s\\n\", \"%s\"));\n", node-&gt;rule.name);</span>
<span class='curline'><a href='../S/162.html#L410'>node</a>              410 syn/compile.c        Node_compile_c_ko(node-&gt;rule.expression, ko);</span>
<span class='curline'><a href='../S/162.html#L411'>node</a>              411 syn/compile.c        fprintf(output, "  yyprintfokrule(\"%s\");\n", node-&gt;rule.name);</span>
<span class='curline'><a href='../S/162.html#L412'>node</a>              412 syn/compile.c        if (node-&gt;rule.variables)</span>
<span class='curline'><a href='../S/162.html#L413'>node</a>              413 syn/compile.c  	fprintf(output, "  yyDo(G, yyPop, %d, 0, \"yyPop\");\n", countVariables(node-&gt;rule.variables));</span>
<span class='curline'><a href='../S/162.html#L419'>node</a>              419 syn/compile.c  	  fprintf(output, "  yyprintfvfailrule(\"%s\");\n", node-&gt;rule.name);</span>
<span class='curline'><a href='../S/162.html#L425'>node</a>              425 syn/compile.c    if (node-&gt;rule.next)</span>
<span class='curline'><a href='../S/162.html#L426'>node</a>              426 syn/compile.c      Rule_compile_c2(node-&gt;rule.next);</span>
<span class='curline'><a href='../S/162.html#L905'>node</a>              905 syn/compile.c  int consumesInput(Node *node)</span>
<span class='curline'><a href='../S/162.html#L907'>node</a>              907 syn/compile.c    if (!node) return 0;</span>
<span class='curline'><a href='../S/162.html#L909'>node</a>              909 syn/compile.c    switch (node-&gt;type)</span>
<span class='curline'><a href='../S/162.html#L914'>node</a>              914 syn/compile.c  	if (RuleReached &amp; node-&gt;rule.flags)</span>
<span class='curline'><a href='../S/162.html#L915'>node</a>              915 syn/compile.c  	  fprintf(stderr, "possible infinite left recursion in rule '%s'\n", node-&gt;rule.name);</span>
<span class='curline'><a href='../S/162.html#L918'>node</a>              918 syn/compile.c  	    node-&gt;rule.flags |= RuleReached;</span>
<span class='curline'><a href='../S/162.html#L919'>node</a>              919 syn/compile.c  	    result= consumesInput(node-&gt;rule.expression);</span>
<span class='curline'><a href='../S/162.html#L920'>node</a>              920 syn/compile.c  	    node-&gt;rule.flags &amp;= ~RuleReached;</span>
<span class='curline'><a href='../S/162.html#L927'>node</a>              927 syn/compile.c      case Name:		return consumesInput(node-&gt;name.rule);</span>
<span class='curline'><a href='../S/162.html#L929'>node</a>              929 syn/compile.c      case String:	return strlen(node-&gt;string.value) &gt; 0;</span>
<span class='curline'><a href='../S/162.html#L937'>node</a>              937 syn/compile.c  	for (n= node-&gt;alternate.first;  n;  n= n-&gt;alternate.next)</span>
<span class='curline'><a href='../S/162.html#L946'>node</a>              946 syn/compile.c  	for (n= node-&gt;alternate.first;  n;  n= n-&gt;alternate.next)</span>
<span class='curline'><a href='../S/162.html#L956'>node</a>              956 syn/compile.c      case Plus:		return consumesInput(node-&gt;plus.element);</span>
<span class='curline'><a href='../S/162.html#L959'>node</a>              959 syn/compile.c        fprintf(stderr, "\nconsumesInput: illegal node type %d\n", node-&gt;type);</span>
<span class='curline'><a href='../S/162.html#L966'>node</a>              966 syn/compile.c  void Rule_compile_c(Node *node)</span>
<span class='curline'><a href='../S/162.html#L974'>node</a>              974 syn/compile.c    for (n= node;  n;  n= n-&gt;rule.next)</span>
<span class='curline'><a href='../S/162.html#L993'>node</a>              993 syn/compile.c    Rule_compile_c2(node);</span>
<span class='curline'><a href='../S/163.html#L411'>node</a>              411 syn/greg.c       Node *node = pop(); ((struct Any *) node)-&gt;errblock = strdup(yytext); push(node); ;</span>
<span class='curline'><a href='../S/164.html#L108'>node</a>              108 syn/greg.h     extern Node *push(Node *node);</span>
<span class='curline'><a href='../S/164.html#L113'>node</a>              113 syn/greg.h     extern void  Rule_compile_c(Node *node);</span>
<span class='curline'><a href='../S/164.html#L115'>node</a>              115 syn/greg.h     extern void  Node_print(Node *node);</span>
<span class='curline'><a href='../S/164.html#L116'>node</a>              116 syn/greg.h     extern void  Rule_print(Node *node);</span>
<span class='curline'><a href='../S/164.html#L117'>node</a>              117 syn/greg.h     extern void  Rule_free(Node *node);</span>
<span class='curline'><a href='../S/166.html#L98'>node</a>               98 syn/greg.y                     ) (errblock { Node *node = pop(); ((struct Any *) node)-&gt;errblock = strdup(yytext); push(node); })?</span>
<span class='curline'><a href='../S/165.html#L40'>node</a>               40 syn/tree.c       Node *node= calloc(1, size);</span>
<span class='curline'><a href='../S/165.html#L41'>node</a>               41 syn/tree.c       node-&gt;type= type;</span>
<span class='curline'><a href='../S/165.html#L42'>node</a>               42 syn/tree.c       ((struct Any *) node)-&gt;errblock= NULL;</span>
<span class='curline'><a href='../S/165.html#L43'>node</a>               43 syn/tree.c       return node;</span>
<span class='curline'><a href='../S/165.html#L50'>node</a>               50 syn/tree.c       Node *node= newNode(Rule);</span>
<span class='curline'><a href='../S/165.html#L51'>node</a>               51 syn/tree.c       node-&gt;rule.name= strdup(name);</span>
<span class='curline'><a href='../S/165.html#L52'>node</a>               52 syn/tree.c       node-&gt;rule.id= ++ruleCount;</span>
<span class='curline'><a href='../S/165.html#L53'>node</a>               53 syn/tree.c       node-&gt;rule.flags= starts ? RuleUsed : 0;</span>
<span class='curline'><a href='../S/165.html#L54'>node</a>               54 syn/tree.c       node-&gt;rule.next= rules;</span>
<span class='curline'><a href='../S/165.html#L55'>node</a>               55 syn/tree.c       rules= node;</span>
<span class='curline'><a href='../S/165.html#L56'>node</a>               56 syn/tree.c       return node;</span>
<span class='curline'><a href='../S/165.html#L79'>node</a>               79 syn/tree.c     void Rule_setExpression(Node *node, Node *expression)</span>
<span class='curline'><a href='../S/165.html#L81'>node</a>               81 syn/tree.c       assert(node);</span>
<span class='curline'><a href='../S/165.html#L83'>node</a>               83 syn/tree.c       Node_print(node);  fprintf(stderr, " [%d]&lt;- ", node-&gt;type);  Node_print(expression);  fprintf(stderr, "\n");</span>
<span class='curline'><a href='../S/165.html#L85'>node</a>               85 syn/tree.c       assert(Rule == node-&gt;type);</span>
<span class='curline'><a href='../S/165.html#L86'>node</a>               86 syn/tree.c       node-&gt;rule.expression= expression;</span>
<span class='curline'><a href='../S/165.html#L87'>node</a>               87 syn/tree.c       if (!start || !strcmp(node-&gt;rule.name, "start"))</span>
<span class='curline'><a href='../S/165.html#L88'>node</a>               88 syn/tree.c         start= node;</span>
<span class='curline'><a href='../S/165.html#L93'>node</a>               93 syn/tree.c       Node *node;</span>
<span class='curline'><a href='../S/165.html#L95'>node</a>               95 syn/tree.c       for (node= thisRule-&gt;rule.variables;  node;  node= node-&gt;variable.next)</span>
<span class='curline'><a href='../S/165.html#L96'>node</a>               96 syn/tree.c         if (!strcmp(name, node-&gt;variable.name))</span>
<span class='curline'><a href='../S/165.html#L97'>node</a>               97 syn/tree.c           return node;</span>
<span class='curline'><a href='../S/165.html#L98'>node</a>               98 syn/tree.c       node= newNode(Variable);</span>
<span class='curline'><a href='../S/165.html#L99'>node</a>               99 syn/tree.c       node-&gt;variable.name= strdup(name);</span>
<span class='curline'><a href='../S/165.html#L100'>node</a>              100 syn/tree.c       node-&gt;variable.next= thisRule-&gt;rule.variables;</span>
<span class='curline'><a href='../S/165.html#L101'>node</a>              101 syn/tree.c       thisRule-&gt;rule.variables= node;</span>
<span class='curline'><a href='../S/165.html#L102'>node</a>              102 syn/tree.c       return node;</span>
<span class='curline'><a href='../S/165.html#L107'>node</a>              107 syn/tree.c       Node *node= newNode(Name);</span>
<span class='curline'><a href='../S/165.html#L108'>node</a>              108 syn/tree.c       node-&gt;name.rule= rule;</span>
<span class='curline'><a href='../S/165.html#L109'>node</a>              109 syn/tree.c       node-&gt;name.variable= 0;</span>
<span class='curline'><a href='../S/165.html#L111'>node</a>              111 syn/tree.c       return node;</span>
<span class='curline'><a href='../S/165.html#L121'>node</a>              121 syn/tree.c       Node *node= newNode(Character);</span>
<span class='curline'><a href='../S/165.html#L122'>node</a>              122 syn/tree.c       node-&gt;character.value= strdup(text);</span>
<span class='curline'><a href='../S/165.html#L123'>node</a>              123 syn/tree.c       return node;</span>
<span class='curline'><a href='../S/165.html#L128'>node</a>              128 syn/tree.c       Node *node= newNode(String);</span>
<span class='curline'><a href='../S/165.html#L129'>node</a>              129 syn/tree.c       node-&gt;string.value= strdup(text);</span>
<span class='curline'><a href='../S/165.html#L130'>node</a>              130 syn/tree.c       return node;</span>
<span class='curline'><a href='../S/165.html#L135'>node</a>              135 syn/tree.c       Node *node= newNode(Class);</span>
<span class='curline'><a href='../S/165.html#L136'>node</a>              136 syn/tree.c       node-&gt;cclass.value= (unsigned char *)strdup(text);</span>
<span class='curline'><a href='../S/165.html#L137'>node</a>              137 syn/tree.c       return node;</span>
<span class='curline'><a href='../S/165.html#L142'>node</a>              142 syn/tree.c       Node *node= newNode(Action);</span>
<span class='curline'><a href='../S/165.html#L146'>node</a>              146 syn/tree.c       node-&gt;action.name= strdup(name);</span>
<span class='curline'><a href='../S/165.html#L147'>node</a>              147 syn/tree.c       node-&gt;action.text= strdup(text);</span>
<span class='curline'><a href='../S/165.html#L148'>node</a>              148 syn/tree.c       node-&gt;action.list= actions;</span>
<span class='curline'><a href='../S/165.html#L149'>node</a>              149 syn/tree.c       node-&gt;action.rule= thisRule;</span>
<span class='curline'><a href='../S/165.html#L150'>node</a>              150 syn/tree.c       actions= node;</span>
<span class='curline'><a href='../S/165.html#L153'>node</a>              153 syn/tree.c         for (ptr= node-&gt;action.text;  *ptr;  ++ptr)</span>
<span class='curline'><a href='../S/165.html#L157'>node</a>              157 syn/tree.c       return node;</span>
<span class='curline'><a href='../S/165.html#L162'>node</a>              162 syn/tree.c       Node *node= newNode(Predicate);</span>
<span class='curline'><a href='../S/165.html#L163'>node</a>              163 syn/tree.c       node-&gt;predicate.text= strdup(text);</span>
<span class='curline'><a href='../S/165.html#L164'>node</a>              164 syn/tree.c       return node;</span>
<span class='curline'><a href='../S/165.html#L171'>node</a>              171 syn/tree.c           Node *node= newNode(Alternate);</span>
<span class='curline'><a href='../S/165.html#L174'>node</a>              174 syn/tree.c           node-&gt;alternate.first=</span>
<span class='curline'><a href='../S/165.html#L175'>node</a>              175 syn/tree.c     	node-&gt;alternate.last= e;</span>
<span class='curline'><a href='../S/165.html#L176'>node</a>              176 syn/tree.c           return node;</span>
<span class='curline'><a href='../S/165.html#L196'>node</a>              196 syn/tree.c           Node *node= newNode(Sequence);</span>
<span class='curline'><a href='../S/165.html#L199'>node</a>              199 syn/tree.c           node-&gt;sequence.first=</span>
<span class='curline'><a href='../S/165.html#L200'>node</a>              200 syn/tree.c     	node-&gt;sequence.last= e;</span>
<span class='curline'><a href='../S/165.html#L201'>node</a>              201 syn/tree.c           return node;</span>
<span class='curline'><a href='../S/165.html#L219'>node</a>              219 syn/tree.c       Node *node= newNode(PeekFor);</span>
<span class='curline'><a href='../S/165.html#L220'>node</a>              220 syn/tree.c       node-&gt;peekFor.element= e;</span>
<span class='curline'><a href='../S/165.html#L221'>node</a>              221 syn/tree.c       return node;</span>
<span class='curline'><a href='../S/165.html#L226'>node</a>              226 syn/tree.c       Node *node= newNode(PeekNot);</span>
<span class='curline'><a href='../S/165.html#L227'>node</a>              227 syn/tree.c       node-&gt;peekNot.element= e;</span>
<span class='curline'><a href='../S/165.html#L228'>node</a>              228 syn/tree.c       return node;</span>
<span class='curline'><a href='../S/165.html#L233'>node</a>              233 syn/tree.c       Node *node= newNode(Query);</span>
<span class='curline'><a href='../S/165.html#L234'>node</a>              234 syn/tree.c       node-&gt;query.element= e;</span>
<span class='curline'><a href='../S/165.html#L235'>node</a>              235 syn/tree.c       return node;</span>
<span class='curline'><a href='../S/165.html#L240'>node</a>              240 syn/tree.c       Node *node= newNode(Star);</span>
<span class='curline'><a href='../S/165.html#L241'>node</a>              241 syn/tree.c       node-&gt;star.element= e;</span>
<span class='curline'><a href='../S/165.html#L242'>node</a>              242 syn/tree.c       return node;</span>
<span class='curline'><a href='../S/165.html#L247'>node</a>              247 syn/tree.c       Node *node= newNode(Plus);</span>
<span class='curline'><a href='../S/165.html#L248'>node</a>              248 syn/tree.c       node-&gt;plus.element= e;</span>
<span class='curline'><a href='../S/165.html#L249'>node</a>              249 syn/tree.c       return node;</span>
<span class='curline'><a href='../S/165.html#L270'>node</a>              270 syn/tree.c     Node *push(Node *node)</span>
<span class='curline'><a href='../S/165.html#L272'>node</a>              272 syn/tree.c       assert(node);</span>
<span class='curline'><a href='../S/165.html#L275'>node</a>              275 syn/tree.c       dumpStack();  fprintf(stderr, " PUSH ");  Node_print(node);  fprintf(stderr, "\n");</span>
<span class='curline'><a href='../S/165.html#L277'>node</a>              277 syn/tree.c       return *++stackPointer= node;</span>
<span class='curline'><a href='../S/165.html#L296'>node</a>              296 syn/tree.c     static void Node_fprint(FILE *stream, Node *node)</span>
<span class='curline'><a href='../S/165.html#L298'>node</a>              298 syn/tree.c       assert(node);</span>
<span class='curline'><a href='../S/165.html#L299'>node</a>              299 syn/tree.c       switch (node-&gt;type)</span>
<span class='curline'><a href='../S/165.html#L302'>node</a>              302 syn/tree.c         case Rule:		fprintf(stream, " %s", node-&gt;rule.name);				break;</span>
<span class='curline'><a href='../S/165.html#L303'>node</a>              303 syn/tree.c         case Variable:	fprintf(stream, " %s", node-&gt;variable.name);				break;</span>
<span class='curline'><a href='../S/165.html#L304'>node</a>              304 syn/tree.c         case Name:		fprintf(stream, " %s", node-&gt;name.rule-&gt;rule.name);			break;</span>
<span class='curline'><a href='../S/165.html#L306'>node</a>              306 syn/tree.c         case Character:	fprintf(stream, " '%s'", node-&gt;character.value);			break;</span>
<span class='curline'><a href='../S/165.html#L307'>node</a>              307 syn/tree.c         case String:	fprintf(stream, " \"%s\"", node-&gt;string.value);				break;</span>
<span class='curline'><a href='../S/165.html#L308'>node</a>              308 syn/tree.c         case Class:		fprintf(stream, " [%s]", node-&gt;cclass.value);				break;</span>
<span class='curline'><a href='../S/165.html#L309'>node</a>              309 syn/tree.c         case Action:	fprintf(stream, " { %s }", node-&gt;action.text);				break;</span>
<span class='curline'><a href='../S/165.html#L310'>node</a>              310 syn/tree.c         case Predicate:	fprintf(stream, " ?{ %s }", node-&gt;action.text);				break;</span>
<span class='curline'><a href='../S/165.html#L312'>node</a>              312 syn/tree.c         case Alternate:	node= node-&gt;alternate.first;</span>
<span class='curline'><a href='../S/165.html#L314'>node</a>              314 syn/tree.c     			Node_fprint(stream, node);</span>
<span class='curline'><a href='../S/165.html#L315'>node</a>              315 syn/tree.c     			while ((node= node-&gt;any.next))</span>
<span class='curline'><a href='../S/165.html#L318'>node</a>              318 syn/tree.c     			    Node_fprint(stream, node);</span>
<span class='curline'><a href='../S/165.html#L323'>node</a>              323 syn/tree.c         case Sequence:	node= node-&gt;sequence.first;</span>
<span class='curline'><a href='../S/165.html#L325'>node</a>              325 syn/tree.c     			Node_fprint(stream, node);</span>
<span class='curline'><a href='../S/165.html#L326'>node</a>              326 syn/tree.c     			while ((node= node-&gt;any.next))</span>
<span class='curline'><a href='../S/165.html#L327'>node</a>              327 syn/tree.c     			  Node_fprint(stream, node);</span>
<span class='curline'><a href='../S/165.html#L331'>node</a>              331 syn/tree.c         case PeekFor:	fprintf(stream, "&amp;");  Node_fprint(stream, node-&gt;query.element);	break;</span>
<span class='curline'><a href='../S/165.html#L332'>node</a>              332 syn/tree.c         case PeekNot:	fprintf(stream, "!");  Node_fprint(stream, node-&gt;query.element);	break;</span>
<span class='curline'><a href='../S/165.html#L333'>node</a>              333 syn/tree.c         case Query:		Node_fprint(stream, node-&gt;query.element);  fprintf(stream, "?");	break;</span>
<span class='curline'><a href='../S/165.html#L334'>node</a>              334 syn/tree.c         case Star:		Node_fprint(stream, node-&gt;query.element);  fprintf(stream, "*");	break;</span>
<span class='curline'><a href='../S/165.html#L335'>node</a>              335 syn/tree.c         case Plus:		Node_fprint(stream, node-&gt;query.element);  fprintf(stream, "+");	break;</span>
<span class='curline'><a href='../S/165.html#L337'>node</a>              337 syn/tree.c           fprintf(stream, "\nunknown node type %d\n", node-&gt;type);</span>
<span class='curline'><a href='../S/165.html#L342'>node</a>              342 syn/tree.c     void Node_print(Node *node)	{ Node_fprint(stderr, node); }</span>
<span class='curline'><a href='../S/165.html#L344'>node</a>              344 syn/tree.c     static void Rule_fprint(FILE *stream, Node *node)</span>
<span class='curline'><a href='../S/165.html#L346'>node</a>              346 syn/tree.c       assert(node);</span>
<span class='curline'><a href='../S/165.html#L347'>node</a>              347 syn/tree.c       assert(Rule == node-&gt;type);</span>
<span class='curline'><a href='../S/165.html#L348'>node</a>              348 syn/tree.c       fprintf(stream, "%s.%d =", node-&gt;rule.name, node-&gt;rule.id);</span>
<span class='curline'><a href='../S/165.html#L349'>node</a>              349 syn/tree.c       if (node-&gt;rule.expression)</span>
<span class='curline'><a href='../S/165.html#L350'>node</a>              350 syn/tree.c         Node_fprint(stream, node-&gt;rule.expression);</span>
<span class='curline'><a href='../S/165.html#L356'>node</a>              356 syn/tree.c     void Rule_print(Node *node)	{ Rule_fprint(stderr, node); }</span>
<span class='curline'><a href='../S/165.html#L358'>node</a>              358 syn/tree.c     void Rule_free(Node *node)</span>
<span class='curline'><a href='../S/165.html#L360'>node</a>              360 syn/tree.c       switch (node-&gt;type)</span>
<span class='curline'><a href='../S/165.html#L365'>node</a>              365 syn/tree.c     	Node *var= node-&gt;rule.variables;</span>
<span class='curline'><a href='../S/165.html#L368'>node</a>              368 syn/tree.c     	fprintf(stderr, "free Rule %s.%d\n", node-&gt;rule.name, node-&gt;rule.id);</span>
<span class='curline'><a href='../S/165.html#L370'>node</a>              370 syn/tree.c     	free(node-&gt;rule.name);</span>
<span class='curline'><a href='../S/165.html#L374'>node</a>              374 syn/tree.c     	if (node-&gt;rule.expression)</span>
<span class='curline'><a href='../S/165.html#L375'>node</a>              375 syn/tree.c     	  Rule_free(node-&gt;rule.expression);</span>
<span class='curline'><a href='../S/165.html#L379'>node</a>              379 syn/tree.c         case Variable:	free(node-&gt;variable.name);		break;</span>
<span class='curline'><a href='../S/165.html#L381'>node</a>              381 syn/tree.c         case Character:	free(node-&gt;character.value);		break;</span>
<span class='curline'><a href='../S/165.html#L382'>node</a>              382 syn/tree.c         case String:	free(node-&gt;string.value);		break;</span>
<span class='curline'><a href='../S/165.html#L383'>node</a>              383 syn/tree.c         case Class:		free(node-&gt;cclass.value);		break;</span>
<span class='curline'><a href='../S/165.html#L386'>node</a>              386 syn/tree.c     	fprintf(stderr, "free Action %s\n", node-&gt;action.name);</span>
<span class='curline'><a href='../S/165.html#L388'>node</a>              388 syn/tree.c     	free(node-&gt;action.text); free(node-&gt;action.name); 	break;</span>
<span class='curline'><a href='../S/165.html#L389'>node</a>              389 syn/tree.c         case Predicate:	free(node-&gt;predicate.text);		break;</span>
<span class='curline'><a href='../S/165.html#L392'>node</a>              392 syn/tree.c     	Node *root= node;</span>
<span class='curline'><a href='../S/165.html#L394'>node</a>              394 syn/tree.c     	fprintf(stderr, "free Alternate %p\n", node);</span>
<span class='curline'><a href='../S/165.html#L396'>node</a>              396 syn/tree.c     	node= node-&gt;alternate.first;</span>
<span class='curline'><a href='../S/165.html#L397'>node</a>              397 syn/tree.c     	while (node-&gt;any.next) {</span>
<span class='curline'><a href='../S/165.html#L398'>node</a>              398 syn/tree.c     	  Node *tmp= node-&gt;any.next; Rule_free(node); node= tmp;</span>
<span class='curline'><a href='../S/165.html#L400'>node</a>              400 syn/tree.c     	Rule_free(node);</span>
<span class='curline'><a href='../S/165.html#L401'>node</a>              401 syn/tree.c     	node= root;</span>
<span class='curline'><a href='../S/165.html#L406'>node</a>              406 syn/tree.c     	Node *root= node;</span>
<span class='curline'><a href='../S/165.html#L408'>node</a>              408 syn/tree.c     	fprintf(stderr, "free Sequence %p\n", node);</span>
<span class='curline'><a href='../S/165.html#L410'>node</a>              410 syn/tree.c     	node= node-&gt;sequence.first;</span>
<span class='curline'><a href='../S/165.html#L411'>node</a>              411 syn/tree.c     	while (node-&gt;any.next) {</span>
<span class='curline'><a href='../S/165.html#L412'>node</a>              412 syn/tree.c     	  Node *tmp= node-&gt;any.next; Rule_free(node); node= tmp;</span>
<span class='curline'><a href='../S/165.html#L414'>node</a>              414 syn/tree.c     	Rule_free(node);</span>
<span class='curline'><a href='../S/165.html#L415'>node</a>              415 syn/tree.c     	node= root;</span>
<span class='curline'><a href='../S/165.html#L424'>node</a>              424 syn/tree.c           fprintf(stderr, "\nunknown node type %d\n", node-&gt;type);</span>
<span class='curline'><a href='../S/165.html#L427'>node</a>              427 syn/tree.c       assert(node);</span>
<span class='curline'><a href='../S/165.html#L428'>node</a>              428 syn/tree.c       node-&gt;type = Freed;</span>
<span class='curline'><a href='../S/165.html#L429'>node</a>              429 syn/tree.c       if (((struct Any *)node)-&gt;errblock)</span>
<span class='curline'><a href='../S/165.html#L430'>node</a>              430 syn/tree.c         free(((struct Any *)node)-&gt;errblock);</span>
<span class='curline'><a href='../S/165.html#L432'>node</a>              432 syn/tree.c       free(node);</span>
<span class='curline'><a href='../S/55.html#L62'>node</a>               62 test/api/gc-bench.c PN gc_populate_tree(PN node, int depth, PN PN_left, PN PN_right) {</span>
<span class='curline'><a href='../S/55.html#L67'>node</a>               67 test/api/gc-bench.c   potion_obj_set(P, PN_NIL, node, PN_left, ALLOC_NODE());</span>
<span class='curline'><a href='../S/55.html#L68'>node</a>               68 test/api/gc-bench.c   PN_TOUCH(node);</span>
<span class='curline'><a href='../S/55.html#L72'>node</a>               72 test/api/gc-bench.c   potion_obj_set(P, PN_NIL, node, PN_right, ALLOC_NODE());</span>
<span class='curline'><a href='../S/55.html#L73'>node</a>               73 test/api/gc-bench.c   PN_TOUCH(node);</span>
<span class='curline'><a href='../S/55.html#L77'>node</a>               77 test/api/gc-bench.c   gc_populate_tree(potion_obj_get(P, PN_NIL, node, PN_left), depth, PN_left, PN_right);</span>
<span class='curline'><a href='../S/55.html#L78'>node</a>               78 test/api/gc-bench.c   gc_populate_tree(potion_obj_get(P, PN_NIL, node, PN_right), depth, PN_left, PN_right);</span>
<span class='curline'><a href='../S/55.html#L81'>node</a>               81 test/api/gc-bench.c int gc_tree_depth(PN node, int side, int depth) {</span>
<span class='curline'><a href='../S/55.html#L82'>node</a>               82 test/api/gc-bench.c   PN n = ((struct PNObject *)node)-&gt;ivars[side];</span>
</pre>
</body>
</html>
