<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
<title>doc/p2-extensions.textile</title>
<meta name='robots' content='noindex,nofollow' />
<meta name='generator' content='GLOBAL-6.2.8' />
<meta http-equiv='Content-Style-Type' content='text/css' />
<link rel='stylesheet' type='text/css' href='../style.css' />
</head>
<body>
<!-- beginning of fixed guide -->
<div id='guide'><ul>
<li><a href='#TOP'><img class='icon' src='../icons/first.png' alt='[^]' /></a></li>
<li><a href='#BOTTOM'><img class='icon' src='../icons/last.png' alt='[v]' /></a></li>
<li><a href='#TOP'><img class='icon' src='../icons/top.png' alt='[top]' /></a></li>
<li><a href='#BOTTOM'><img class='icon' src='../icons/bottom.png' alt='[bottom]' /></a></li>
<li><a href='../mains.html'><img class='icon' src='../icons/index.png' alt='[index]' /></a></li>
<li><a href='../help.html'><img class='icon' src='../icons/help.png' alt='[help]' /></a></li>
<li class='standout'><span><a href='../files/177.html'>doc</a>/p2-extensions.textile</span></li>
</ul></div>
<!-- end of fixed guide -->
<a id='TOP' name='TOP'></a><h2 class='header'><a href='../mains.html'>root</a>/<a href='../files/177.html'>doc</a>/p2-extensions.textile</h2>
<em class='comment'>/* <img class='icon' src='../icons/n_left.png' alt='[previous]' /><img class='icon' src='../icons/n_right.png' alt='[next]' /><img class='icon' src='../icons/n_first.png' alt='[first]' /><img class='icon' src='../icons/n_last.png' alt='[last]' /><img class='icon' src='../icons/n_top.png' alt='[top]' /><a href='#BOTTOM'><img class='icon' src='../icons/bottom.png' alt='[bottom]' /></a><a href='../mains.html'><img class='icon' src='../icons/index.png' alt='[index]' /></a><a href='../help.html'><img class='icon' src='../icons/help.png' alt='[help]' /></a>&nbsp;<em class='position'>[+1 doc/p2-extensions.textile]</em> */</em>
<hr />
<pre>
<a id='L1' name='L1'></a>h1. Perl5 on p2
<a id='L2' name='L2'></a>
<a id='L3' name='L3'></a>h2. Language backwards-compatible Extensions
<a id='L4' name='L4'></a>
<a id='L5' name='L5'></a>With p2 I plan to parse and execute perl5 asis.
<a id='L6' name='L6'></a>It is still vaporware, only the compiler and vm works so far.
<a id='L7' name='L7'></a>Not the parser, compile-time type optimizations (_so far everything is dynamic_),
<a id='L8' name='L8'></a>threaded coroutines, aio, thread-safe GC, no libraries, no ffi.
<a id='L9' name='L9'></a>
<a id='L10' name='L10'></a>Problem will arise with XS code, since the VM is different, and not
<a id='L11' name='L11'></a>all XS API functions can be supported.  It should be much easier to
<a id='L12' name='L12'></a>use XS-like functionality with the new FFI, or by using extension
<a id='L13' name='L13'></a>libraries with native calls. See @lib/readline@. So we will loose
<a id='L14' name='L14'></a>40% of CPAN code, but will win on performance, expressibility and
<a id='L15' name='L15'></a>compile-time error checking when binding libs.
<a id='L16' name='L16'></a>
<a id='L17' name='L17'></a>@use p2;@ or @-E@ will enable the following extended features:
<a id='L18' name='L18'></a>
<a id='L19' name='L19'></a>h3. All data are objects, all declarations can be optionally typed
<a id='L20' name='L20'></a>
<a id='L21' name='L21'></a>I.e. all core types are implictly blessed into the int, str, num
<a id='L22' name='L22'></a>classes and mixins thereof.
<a id='L23' name='L23'></a>See "pddtypes.pod":https://github.com/rurban/perl/blob/d1c07ab82fd3acf17803a9f7dbd8e3ab3c5d3903/pddtypes.pod and "perltypes.pod":https://github.com/rurban/perl/blob/05514649c35a695734bc8e02911e7efef6ee4dde/pod/perltypes.pod for more.
<a id='L24' name='L24'></a>
<a id='L25' name='L25'></a>bc. my int $i;
<a id='L26' name='L26'></a>my const str $s = "string";
<a id='L27' name='L27'></a>my const int $h = {foo =&gt; 1, bla =&gt; 0};
<a id='L28' name='L28'></a>my const int @a = (0..9);
<a id='L29' name='L29'></a>
<a id='L30' name='L30'></a>h3. const declarations for data, @ISA, classes and functions/methods
<a id='L31' name='L31'></a>
<a id='L32' name='L32'></a>method calls should be inlinable and compile-time optimizable.
<a id='L33' name='L33'></a>
<a id='L34' name='L34'></a>h3. sized arrays
<a id='L35' name='L35'></a>
<a id='L36' name='L36'></a>bc. my $a[10];
<a id='L37' name='L37'></a>my int $a[10];
<a id='L38' name='L38'></a>
<a id='L39' name='L39'></a>Sized arrays are are non-autovivifying and initialized with undef,
<a id='L40' name='L40'></a>resp. if typed 0, 0.0, or "". This speeds up array access by factor 2-4.
<a id='L41' name='L41'></a>See "optimizing compiler benchmarks part 3":http://blogs.perl.org/users/rurban/2012/10/optimizing-compiler-benchmarks-part-3.html
<a id='L42' name='L42'></a>
<a id='L43' name='L43'></a>h3. no magic
<a id='L44' name='L44'></a>
<a id='L45' name='L45'></a>A new pragma "no magic" applies to all visible objects in scope.
<a id='L46' name='L46'></a>
<a id='L47' name='L47'></a>bc. {
<a id='L48' name='L48'></a>  no magic;
<a id='L49' name='L49'></a>  use Config;
<a id='L50' name='L50'></a>  print $Config{'ccflags'};
<a id='L51' name='L51'></a>}
<a id='L52' name='L52'></a>
<a id='L53' name='L53'></a>@=&gt; compile-time error: Invalid use of tie with no magic@
<a id='L54' name='L54'></a>
<a id='L55' name='L55'></a>use
<a id='L56' name='L56'></a>
<a id='L57' name='L57'></a>bc. {
<a id='L58' name='L58'></a>  no magic;
<a id='L59' name='L59'></a>  use Config ();
<a id='L60' name='L60'></a>  print $Config::Config{'ccflags'};
<a id='L61' name='L61'></a>}
<a id='L62' name='L62'></a>
<a id='L63' name='L63'></a>instead.
<a id='L64' name='L64'></a>
<a id='L65' name='L65'></a>See "optimizing compiler benchmarks part 3":http://blogs.perl.org/users/rurban/2012/10/optimizing-compiler-benchmarks-part-3.html
<a id='L66' name='L66'></a>
<a id='L67' name='L67'></a>h3. match operator
<a id='L68' name='L68'></a>
<a id='L69' name='L69'></a>The simple smartmatch is already taken and will just work, because all
<a id='L70' name='L70'></a>data is dynamically typed. smartmatch will use a user-defined @MATCH@ method
<a id='L71' name='L71'></a>for objects. given/when is too limited and a bit broken.
<a id='L72' name='L72'></a>
<a id='L73' name='L73'></a>But we want to match structures to find structures in lists or trees
<a id='L74' name='L74'></a>(nested structures), not only strings. regex and parsers are string matchers,
<a id='L75' name='L75'></a>match and bind are more general concepts.
<a id='L76' name='L76'></a>See "magpie patterns":http://magpie.stuffwithstuff.com/patterns.html
<a id='L77' name='L77'></a>
<a id='L78' name='L78'></a>bc. my $s = "s";
<a id='L79' name='L79'></a>match /^s/, 123, 1 {
<a id='L80' name='L80'></a>  case $s, $n is Int, $_: say "matched $s, $n, $_";
<a id='L81' name='L81'></a>  else: say "no match";
<a id='L82' name='L82'></a>}
<a id='L83' name='L83'></a>
<a id='L84' name='L84'></a>@is Int@ is a new Type Pattern, which matches a type or subtype. 
<a id='L85' name='L85'></a>It calls the typeof() function.
<a id='L86' name='L86'></a>@is@ is a new keyword to match types in patterns.
<a id='L87' name='L87'></a>@$_@ in patterns is always true and returns the given scalar value.
<a id='L88' name='L88'></a>Use @_ to match multiple expressions, the "rest".
<a id='L89' name='L89'></a>
<a id='L90' name='L90'></a>h3. extensible parser
<a id='L91' name='L91'></a>
<a id='L92' name='L92'></a>The current "leg":http://piumarta.com/software/peg/ based p2 parser can handle complicated expressions and operator
<a id='L93' name='L93'></a>precedence much better than the recursive descent LLAR @yacc@
<a id='L94' name='L94'></a>parser in @perly.y@.  No lexer needed, problematic syntax can be avoided,
<a id='L95' name='L95'></a>like previously mandatory parenthesis. E.g. @if@ or @while@ boolean expressions
<a id='L96' name='L96'></a>don't need parens.
<a id='L97' name='L97'></a>
<a id='L98' name='L98'></a>bc. if $cmp {
<a id='L99' name='L99'></a>  if $s say "$s";
<a id='L100' name='L100'></a>  else say "else";
<a id='L101' name='L101'></a>}
<a id='L102' name='L102'></a>
<a id='L103' name='L103'></a>@for@ lists should not need parens, the expressions are evaluated in list
<a id='L104' name='L104'></a>context.
<a id='L105' name='L105'></a>
<a id='L106' name='L106'></a>bc..   for $_ qw(a b c) {
<a id='L107' name='L107'></a>  }
<a id='L108' name='L108'></a>
<a id='L109' name='L109'></a>  const int[] sub get_list {(0..9)}
<a id='L110' name='L110'></a>
<a id='L111' name='L111'></a>  for my $i get_list() {
<a id='L112' name='L112'></a>    say $i;
<a id='L113' name='L113'></a>  }
<a id='L114' name='L114'></a>
<a id='L115' name='L115'></a>p. The language should be extendable. Left or right assiocative keywords
<a id='L116' name='L116'></a>should be easily added to the parser description, with statically
<a id='L117' name='L117'></a>deterministic proper precedence rules. run-time extendable
<a id='L118' name='L118'></a>associativity only with Pratt or marpa-like parsers. 
<a id='L119' name='L119'></a>with peg top-down parsers the problem is which rule to extend, and how.
<a id='L120' name='L120'></a>Anyway, I need to add a little state-machine interpreter (such as spencer regexs),
<a id='L121' name='L121'></a>or jit the state machine as in maru, or precompile grammars and macros to shared libs.
<a id='L122' name='L122'></a>
<a id='L123' name='L123'></a>The current packrat parser based on @leg@ is not quite as highly efficient and
<a id='L124' name='L124'></a>dynamically extendable as a "Pratt top-down parser":http://journal.stuffwithstuff.com/2011/02/13/extending-syntax-from-within-a-language/
<a id='L125' name='L125'></a>with special operator precedence rules in the parser table
<a id='L126' name='L126'></a>declaration, but it does not backtrack as much as @yacc@ in
<a id='L127' name='L127'></a>expressions due to memoizing, and precedence is statically defined in
<a id='L128' name='L128'></a>the rules.
<a id='L129' name='L129'></a>
<a id='L130' name='L130'></a>But in the end I'll need a dynamic parser to support macros.  The
<a id='L131' name='L131'></a>problem is that such a parser cannot be stolen yet, nobody has written
<a id='L132' name='L132'></a>so far one in C, only in LISP, C#, java or javascript. The idea to base
<a id='L133' name='L133'></a>macros on the parser probably didn't come to anyone yet outside the
<a id='L134' name='L134'></a>functional language community. Rob Pike recently presented a nice and easy-enough
<a id='L135' name='L135'></a>ad-hoc parser for "Go templates":https://www.youtube.com/watch?v=HxaD_trXwRE
<a id='L136' name='L136'></a>So far "marpa":http://jeffreykegler.github.com/Marpa-web-site/ seems to be the best dynamic parser library, there is a C library. 
<a id='L137' name='L137'></a>Extending it at run-time should be achievable easily, and the parser 
<a id='L138' name='L138'></a>algorithm is pretty robust. "magpie":http://journal.stuffwithstuff.com/2011/02/13/extending-syntax-from-within-a-language/, "maru":http://piumarta.com/software/maru/ and "idst":http://piumarta.com/software/cola/ provide similar dynamic
<a id='L139' name='L139'></a>extensible parsing frameworks in non-weird vm's, Haskell, JVM, .NET.
<a id='L140' name='L140'></a>
<a id='L141' name='L141'></a>h3. macros
<a id='L142' name='L142'></a>
<a id='L143' name='L143'></a>macros expose the power of the parser to the language, as in LISP.
<a id='L144' name='L144'></a>They allow extending and simplifying the language.
<a id='L145' name='L145'></a>
<a id='L146' name='L146'></a>macros are compile-time parser extensions, rules added after startup,
<a id='L147' name='L147'></a>which do not construct parse trees directy, but indirectly.  macro
<a id='L148' name='L148'></a>argument declarations have the same syntax as the internal grammer,
<a id='L149' name='L149'></a>and may use the same rules (i.e. non-terminal symbols) from the
<a id='L150' name='L150'></a>grammer, i.e. the left hand side of the grammar rules, but the body is
<a id='L151' name='L151'></a>written in native perl5, with a mix of compile-time and run-time
<a id='L152' name='L152'></a>expressions.
<a id='L153' name='L153'></a>
<a id='L154' name='L154'></a>e.g.
<a id='L155' name='L155'></a>
<a id='L156' name='L156'></a>bc. syntax-p5.g:
<a id='L157' name='L157'></a>    block = '{' s:statements* '}' { $$ = PN_AST(BLOCK, s); }
<a id='L158' name='L158'></a>
<a id='L159' name='L159'></a>bc. macro ifdebug block 'ifdebug' {
<a id='L160' name='L160'></a>    if ($DEBUG) `block`;
<a id='L161' name='L161'></a>}
<a id='L162' name='L162'></a>{ call() } ifdebug;
<a id='L163' name='L163'></a>
<a id='L164' name='L164'></a>A macro can use valid parser expressions, i.e. strings
<a id='L165' name='L165'></a>(i.e. terminals) or any valid parser rule (i.e. non-terminals) as argument,
<a id='L166' name='L166'></a>here the rule @block@, and even @b:block@ to assign the variable @b@
<a id='L167' name='L167'></a>for the matched block, esp.  when matching two rules, i.e. @b1:block
<a id='L168' name='L168'></a>b2:block@.
<a id='L169' name='L169'></a>See the documentation of the parser for valid parser expressions. 
<a id='L170' name='L170'></a>@leg@ supports peg expressions like @* + ?@, backtracking lookahead assertions
<a id='L171' name='L171'></a>@! &amp;@, and grouping via @()@.
<a id='L172' name='L172'></a>@marpa@ only supports sequences with a defined number of @min@ and @max@ sequences,
<a id='L173' name='L173'></a>@min=0@ i.e. @*@, @min=1@ i.e. @+@, optional @?@ would be @min=0, max=1@.
<a id='L174' name='L174'></a>Syntax: @rule{min,max}@ min defaults to 0, max to infinite,
<a id='L175' name='L175'></a>Later hopefully @rule+@, @rule*@ and @rule?@. The PEG backtracking lookahead
<a id='L176' name='L176'></a>assertions @! &amp;@ are not needed in marpa, because it embraces a bottom-up BNF
<a id='L177' name='L177'></a>grammar.
<a id='L178' name='L178'></a>
<a id='L179' name='L179'></a>Most keywords should be defined as macros.  E.g. @for@, @while@ and
<a id='L180' name='L180'></a>@match@ can be more easily defined as macros. Short circuiting and
<a id='L181' name='L181'></a>partial evaluation should be possible in macros.
<a id='L182' name='L182'></a>
<a id='L183' name='L183'></a>Normal functions or methods do not need to be defined in the language,
<a id='L184' name='L184'></a>they are library calls. 90% of the ops previously defined in perl5 are
<a id='L185' name='L185'></a>moved to the standard library. Most syntax extending declarations are
<a id='L186' name='L186'></a>macros defined in the standard library.
<a id='L187' name='L187'></a>
<a id='L188' name='L188'></a>With macros you can define your own compile-time optimizations.
<a id='L189' name='L189'></a>Every statement in a macro, which is not evaluated, is not compiled in,
<a id='L190' name='L190'></a>it is ignored. E.g. you can simplify all your @if $DEBUG@ statements,
<a id='L191' name='L191'></a>and extend the expressibility of your code.
<a id='L192' name='L192'></a>
<a id='L193' name='L193'></a>@()@ groups list in parse expressions, and does not match perl elements in lists.
<a id='L194' name='L194'></a>
<a id='L195' name='L195'></a>bc. macro dbgprint 'dbgprint' ( s:stmt )* {
<a id='L196' name='L196'></a>  if ($DEBUG) {
<a id='L197' name='L197'></a>    print @`s`;
<a id='L198' name='L198'></a>  }
<a id='L199' name='L199'></a>}
<a id='L200' name='L200'></a>
<a id='L201' name='L201'></a>bc. macro while 'while' - '(' e:expr ')' - '{' b:block '}' {
<a id='L202' name='L202'></a>  my $label = gensym('WHILE');
<a id='L203' name='L203'></a>  $label: if (`e`) {
<a id='L204' name='L204'></a>    @`b`;
<a id='L205' name='L205'></a>    goto $label;
<a id='L206' name='L206'></a>  }
<a id='L207' name='L207'></a>}
<a id='L208' name='L208'></a>
<a id='L209' name='L209'></a>'(' is to disambiguate a parse-time '(' from a grouping @(@.
<a id='L210' name='L210'></a>`` is taken to evaluate (=expand) expressions within macros.
<a id='L211' name='L211'></a>@@@`` splices expanded code in list context.
<a id='L212' name='L212'></a>Similar to perl6 @quasi@ or @{{{ }}}@ blocks, just simplier.
<a id='L213' name='L213'></a>
<a id='L214' name='L214'></a>Note that the return value of this while is always @undef@, and
<a id='L215' name='L215'></a>the while construct needs the @()@ and @{}@, contrary to the current keyword.
<a id='L216' name='L216'></a>But you can declare a while macro for the single block case without @{}@.
<a id='L217' name='L217'></a>
<a id='L218' name='L218'></a>*marketing blurbs*: _p2 will be the first implementation of any mainstream 
<a id='L219' name='L219'></a>non-LISP language with proper macro support._
<a id='L220' name='L220'></a>
<a id='L221' name='L221'></a>h3. ffi
<a id='L222' name='L222'></a>
<a id='L223' name='L223'></a>you should be able to define C functions and structs easily, 
<a id='L224' name='L224'></a>either by parsing a header file or by inling C syntax.
<a id='L225' name='L225'></a>p2 will support @load@ and calling a @dlsym@,
<a id='L226' name='L226'></a>but hopefully also parsing a full C grammar.
<a id='L227' name='L227'></a>
<a id='L228' name='L228'></a>e.g.
<a id='L229' name='L229'></a>
<a id='L230' name='L230'></a>bc.. p2::load "libm";
<a id='L231' name='L231'></a>{
<a id='L232' name='L232'></a>  use syntax 'C';
<a id='L233' name='L233'></a>  #pragma perl $i =&gt; double;
<a id='L234' name='L234'></a>  #pragma perl $num &lt;= double num;
<a id='L235' name='L235'></a>
<a id='L236' name='L236'></a>  #include &lt;math.h&gt;
<a id='L237' name='L237'></a>  double num = sqrt(2.0 + $i);
<a id='L238' name='L238'></a>}
<a id='L239' name='L239'></a>print $num;
<a id='L240' name='L240'></a>
<a id='L241' name='L241'></a>p. This will work because loading a new syntax can be done at
<a id='L242' name='L242'></a>run-time and a block has scoped types and mixins.
</pre>
<hr />
<a id='BOTTOM' name='BOTTOM'></a>
<em class='comment'>/* <img class='icon' src='../icons/n_left.png' alt='[previous]' /><img class='icon' src='../icons/n_right.png' alt='[next]' /><img class='icon' src='../icons/n_first.png' alt='[first]' /><img class='icon' src='../icons/n_last.png' alt='[last]' /><a href='#TOP'><img class='icon' src='../icons/top.png' alt='[top]' /></a><img class='icon' src='../icons/n_bottom.png' alt='[bottom]' /><a href='../mains.html'><img class='icon' src='../icons/index.png' alt='[index]' /></a><a href='../help.html'><img class='icon' src='../icons/help.png' alt='[help]' /></a>&nbsp;<em class='position'>[+242 doc/p2-extensions.textile]</em> */</em>
</body>
</html>
