<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
<title>doc/design-decisions.textile</title>
<meta name='robots' content='noindex,nofollow' />
<meta name='generator' content='GLOBAL-6.2.8' />
<meta http-equiv='Content-Style-Type' content='text/css' />
<link rel='stylesheet' type='text/css' href='../style.css' />
</head>
<body>
<!-- beginning of fixed guide -->
<div id='guide'><ul>
<li><a href='#TOP'><img class='icon' src='../icons/first.png' alt='[^]' /></a></li>
<li><a href='#BOTTOM'><img class='icon' src='../icons/last.png' alt='[v]' /></a></li>
<li><a href='#TOP'><img class='icon' src='../icons/top.png' alt='[top]' /></a></li>
<li><a href='#BOTTOM'><img class='icon' src='../icons/bottom.png' alt='[bottom]' /></a></li>
<li><a href='../mains.html'><img class='icon' src='../icons/index.png' alt='[index]' /></a></li>
<li><a href='../help.html'><img class='icon' src='../icons/help.png' alt='[help]' /></a></li>
<li class='standout'><span><a href='../files/177.html'>doc</a>/design-decisions.textile</span></li>
</ul></div>
<!-- end of fixed guide -->
<a id='TOP' name='TOP'></a><h2 class='header'><a href='../mains.html'>root</a>/<a href='../files/177.html'>doc</a>/design-decisions.textile</h2>
<em class='comment'>/* <img class='icon' src='../icons/n_left.png' alt='[previous]' /><img class='icon' src='../icons/n_right.png' alt='[next]' /><img class='icon' src='../icons/n_first.png' alt='[first]' /><img class='icon' src='../icons/n_last.png' alt='[last]' /><img class='icon' src='../icons/n_top.png' alt='[top]' /><a href='#BOTTOM'><img class='icon' src='../icons/bottom.png' alt='[bottom]' /></a><a href='../mains.html'><img class='icon' src='../icons/index.png' alt='[index]' /></a><a href='../help.html'><img class='icon' src='../icons/help.png' alt='[help]' /></a>&nbsp;<em class='position'>[+1 doc/design-decisions.textile]</em> */</em>
<hr />
<pre>
<a id='L1' name='L1'></a>h1. design decisions on p2
<a id='L2' name='L2'></a>
<a id='L3' name='L3'></a>With p2 I plan to parse and execute perl5 asis.
<a id='L4' name='L4'></a>libp2, the compiler and vm based on potion, should be a good target
<a id='L5' name='L5'></a>for perl6.
<a id='L6' name='L6'></a>
<a id='L7' name='L7'></a>But I will not be able to run 100% of CPAN. I could, but then there
<a id='L8' name='L8'></a>would be no progress.
<a id='L9' name='L9'></a>I plan significant enhancements in perl performance and features.
<a id='L10' name='L10'></a>
<a id='L11' name='L11'></a>
<a id='L12' name='L12'></a>h2. Generally
<a id='L13' name='L13'></a>
<a id='L14' name='L14'></a>I go along with _why and every lisp coder.  Good software should be
<a id='L15' name='L15'></a>beautiful. But not too beautiful. Code is also art not only technology.
<a id='L16' name='L16'></a>Short, precise, readable. No one wants to work with a big and ugly
<a id='L17' name='L17'></a>mess, not even companies. Too much code smells.  Rather restrict the
<a id='L18' name='L18'></a>usage to those who know and can be taught, than sacrifice your system
<a id='L19' name='L19'></a>for it. On the other hand too beautiful code rarely gets out of a niche.
<a id='L20' name='L20'></a>Worse is better.
<a id='L21' name='L21'></a>
<a id='L22' name='L22'></a>Support 90% but do not sacrifice for the rest.
<a id='L23' name='L23'></a>gmake and gcc/clang are available everywhere, even on pure bsd's.
<a id='L24' name='L24'></a>
<a id='L25' name='L25'></a>Examples:
<a id='L26' name='L26'></a>no support for MS cl/nmake. people should use mingw with gmake and gcc instead.
<a id='L27' name='L27'></a>no support for BSDmakefile syntax. see the @bsd@ branch.
<a id='L28' name='L28'></a>no support for pure strict c++ compilers. see the @p2-c++@ branch.
<a id='L29' name='L29'></a>no vax, hpux, aix without gnu tools.
<a id='L30' name='L30'></a>
<a id='L31' name='L31'></a>
<a id='L32' name='L32'></a>h1. Incompatibilities
<a id='L33' name='L33'></a>
<a id='L34' name='L34'></a>Some functionality will change, some annoying bugs fixed, 
<a id='L35' name='L35'></a>and some functionality might get removed, or not yet supported.
<a id='L36' name='L36'></a>
<a id='L37' name='L37'></a>h2. XS 
<a id='L38' name='L38'></a>
<a id='L39' name='L39'></a>Problem will arise with XS code, since the VM is different, and not
<a id='L40' name='L40'></a>all XS API functions can be supported.  It should be much easier to
<a id='L41' name='L41'></a>use XS-like functionality with the new FFI, or by using extension
<a id='L42' name='L42'></a>libraries with native calls. See @lib/readline@. So we will loose
<a id='L43' name='L43'></a>40% of CPAN code, but will win on performance, expressibility and
<a id='L44' name='L44'></a>compile-time error checking when binding libs.
<a id='L45' name='L45'></a>
<a id='L46' name='L46'></a>There should be a translator of old XS code to check the stack
<a id='L47' name='L47'></a>(argument + return values) handling macros and convert them to direct
<a id='L48' name='L48'></a>calls.
<a id='L49' name='L49'></a>
<a id='L50' name='L50'></a>h2. functional programming
<a id='L51' name='L51'></a>
<a id='L52' name='L52'></a>p2 is pretty obscene in being a pure functional language, certainly more functional
<a id='L53' name='L53'></a>than LISP.
<a id='L54' name='L54'></a>Internally any non-lexical variable (GV in perl5) is a function, a closure, which means
<a id='L55' name='L55'></a>it is an object, which means getting the value is done by sending it a message with
<a id='L56' name='L56'></a>an empty name,
<a id='L57' name='L57'></a>and setting the value is done by sending it the "def" message.
<a id='L58' name='L58'></a>
<a id='L59' name='L59'></a>  (message %ENV) =&gt; return value of %ENV
<a id='L60' name='L60'></a>  (message %ENV "def" &amp;env) =&gt; set new value of %ENV
<a id='L61' name='L61'></a>
<a id='L62' name='L62'></a>Yes, you smell Smalltalk.
<a id='L63' name='L63'></a>This is needed to be able to support a proper object system, types and esp.
<a id='L64' name='L64'></a>proper multi-threading.
<a id='L65' name='L65'></a>
<a id='L66' name='L66'></a>On the user-side some side-effect-only functions will be changed to return the
<a id='L67' name='L67'></a>changed argument.
<a id='L68' name='L68'></a>E.g. chop, chomp, ...
<a id='L69' name='L69'></a>return $s =~ s///r as default if the left hand side (wantarray) is no list.
<a id='L70' name='L70'></a>
<a id='L71' name='L71'></a>The parser simplier and different. All statements return values. Everything can be on a
<a id='L72' name='L72'></a>right hand side of something.
<a id='L73' name='L73'></a>E.g. *if* returns the value of the executed branch or
<a id='L74' name='L74'></a>*undef* if no branch is choosen.
<a id='L75' name='L75'></a>
<a id='L76' name='L76'></a>bc. {
<a id='L77' name='L77'></a>    $a = if (1) { $c }; #same as: $a = $c;
<a id='L78' name='L78'></a>}
<a id='L79' name='L79'></a>
<a id='L80' name='L80'></a>
<a id='L81' name='L81'></a>h2. order of destruction
<a id='L82' name='L82'></a>
<a id='L83' name='L83'></a>If you don't use explicit DESTROY calls at the end of blocks, the compiler 
<a id='L84' name='L84'></a>might miss some DESTROY calls of untyped objects. DESTROY might be called
<a id='L85' name='L85'></a>later then, as in other GC'd languages. get over it.
<a id='L86' name='L86'></a>
<a id='L87' name='L87'></a>reference counted objects are too dangerous, too hard and too slow.
<a id='L88' name='L88'></a>cyclic data structures do not play well with refcounts.
<a id='L89' name='L89'></a>use-after-free bugs are by factor 10 the most exploited security problems
<a id='L90' name='L90'></a>nowadays, and perl5 is full of them.
<a id='L91' name='L91'></a>
<a id='L92' name='L92'></a>
<a id='L93' name='L93'></a>h2. lexical hash iterators
<a id='L94' name='L94'></a>
<a id='L95' name='L95'></a>iterating a hash twice in lexically scoped blocks does not work in the second, 
<a id='L96' name='L96'></a>outer iterator, as the iterator in p5p perl is stored in the data. 
<a id='L97' name='L97'></a>This will be changed to be stored in the scope (block).
<a id='L98' name='L98'></a>
<a id='L99' name='L99'></a>i.e. using Data::Dumper inside a each %hash loop will restore the position after 
<a id='L100' name='L100'></a>Data::Dumper dumped the hash.
<a id='L101' name='L101'></a>
<a id='L102' name='L102'></a>
<a id='L103' name='L103'></a>h1. New features (planned)
<a id='L104' name='L104'></a>
<a id='L105' name='L105'></a>h3. All data are objects, all declarations can be optionally typed.
<a id='L106' name='L106'></a>
<a id='L107' name='L107'></a>extendability, maintainance
<a id='L108' name='L108'></a>
<a id='L109' name='L109'></a>efficient oo and dynamic type system, with compiler support for static types.
<a id='L110' name='L110'></a>
<a id='L111' name='L111'></a>
<a id='L112' name='L112'></a>h3. const declarations for lexical data, @ISA, classes and functions/methods
<a id='L113' name='L113'></a>
<a id='L114' name='L114'></a>efficiency
<a id='L115' name='L115'></a>
<a id='L116' name='L116'></a>Also needed for threads and oo to avoid generating writer methods.
<a id='L117' name='L117'></a>Define immutable and final classes.
<a id='L118' name='L118'></a>
<a id='L119' name='L119'></a>h3. optional function signatures and type declarations
<a id='L120' name='L120'></a>
<a id='L121' name='L121'></a>efficiency and safety, compile-time checks
<a id='L122' name='L122'></a>
<a id='L123' name='L123'></a>
<a id='L124' name='L124'></a>h3. efficient meta-object system, with classes, methods, roles
<a id='L125' name='L125'></a>
<a id='L126' name='L126'></a>like Moose (i.e. CLOS), but ~800x faster and with native type support.
<a id='L127' name='L127'></a>i.e. compile-time checks.
<a id='L128' name='L128'></a>
<a id='L129' name='L129'></a>
<a id='L130' name='L130'></a>h3. sized arrays
<a id='L131' name='L131'></a>
<a id='L132' name='L132'></a>efficiency
<a id='L133' name='L133'></a>
<a id='L134' name='L134'></a>
<a id='L135' name='L135'></a>h3. no magic
<a id='L136' name='L136'></a>
<a id='L137' name='L137'></a>efficiency
<a id='L138' name='L138'></a>
<a id='L139' name='L139'></a>
<a id='L140' name='L140'></a>h3. match operator
<a id='L141' name='L141'></a>
<a id='L142' name='L142'></a>expressibility
<a id='L143' name='L143'></a>
<a id='L144' name='L144'></a>A proper matcher should be able to match structures and types, and to
<a id='L145' name='L145'></a>bind result variables.
<a id='L146' name='L146'></a>
<a id='L147' name='L147'></a>
<a id='L148' name='L148'></a>h3. dynamic and cleaned up parser
<a id='L149' name='L149'></a>
<a id='L150' name='L150'></a>maintainability.
<a id='L151' name='L151'></a>new technology (risc and code maintainability), but needed for macros.
<a id='L152' name='L152'></a>
<a id='L153' name='L153'></a>allow sensible language features, disallowed by p5p or the old yacc
<a id='L154' name='L154'></a>parser.  the parser grammar needs to be expressive, even for perl,
<a id='L155' name='L155'></a>which is known to be hard to parse, and dynamic at parse-time
<a id='L156' name='L156'></a>(prototypes).
<a id='L157' name='L157'></a>
<a id='L158' name='L158'></a>new syntactic constructs needs to added to the grammar, not elsewhere
<a id='L159' name='L159'></a>in the code.  the parser needs to be accessible and extendable at
<a id='L160' name='L160'></a>compile-time, maybe even run-time, but we cannot use a non-optimized
<a id='L161' name='L161'></a>pure top-down parser as e.g. lua to enable this.
<a id='L162' name='L162'></a>
<a id='L163' name='L163'></a>we need to precompile the base grammar, bootstrap system macros and
<a id='L164' name='L164'></a>allow user macros. expose the parser API to the user. query and
<a id='L165' name='L165'></a>insert rules. use custom rules to parse ffi declarations (c headers)
<a id='L166' name='L166'></a>templates, ... or even basic, ruby, python or perl6.
<a id='L167' name='L167'></a>
<a id='L168' name='L168'></a>bc. {
<a id='L169' name='L169'></a>  use v6;
<a id='L170' name='L170'></a>  # perl6 syntax...
<a id='L171' name='L171'></a>}
<a id='L172' name='L172'></a>
<a id='L173' name='L173'></a>_(this will need a pre-compiled @syntax-p6.g@ and scoped syntax)_
<a id='L174' name='L174'></a>
<a id='L175' name='L175'></a>Either done by extending packrat greg (ie leg) by with a parser
<a id='L176' name='L176'></a>interpreter to add rules at run-time, - from precompiled rules and
<a id='L177' name='L177'></a>user-added rules - or by extending marpa to be extensible.
<a id='L178' name='L178'></a>
<a id='L179' name='L179'></a>
<a id='L180' name='L180'></a>h3. macros as parser extensions
<a id='L181' name='L181'></a>
<a id='L182' name='L182'></a>expressibility (lisp-like)
<a id='L183' name='L183'></a>keep the vm small, do not prototype everything in the C library.
<a id='L184' name='L184'></a>use the existing parser engine.
<a id='L185' name='L185'></a>
<a id='L186' name='L186'></a>macro args are rules (non-terminals) and terminals (strings) to be
<a id='L187' name='L187'></a>added to the parser, the macro block is evaluated at compile-time,
<a id='L188' name='L188'></a>with `...` expanded at run-time.
<a id='L189' name='L189'></a>
<a id='L190' name='L190'></a>so perl will be the first non-lisp like language with a proper macro
<a id='L191' name='L191'></a>system, i.e. extending parser grammars. perl6 has similar ideas using peg
<a id='L192' name='L192'></a>at run-time, but their syntactic macros are too complicated for me.
<a id='L193' name='L193'></a>maybe using the perl6 &lt;rule&gt; syntax looks ok. _(i.e. &lt;block&gt; below)_
<a id='L194' name='L194'></a>
<a id='L195' name='L195'></a>There are some similar non-mainstream approaches, on mono or java or
<a id='L196' name='L196'></a>haskell, but none on fast, compiled to C scripting languages.
<a id='L197' name='L197'></a>
<a id='L198' name='L198'></a>bc. syntax-p5.g:
<a id='L199' name='L199'></a>    block = '{' s:statements* '}' { $$ = PN_AST(BLOCK, s); }
<a id='L200' name='L200'></a>
<a id='L201' name='L201'></a>bc.  macro ifdebug block 'ifdebug' {
<a id='L202' name='L202'></a>  if ($DEBUG) `block`;
<a id='L203' name='L203'></a>}
<a id='L204' name='L204'></a>{ call() } ifdebug;
<a id='L205' name='L205'></a>
<a id='L206' name='L206'></a>h3. auto-threads
<a id='L207' name='L207'></a>
<a id='L208' name='L208'></a>the p2/potion data-structures, compiler, vm, gc, interpreter are
<a id='L209' name='L209'></a>thread-safe.
<a id='L210' name='L210'></a>
<a id='L211' name='L211'></a>with a OO task and scheduler interface as in parrot (pre-create,
<a id='L212' name='L212'></a>useful esp. for windows alarms),
<a id='L213' name='L213'></a>or as in Go (similar),
<a id='L214' name='L214'></a>or maybe only non-autothreaded as in lua, with just first-class
<a id='L215' name='L215'></a>  coroutines, methods: create, status, resume, yield, wrap
<a id='L216' name='L216'></a>
<a id='L217' name='L217'></a>h3. ffi
<a id='L218' name='L218'></a>
<a id='L219' name='L219'></a>builtin
<a id='L220' name='L220'></a>extendability, maintainance
<a id='L221' name='L221'></a>
<a id='L222' name='L222'></a>maybe ctypes alike, maybe something simplier or more advanced.
<a id='L223' name='L223'></a>(i.e. import parses header files and generates all ffi functions
<a id='L224' name='L224'></a>and types, or on the hand only support the bare cc types:
<a id='L225' name='L225'></a>signed/unsigned, void/byte/short/long/ptr float/double/long double)
<a id='L226' name='L226'></a>
</pre>
<hr />
<a id='BOTTOM' name='BOTTOM'></a>
<em class='comment'>/* <img class='icon' src='../icons/n_left.png' alt='[previous]' /><img class='icon' src='../icons/n_right.png' alt='[next]' /><img class='icon' src='../icons/n_first.png' alt='[first]' /><img class='icon' src='../icons/n_last.png' alt='[last]' /><a href='#TOP'><img class='icon' src='../icons/top.png' alt='[top]' /></a><img class='icon' src='../icons/n_bottom.png' alt='[bottom]' /><a href='../mains.html'><img class='icon' src='../icons/index.png' alt='[index]' /></a><a href='../help.html'><img class='icon' src='../icons/help.png' alt='[help]' /></a>&nbsp;<em class='position'>[+226 doc/design-decisions.textile]</em> */</em>
</body>
</html>
