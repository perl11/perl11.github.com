<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
<title>Node</title>
<meta name='robots' content='noindex,nofollow' />
<meta name='generator' content='GLOBAL-6.5.7' />
<meta http-equiv='Content-Style-Type' content='text/css' />
<link rel='stylesheet' type='text/css' href='../style.css' />
</head>
<body>
<pre>
<span class='curline'><a href='../S/103.html#L191'>Node</a>              191 syn/compile.c  static void Node_compile_c_ko(Node *node, int ko)</span>
<span class='curline'><a href='../S/103.html#L377'>Node</a>              377 syn/compile.c  static int countVariables(Node *node)</span>
<span class='curline'><a href='../S/103.html#L388'>Node</a>              388 syn/compile.c  static void defineVariables(Node *node)</span>
<span class='curline'><a href='../S/103.html#L399'>Node</a>              399 syn/compile.c  static void undefineVariables(Node *node)</span>
<span class='curline'><a href='../S/103.html#L409'>Node</a>              409 syn/compile.c  static void Rule_compile_c2(Node *node)</span>
<span class='curline'><a href='../S/103.html#L940'>Node</a>              940 syn/compile.c  int consumesInput(Node *node)</span>
<span class='curline'><a href='../S/103.html#L972'>Node</a>              972 syn/compile.c  	Node *n;</span>
<span class='curline'><a href='../S/103.html#L981'>Node</a>              981 syn/compile.c  	Node *n;</span>
<span class='curline'><a href='../S/103.html#L1002'>Node</a>             1002 syn/compile.c  void Rule_compile_c(Node *node)</span>
<span class='curline'><a href='../S/103.html#L1004'>Node</a>             1004 syn/compile.c    Node *n;</span>
<span class='curline'><a href='../S/104.html#L38'>Node</a>               38 syn/greg.h     typedef union Node Node;</span>
<span class='curline'><a href='../S/104.html#L40'>Node</a>               40 syn/greg.h     #define NODE_COMMON NodeType type;  Node *next</span>
<span class='curline'><a href='../S/104.html#L41'>Node</a>               41 syn/greg.h     struct Rule	 { NODE_COMMON; char *name; Node *variables;  Node *expression;  int id;  int flags;	};</span>
<span class='curline'><a href='../S/104.html#L42'>Node</a>               42 syn/greg.h     struct Variable	 { NODE_COMMON; char *name; Node *value;  int offset;					};</span>
<span class='curline'><a href='../S/104.html#L43'>Node</a>               43 syn/greg.h     struct Name	 { NODE_COMMON; Node *rule; Node *variable;						};</span>
<span class='curline'><a href='../S/104.html#L48'>Node</a>               48 syn/greg.h     struct Action	 { NODE_COMMON; char *text;  Node *list;  char *name;  Node *rule;			};</span>
<span class='curline'><a href='../S/104.html#L50'>Node</a>               50 syn/greg.h     struct Error     { NODE_COMMON; Node *element; char *text;						};</span>
<span class='curline'><a href='../S/104.html#L51'>Node</a>               51 syn/greg.h     struct Alternate { NODE_COMMON; Node *first;  Node *last;						};</span>
<span class='curline'><a href='../S/104.html#L52'>Node</a>               52 syn/greg.h     struct Sequence	 { NODE_COMMON; Node *first;  Node *last;						};</span>
<span class='curline'><a href='../S/104.html#L53'>Node</a>               53 syn/greg.h     struct PeekFor	 { NODE_COMMON; Node *element;								};</span>
<span class='curline'><a href='../S/104.html#L54'>Node</a>               54 syn/greg.h     struct PeekNot	 { NODE_COMMON; Node *element;								};</span>
<span class='curline'><a href='../S/104.html#L55'>Node</a>               55 syn/greg.h     struct Query	 { NODE_COMMON; Node *element;								};</span>
<span class='curline'><a href='../S/104.html#L56'>Node</a>               56 syn/greg.h     struct Star	 { NODE_COMMON; Node *element;								};</span>
<span class='curline'><a href='../S/104.html#L57'>Node</a>               57 syn/greg.h     struct Plus	 { NODE_COMMON; Node *element;								};</span>
<span class='curline'><a href='../S/104.html#L84'>Node</a>               84 syn/greg.h     extern Node *actions;</span>
<span class='curline'><a href='../S/104.html#L85'>Node</a>               85 syn/greg.h     extern Node *rules;</span>
<span class='curline'><a href='../S/104.html#L86'>Node</a>               86 syn/greg.h     extern Node *start;</span>
<span class='curline'><a href='../S/104.html#L92'>Node</a>               92 syn/greg.h     extern Node *makeRule(char *name, int starts);</span>
<span class='curline'><a href='../S/104.html#L93'>Node</a>               93 syn/greg.h     extern Node *findRule(char *name, int starts);</span>
<span class='curline'><a href='../S/104.html#L94'>Node</a>               94 syn/greg.h     extern Node *beginRule(Node *rule);</span>
<span class='curline'><a href='../S/104.html#L95'>Node</a>               95 syn/greg.h     extern void  Rule_setExpression(Node *rule, Node *expression);</span>
<span class='curline'><a href='../S/104.html#L96'>Node</a>               96 syn/greg.h     extern Node *Rule_beToken(Node *rule);</span>
<span class='curline'><a href='../S/104.html#L97'>Node</a>               97 syn/greg.h     extern Node *makeVariable(char *name);</span>
<span class='curline'><a href='../S/104.html#L98'>Node</a>               98 syn/greg.h     extern Node *makeName(Node *rule);</span>
<span class='curline'><a href='../S/104.html#L99'>Node</a>               99 syn/greg.h     extern Node *makeDot(void);</span>
<span class='curline'><a href='../S/104.html#L100'>Node</a>              100 syn/greg.h     extern Node *makeCharacter(char *text);</span>
<span class='curline'><a href='../S/104.html#L101'>Node</a>              101 syn/greg.h     extern Node *makeString(char *text);</span>
<span class='curline'><a href='../S/104.html#L102'>Node</a>              102 syn/greg.h     extern Node *makeClass(char *text);</span>
<span class='curline'><a href='../S/104.html#L103'>Node</a>              103 syn/greg.h     extern Node *makeAction(char *text);</span>
<span class='curline'><a href='../S/104.html#L104'>Node</a>              104 syn/greg.h     extern Node *makePredicate(char *text);</span>
<span class='curline'><a href='../S/104.html#L105'>Node</a>              105 syn/greg.h     extern Node *makeError(Node *e, char *text);</span>
<span class='curline'><a href='../S/104.html#L106'>Node</a>              106 syn/greg.h     extern Node *makeAlternate(Node *e);</span>
<span class='curline'><a href='../S/104.html#L107'>Node</a>              107 syn/greg.h     extern Node *Alternate_append(Node *e, Node *f);</span>
<span class='curline'><a href='../S/104.html#L108'>Node</a>              108 syn/greg.h     extern Node *makeSequence(Node *e);</span>
<span class='curline'><a href='../S/104.html#L109'>Node</a>              109 syn/greg.h     extern Node *Sequence_append(Node *e, Node *f);</span>
<span class='curline'><a href='../S/104.html#L110'>Node</a>              110 syn/greg.h     extern Node *makePeekFor(Node *e);</span>
<span class='curline'><a href='../S/104.html#L111'>Node</a>              111 syn/greg.h     extern Node *makePeekNot(Node *e);</span>
<span class='curline'><a href='../S/104.html#L112'>Node</a>              112 syn/greg.h     extern Node *makeQuery(Node *e);</span>
<span class='curline'><a href='../S/104.html#L113'>Node</a>              113 syn/greg.h     extern Node *makeStar(Node *e);</span>
<span class='curline'><a href='../S/104.html#L114'>Node</a>              114 syn/greg.h     extern Node *makePlus(Node *e);</span>
<span class='curline'><a href='../S/104.html#L115'>Node</a>              115 syn/greg.h     extern Node *push(Node *node);</span>
<span class='curline'><a href='../S/104.html#L116'>Node</a>              116 syn/greg.h     extern Node *top(void);</span>
<span class='curline'><a href='../S/104.html#L117'>Node</a>              117 syn/greg.h     extern Node *pop(void);</span>
<span class='curline'><a href='../S/104.html#L120'>Node</a>              120 syn/greg.h     extern void  Rule_compile_c(Node *node);</span>
<span class='curline'><a href='../S/104.html#L122'>Node</a>              122 syn/greg.h     extern void  Node_print(Node *node);</span>
<span class='curline'><a href='../S/104.html#L123'>Node</a>              123 syn/greg.h     extern void  Rule_print(Node *node);</span>
<span class='curline'><a href='../S/104.html#L124'>Node</a>              124 syn/greg.h     extern void  Rule_free(Node *node);</span>
<span class='curline'><a href='../S/105.html#L68'>Node</a>               68 syn/greg.y     		EQUAL expression			{ Node *e= pop();  Rule_setExpression(pop(), e); }</span>
<span class='curline'><a href='../S/105.html#L71'>Node</a>               71 syn/greg.y     expression=	sequence (BAR sequence			{ Node *f= pop();  push(Alternate_append(pop(), f)); }</span>
<span class='curline'><a href='../S/105.html#L74'>Node</a>               74 syn/greg.y     sequence=	prefix (prefix				{ Node *f= pop();  push(Sequence_append(pop(), f)); }</span>
<span class='curline'><a href='../S/105.html#L89'>Node</a>               89 syn/greg.y     		COLON identifier !EQUAL			{ Node *name= makeName(findRule(yytext,0));  name-&gt;name.variable= pop();  push(name); }</span>
<span class='curline'><a href='../S/105.html#L185'>Node</a>              185 syn/greg.y       Node *n;</span>
<span class='curline'><a href='../S/108.html#L27'>Node</a>               27 syn/tree.c     Node *actions= 0;</span>
<span class='curline'><a href='../S/108.html#L28'>Node</a>               28 syn/tree.c     Node *rules= 0;</span>
<span class='curline'><a href='../S/108.html#L29'>Node</a>               29 syn/tree.c     Node *thisRule= 0;</span>
<span class='curline'><a href='../S/108.html#L30'>Node</a>               30 syn/tree.c     Node *start= 0;</span>
<span class='curline'><a href='../S/108.html#L38'>Node</a>               38 syn/tree.c     static inline Node *_newNode(NodeType type, int size)</span>
<span class='curline'><a href='../S/108.html#L40'>Node</a>               40 syn/tree.c       Node *node= calloc(1, size);</span>
<span class='curline'><a href='../S/108.html#L47'>Node</a>               47 syn/tree.c     Node *makeRule(char *name, int defined)</span>
<span class='curline'><a href='../S/108.html#L49'>Node</a>               49 syn/tree.c       Node *node= newNode(Rule);</span>
<span class='curline'><a href='../S/108.html#L58'>Node</a>               58 syn/tree.c     Node *findRule(char *name, int defined)</span>
<span class='curline'><a href='../S/108.html#L60'>Node</a>               60 syn/tree.c       Node *n;</span>
<span class='curline'><a href='../S/108.html#L72'>Node</a>               72 syn/tree.c     Node *beginRule(Node *rule)</span>
<span class='curline'><a href='../S/108.html#L78'>Node</a>               78 syn/tree.c     void Rule_setExpression(Node *node, Node *expression)</span>
<span class='curline'><a href='../S/108.html#L90'>Node</a>               90 syn/tree.c     Node *makeVariable(char *name)</span>
<span class='curline'><a href='../S/108.html#L92'>Node</a>               92 syn/tree.c       Node *node;</span>
<span class='curline'><a href='../S/108.html#L104'>Node</a>              104 syn/tree.c     Node *makeName(Node *rule)</span>
<span class='curline'><a href='../S/108.html#L106'>Node</a>              106 syn/tree.c       Node *node= newNode(Name);</span>
<span class='curline'><a href='../S/108.html#L113'>Node</a>              113 syn/tree.c     Node *makeDot(void)</span>
<span class='curline'><a href='../S/108.html#L118'>Node</a>              118 syn/tree.c     Node *makeCharacter(char *text)</span>
<span class='curline'><a href='../S/108.html#L120'>Node</a>              120 syn/tree.c       Node *node= newNode(Character);</span>
<span class='curline'><a href='../S/108.html#L125'>Node</a>              125 syn/tree.c     Node *makeString(char *text)</span>
<span class='curline'><a href='../S/108.html#L127'>Node</a>              127 syn/tree.c       Node *node= newNode(String);</span>
<span class='curline'><a href='../S/108.html#L132'>Node</a>              132 syn/tree.c     Node *makeClass(char *text)</span>
<span class='curline'><a href='../S/108.html#L134'>Node</a>              134 syn/tree.c       Node *node= newNode(Class);</span>
<span class='curline'><a href='../S/108.html#L139'>Node</a>              139 syn/tree.c     Node *makeAction(char *text)</span>
<span class='curline'><a href='../S/108.html#L141'>Node</a>              141 syn/tree.c       Node *node= newNode(Action);</span>
<span class='curline'><a href='../S/108.html#L159'>Node</a>              159 syn/tree.c     Node *makePredicate(char *text)</span>
<span class='curline'><a href='../S/108.html#L161'>Node</a>              161 syn/tree.c       Node *node= newNode(Predicate);</span>
<span class='curline'><a href='../S/108.html#L166'>Node</a>              166 syn/tree.c     Node *makeError(Node *e, char *text)</span>
<span class='curline'><a href='../S/108.html#L168'>Node</a>              168 syn/tree.c       Node *node= newNode(Error);</span>
<span class='curline'><a href='../S/108.html#L174'>Node</a>              174 syn/tree.c     Node *makeAlternate(Node *e)</span>
<span class='curline'><a href='../S/108.html#L178'>Node</a>              178 syn/tree.c           Node *node= newNode(Alternate);</span>
<span class='curline'><a href='../S/108.html#L188'>Node</a>              188 syn/tree.c     Node *Alternate_append(Node *a, Node *e)</span>
<span class='curline'><a href='../S/108.html#L199'>Node</a>              199 syn/tree.c     Node *makeSequence(Node *e)</span>
<span class='curline'><a href='../S/108.html#L203'>Node</a>              203 syn/tree.c           Node *node= newNode(Sequence);</span>
<span class='curline'><a href='../S/108.html#L213'>Node</a>              213 syn/tree.c     Node *Sequence_append(Node *a, Node *e)</span>
<span class='curline'><a href='../S/108.html#L224'>Node</a>              224 syn/tree.c     Node *makePeekFor(Node *e)</span>
<span class='curline'><a href='../S/108.html#L226'>Node</a>              226 syn/tree.c       Node *node= newNode(PeekFor);</span>
<span class='curline'><a href='../S/108.html#L231'>Node</a>              231 syn/tree.c     Node *makePeekNot(Node *e)</span>
<span class='curline'><a href='../S/108.html#L233'>Node</a>              233 syn/tree.c       Node *node= newNode(PeekNot);</span>
<span class='curline'><a href='../S/108.html#L238'>Node</a>              238 syn/tree.c     Node *makeQuery(Node *e)</span>
<span class='curline'><a href='../S/108.html#L240'>Node</a>              240 syn/tree.c       Node *node= newNode(Query);</span>
<span class='curline'><a href='../S/108.html#L245'>Node</a>              245 syn/tree.c     Node *makeStar(Node *e)</span>
<span class='curline'><a href='../S/108.html#L247'>Node</a>              247 syn/tree.c       Node *node= newNode(Star);</span>
<span class='curline'><a href='../S/108.html#L252'>Node</a>              252 syn/tree.c     Node *makePlus(Node *e)</span>
<span class='curline'><a href='../S/108.html#L254'>Node</a>              254 syn/tree.c       Node *node= newNode(Plus);</span>
<span class='curline'><a href='../S/108.html#L260'>Node</a>              260 syn/tree.c     static Node  *stack[1024];</span>
<span class='curline'><a href='../S/108.html#L261'>Node</a>              261 syn/tree.c     static Node **stackPointer= stack;</span>
<span class='curline'><a href='../S/108.html#L267'>Node</a>              267 syn/tree.c       Node **p;</span>
<span class='curline'><a href='../S/108.html#L277'>Node</a>              277 syn/tree.c     Node *push(Node *node)</span>
<span class='curline'><a href='../S/108.html#L287'>Node</a>              287 syn/tree.c     Node *top(void)</span>
<span class='curline'><a href='../S/108.html#L293'>Node</a>              293 syn/tree.c     Node *pop(void)</span>
<span class='curline'><a href='../S/108.html#L303'>Node</a>              303 syn/tree.c     static void Node_fprint(FILE *stream, Node *node)</span>
<span class='curline'><a href='../S/108.html#L350'>Node</a>              350 syn/tree.c     void Node_print(Node *node)	{ Node_fprint(stderr, node); }</span>
<span class='curline'><a href='../S/108.html#L352'>Node</a>              352 syn/tree.c     static void Rule_fprint(FILE *stream, Node *node)</span>
<span class='curline'><a href='../S/108.html#L364'>Node</a>              364 syn/tree.c     void Rule_print(Node *node)	{ Rule_fprint(stderr, node); }</span>
<span class='curline'><a href='../S/108.html#L366'>Node</a>              366 syn/tree.c     void Rule_free(Node *node)</span>
<span class='curline'><a href='../S/108.html#L373'>Node</a>              373 syn/tree.c     	Node *var= node-&gt;rule.variables;</span>
<span class='curline'><a href='../S/108.html#L380'>Node</a>              380 syn/tree.c     	  Node *tmp= var-&gt;any.next; Rule_free(var); var= tmp;</span>
<span class='curline'><a href='../S/108.html#L401'>Node</a>              401 syn/tree.c     	Node *root= node;</span>
<span class='curline'><a href='../S/108.html#L407'>Node</a>              407 syn/tree.c     	  Node *tmp= node-&gt;any.next; Rule_free(node); node= tmp;</span>
<span class='curline'><a href='../S/108.html#L415'>Node</a>              415 syn/tree.c     	Node *root= node;</span>
<span class='curline'><a href='../S/108.html#L421'>Node</a>              421 syn/tree.c     	  Node *tmp= node-&gt;any.next; Rule_free(node); node= tmp;</span>
<span class='curline'><a href='../S/108.html#L444'>Node</a>              444 syn/tree.c       Node *n;</span>
<span class='curline'><a href='../S/108.html#L447'>Node</a>              447 syn/tree.c           Node *tmp= n-&gt;any.next;</span>
<span class='curline'><a href='../S/108.html#L461'>Node</a>              461 syn/tree.c           Node *tmp= n-&gt;any.next;</span>
<span class='curline'><a href='../S/231.html#L515'>Node</a>              515 tools/greg.c       Node *name= makeName(findRule(yytext, 0));  name-&gt;name.variable= pop();  push(name); ;</span>
<span class='curline'><a href='../S/231.html#L596'>Node</a>              596 tools/greg.c       Node *f= pop();  push(Sequence_append(pop(), f)); ;</span>
<span class='curline'><a href='../S/231.html#L605'>Node</a>              605 tools/greg.c       Node *f= pop();  push(Alternate_append(pop(), f)); ;</span>
<span class='curline'><a href='../S/231.html#L615'>Node</a>              615 tools/greg.c       Node *e= pop();  Rule_setExpression(pop(), e); ;</span>
<span class='curline'><a href='../S/231.html#L1843'>Node</a>             1843 tools/greg.c     Node *n;</span>
<span class='curline'><a href='../S/232.html#L68'>Node</a>               68 tools/greg.y   		EQUAL expression			{ Node *e= pop();  Rule_setExpression(pop(), e); }</span>
<span class='curline'><a href='../S/232.html#L71'>Node</a>               71 tools/greg.y   expression=	sequence (BAR sequence			{ Node *f= pop();  push(Alternate_append(pop(), f)); }</span>
<span class='curline'><a href='../S/232.html#L74'>Node</a>               74 tools/greg.y   sequence=	error (error				{ Node *f= pop();  push(Sequence_append(pop(), f)); }</span>
<span class='curline'><a href='../S/232.html#L91'>Node</a>               91 tools/greg.y   		COLON identifier !EQUAL			{ Node *name= makeName(findRule(yytext, 0));  name-&gt;name.variable= pop();  push(name); }</span>
<span class='curline'><a href='../S/232.html#L188'>Node</a>              188 tools/greg.y     Node *n;</span>
</pre>
</body>
</html>
