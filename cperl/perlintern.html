<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title></title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:root@elcapitan.internal.macports.net" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION  </a></li>
  <li><a href="#Array-Manipulation-Functions">Array Manipulation Functions</a></li>
  <li><a href="#Check-routines">Check routines</a></li>
  <li><a href="#Compile-time-scope-hooks">Compile-time scope hooks</a></li>
  <li><a href="#Custom-Operators">Custom Operators</a></li>
  <li><a href="#CV-Manipulation-Functions">CV Manipulation Functions</a></li>
  <li><a href="#CV-reference-counts-and-CvOUTSIDE">CV reference counts and CvOUTSIDE</a></li>
  <li><a href="#Debugging-Utilities">Debugging Utilities</a></li>
  <li><a href="#Embedding-Functions">Embedding Functions</a></li>
  <li><a href="#Functions-in-file-op.c">Functions in file op.c</a></li>
  <li><a href="#GV-Functions">GV Functions</a></li>
  <li><a href="#Hash-Manipulation-Functions">Hash Manipulation Functions</a></li>
  <li><a href="#Hook-manipulation">Hook manipulation</a></li>
  <li><a href="#IO-Functions">IO Functions</a></li>
  <li><a href="#Lexer-interface">Lexer interface</a></li>
  <li><a href="#Magical-Functions">Magical Functions</a></li>
  <li><a href="#Miscellaneous-Functions">Miscellaneous Functions</a></li>
  <li><a href="#MRO-Functions">MRO Functions</a></li>
  <li><a href="#Optree-construction">Optree construction</a></li>
  <li><a href="#Optree-Manipulation-Functions">Optree Manipulation Functions</a></li>
  <li><a href="#Pad-Data-Structures">Pad Data Structures</a></li>
  <li><a href="#Per-Interpreter-Variables">Per-Interpreter Variables</a></li>
  <li><a href="#Stack-Manipulation-Macros">Stack Manipulation Macros</a></li>
  <li><a href="#SV-Body-Allocation">SV-Body Allocation</a></li>
  <li><a href="#SV-Manipulation-Functions">SV Manipulation Functions</a></li>
  <li><a href="#Unicode-Support">Unicode Support</a></li>
  <li><a href="#Warning-and-Dieing">Warning and Dieing</a></li>
  <li><a href="#Undocumented-functions">Undocumented functions</a></li>
  <li><a href="#AUTHORS">AUTHORS</a></li>
  <li><a href="#SEE-ALSO">SEE ALSO</a></li>
  <li><a href="#POD-ERRORS">POD ERRORS</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>perlintern - autogenerated documentation of purely <b>internal</b> Perl functions</p>

<h1 id="DESCRIPTION">DESCRIPTION  </h1>

<p>This file is the autogenerated documentation of functions in the Perl interpreter that are documented using Perl&#39;s internal documentation format but are not marked as part of the Perl API. In other words, <b>they are not for use in extensions</b>!</p>

<h1 id="Array-Manipulation-Functions">Array Manipulation Functions</h1>

<dl>

<dt id="av_reify">av_reify </dt>
<dd>

<p>The elements of the @_ argarray, marked as !AvREAL &amp;&amp; AvREIFY, become real refcounted SVs.</p>

<p>Bumps the refcount for every non-empty value, and clears all the invalid values.</p>

<p>Sets AvREIFY_off and AvREAL_on.</p>

<p>AvREAL arrays handle refcounts of the elements, !AvREAL arrays ignore them.</p>

<pre><code>        void    av_reify(AV *av)</code></pre>

</dd>
</dl>

<h1 id="Check-routines">Check routines</h1>

<p>A check routine is called at the end of the &quot;newOP&quot; creation routines. So at the point that a ck_ routine fires, we have no idea what the context is, either upward in the syntax tree, or either forward or backward in the execution order.</p>

<p>Lexical slots (op_targ) are also not yet known, this is done at the end of a check function in op_std_init(o). For more see the comments at the top of <i>op.c</i> for details.</p>

<p>See <i>regen/opcodes</i> which opcode calls which check function. Not all ops have a specific check function.</p>

<p>ck_fun is a generic arity type checker, ck_type a generic type checker for un- and binops.</p>

<p>fold_constants(op_integerize(op_std_init(o))) is the default treatment, i.e. fold constants, apply use integer optimizations and initialize the op_targ for uninitialized pads.</p>

<p>Prototypes are generated by <i>regen/embed_lib.pl</i> by scanning <i>regen/opcodes</i>, check functions are not in <i>embed.fnc</i>.</p>

<dl>

<dt id="aassign_padcheck">aassign_padcheck </dt>
<dd>

<p>helper function for S_aassign_scan().</p>

<p>Check a PAD-related op for commonality and/or set its generation number. Returns a boolean indicating whether its shared. bool aassign_padcheck(OP* o, bool rhs)</p>

</dd>
<dt id="aassign_scan">aassign_scan </dt>
<dd>

<p>Helper function for OPpASSIGN_COMMON* detection in rpeep(). It scans the left or right hand subtree of the aassign op, and returns a set of flags indicating what sorts of things it found there. &#39;rhs&#39; indicates whether we&#39;re scanning the LHS or RHS. If the former, we set PL_generation on lexical vars; if the latter, we see if PL_generation matches.</p>

<p>&#39;top&#39; indicates whether we&#39;re recursing or at the top level. &#39;scalars_p&#39; is a pointer to a counter of the number of scalar SVs seen. This fn will increment it by the number seen. It&#39;s not intended to be an accurate count (especially as many ops can push a variable number of SVs onto the stack); rather it&#39;s used as to test whether there can be at most 1 SV pushed; so it&#39;s only meanings are &quot;0, 1, many&quot;. int aassign_scan(OP* o, bool rhs, bool top, int *scalars_p)</p>

</dd>
<dt id="arg_check_type">arg_check_type </dt>
<dd>

<p>Check if the declared static type of the argument from pn can be fullfilled by the dynamic type of the arg in OP* o (padsv, const, any return type). If possible add a typecast to <code>o</code> to fullfill it. contravariant.</p>

<p>Signatures are new, hence much stricter, than return-types and assignments. arg_check_type;</p>

</dd>
<dt id="can_class_typecheck">can_class_typecheck </dt>
<dd>

<p>Returns 1 if this class has a compile-time @ISA or we are already at the run-time phase. This is not called for coretypes, coretypes would always return 1.</p>

<p>Check for class or package types. Does the class has an compile-time ISA to allow compile-time checks? #249 HvCLASS: Is it a cperl class? Does it use base or fields? If not cannot do this check before run-time.</p>

<p>(Essentially cperl classes are just syntactic and performance optimized sugar over base/fields with roles and multi-dispatch support. We don&#39;t invent anything new, we just fix what p5p broke.)</p>

<pre><code>                can_class_typecheck;</code></pre>

</dd>
<dt id="check_for_bool_cxt">check_for_bool_cxt </dt>
<dd>

<p>See if the ops following o are such that o will always be executed in boolean context: that is, the SV which o pushes onto the stack will only ever be used by later ops with SvTRUE(sv) or similar. If so, set a suitable private flag on o. Normally this will be bool_flag; but if it&#39;s only possible to determine booleaness at run time (e.g. sub f { ....; (%h || $y) }), then set maybe_flag instead. void check_for_bool_cxt(OP* o, U8 bool_flag, U8 maybe_flag)</p>

</dd>
<dt id="ck_aassign">ck_aassign </dt>
<dd>

<p>CHECK callback for aassign (t2 L L &quot;(:List,:List):List&quot;)</p>

<p>Only checks types.</p>

<pre><code>        OP *    ck_aassign(OP *o)</code></pre>

</dd>
<dt id="ck_aelem">ck_aelem </dt>
<dd>

<p>Check for typed and shaped arrays, and promote ops.</p>

<p>With constant indices throws compile-time &quot;Array index out of bounds&quot; and &quot;Too many elements&quot; errors.</p>

<p>No natively typed arrays yet. OP * ck_aelem(OP *o)</p>

</dd>
<dt id="ck_anoncode">ck_anoncode </dt>
<dd>

<p>CHECK callback for anoncode (s$ S)</p>

<p>Creates an anon pad.</p>

<pre><code>        OP *    ck_anoncode(OP *o)</code></pre>

</dd>
<dt id="ck_backtick">ck_backtick </dt>
<dd>

<p>CHECK callback for `` and qx (tu% S?)</p>

<p>Handle readpipe overrides, the missing default argument and apply $^H{open_IN} or $^H{open_OUT} io hints.</p>

<p>TODO: Handle cperl macro `` unquote syntax here later. OP * ck_backtick(OP *o)</p>

</dd>
<dt id="ck_bitop">ck_bitop </dt>
<dd>

<p>CHECK callback for all bitops, if generic, integer or string variants.</p>

<p>Integerize the results (as if under use integer), and handle some warnings.</p>

<pre><code>        OP *    ck_bitop(OP *o)</code></pre>

</dd>
<dt id="ck_cmp">ck_cmp </dt>
<dd>

<p>CHECK callback for numeric comparisons.</p>

<p>Warn on $[</p>

<pre><code>        OP *    ck_cmp(OP *o)</code></pre>

</dd>
<dt id="ck_concat">ck_concat </dt>
<dd>

<p>CHECK callback for concat</p>

<p>Handles STACKED. Leaves out op_integerize, as concat is for strings only. OP * ck_concat(OP *o)</p>

</dd>
<dt id="ck_defined">ck_defined </dt>
<dd>

<p>CHECK callback for defined (isu% S? &quot;(:Scalar):Bool&quot;)</p>

<p>Errors now on @array and %hash arguments.</p>

<p>Also calls <a href="#ck_rfun">&quot;ck_rfun&quot;</a>, turning the argument into a reference, which is still useful for defined &amp;sub, not calling sub, just checking if &amp;sub has a body. OP * ck_defined(OP *o)</p>

</dd>
<dt id="ck_delete">ck_delete </dt>
<dd>

<p>CHECK callback for delete (% S &quot;(:Str):Void&quot;)</p>

<p>Handle array and hash elements and slices.</p>

<pre><code>        OP *    ck_delete(OP *o)</code></pre>

</dd>
<dt id="ck_each">ck_each </dt>
<dd>

<p>CHECK callback for each, valus and keys and its array variants.</p>

<p>Optimizes into the array specific variants, checks for type errors, and die on the old 5.14 experimental feature which allowed <code>each</code>, <code>keys</code>, <code>push</code>, <code>pop</code>, <code>shift</code>, <code>splice</code>, <code>unshift</code>, and <code>values</code> to be called with a scalar argument. See <a href="/cperl/perl5140delta.html#Syntactical-Enhancements">&quot;Syntactical Enhancements&quot; in perl5140delta</a> This experiment is considered unsuccessful, and has been removed.</p>

<pre><code>        OP *    ck_each(OP *o)</code></pre>

</dd>
<dt id="ck_eof">ck_eof </dt>
<dd>

<p>CHECK callback for getc and eof (is% F?)</p>

<p>Esp. set the missing default argument to *ARGV OP * ck_eof(OP *o)</p>

</dd>
<dt id="ck_eval">ck_eval </dt>
<dd>

<p>CHECK callback for entereval (du% S?) and entertry (d|)</p>

<p>... OP * ck_eval(OP *o)</p>

</dd>
<dt id="ck_exec">ck_exec </dt>
<dd>

<p>CHECK callback for system and exec (imsT@ S? L)</p>

<p>If as list or string.</p>

<pre><code>        OP *    ck_exec(OP *o)</code></pre>

</dd>
<dt id="ck_exists">ck_exists </dt>
<dd>

<p>CHECK callback for exists (is% S &quot;(:Str):Bool&quot;)</p>

<p>Handle hash or array elements, and ref subs.</p>

<pre><code>        OP *    ck_exists(OP *o)</code></pre>

</dd>
<dt id="ck_ftst">ck_ftst </dt>
<dd>

<p>CHECK callback for stat, lstat (u- F?) and the -X file tests (isu- F-+)</p>

<p>Handle _ and a missing optional arg.</p>

<pre><code>        OP *    ck_ftst(OP *o)</code></pre>

</dd>
<dt id="ck_fun">ck_fun </dt>
<dd>

<p>CHECK callback for the rest</p>

<p>check and fix arguments of internal op calls, but not entersub user-level signatured or prototyped calls. throw arity errors, unify arg list, e.g. add scalar cast, add $_ ... OP * ck_fun(OP *o)</p>

</dd>
<dt id="ck_glob">ck_glob </dt>
<dd>

<p>CHECK callback for glob (t@ S?)</p>

<p>glob defaults its first arg to $_</p>

<p>Also handles initializing an optional external File::Glob hook on certain platforms. OP * ck_glob(OP *o)</p>

</dd>
<dt id="ck_grep">ck_grep </dt>
<dd>

<p>CHECK callback for grepstart and mapstart (m@ C L)</p>

<p>Handles BLOCK and ordinary comma style, throwing an error if the comma-less version is not on a BLOCK.</p>

<p>Applies lexical $_ optimization or handles the default $_.</p>

<pre><code>        OP *    ck_grep(OP *o)</code></pre>

</dd>
<dt id="ck_index">ck_index </dt>
<dd>

<p>CHECK callback for index, rindex (sT@ S S S?)</p>

<p>Does compile-time fbm (Boyer-Moore) compilation on a constant string. OP * ck_index(OP *o)</p>

</dd>
<dt id="ck_length">ck_length </dt>
<dd>

<p>CHECK callback for length, only needed to throw compile-time warnings when length is mixed up with scalar.</p>

<pre><code>        OP *    ck_length(OP *o)</code></pre>

</dd>
<dt id="ck_lfun">ck_lfun </dt>
<dd>

<p>CHECK callback for {i_,}{pre,post}{inc,dec} (dIs1 S) and sprintf.</p>

<p>Turns on MOD on all kids, setting it to a lvalue function. See <a href="#modkids">&quot;modkids&quot;</a>. OP * ck_lfun(OP *o)</p>

</dd>
<dt id="ck_listiob">ck_listiob </dt>
<dd>

<p>CHECK callback for prtf,print,say (ims@ F? L)</p>

<p>Checks for the 1st bareword filehandle argument, if without comma. And if list argument was provided, or add $_. OP * ck_listiob(OP *o)</p>

</dd>
<dt id="ck_match">ck_match </dt>
<dd>

<p>CHECK callback for match,qr,subst,trans,transr</p>

<p>Sets TARGET_MY and the targ offset on my $_ (not with qr), which avoids runtime lookup of the global $_.</p>

<p>Note: This optimization was removed in perl5 with 5.24. In perl5 you have to fight with other dynamic default topics in blocks, overwriting each other. OP * ck_match(OP *o)</p>

</dd>
<dt id="ck_method">ck_method </dt>
<dd>

<p>CHECK callback for method (d.)</p>

<p>Creates one of the 4 METHOP ops. Checks for static SUPER:: calls. See also <a href="#ck_subr">&quot;ck_subr&quot;</a> OP * ck_method(OP *o)</p>

</dd>
<dt id="ck_negate">ck_negate </dt>
<dd>

<p>Check the ! op, negate and turn off OPpCONST_STRICT of the argument. OP * ck_negate(OP *o)</p>

</dd>
<dt id="ck_nomg">ck_nomg </dt>
<dd>

<p>For tie and bless</p>

<p>Check if the first argument is not a typed coretype. We guarantee coretyped variables to have no magic.</p>

<p>For bless we also require a ref. Check for the most common mistakes as first argument, which cannot be a ref.</p>

<p>For bless we can predict the result type if the 2nd arg is a constant. This allows to type the result of the new method.</p>

<pre><code>    sub D3::new {bless[],&quot;D3&quot;};
    my B2 $obj1 = D3-&gt;new;</code></pre>

<p>And we disallow the blessing to coretypes. This needs to be done via normal compile-time declarations, not dynamic blessing. OP * ck_nomg(OP *o)</p>

</dd>
<dt id="ck_pad">ck_pad </dt>
<dd>

<p>Check for const and types. Called from newOP/newPADOP this is too early, the target is attached later. But we also call it from constant folding. Having an explicit CONST op allows constant optimizations on it. OP * ck_pad(OP *o)</p>

</dd>
<dt id="ck_readline">ck_readline </dt>
<dd>

<p>CHECK callback for readline, the &lt;&gt; op. (t% F? &quot;(:Scalar):Any&quot;)</p>

<p>Adds <code>*ARGV</code> if missing. OP * ck_readline(OP *o)</p>

</dd>
<dt id="ck_rfun">ck_rfun </dt>
<dd>

<p>CHECK callback for lock (s% R)</p>

<p>Calls <a href="#refkids">&quot;refkids&quot;</a> to turn the argument into a reference.</p>

<p>Remember that lock can be called on everything, scalar, ref, array, hash or sub, but internally we better work with a scalar reference. OP * ck_rfun(OP *o)</p>

</dd>
<dt id="ck_rvconst">ck_rvconst </dt>
<dd>

<p>CHECK callback for rv2[gsc]const (ds1 R &quot;(:Ref):Scalar&quot;)</p>

<p>Error on bareword constants, initialize the symbol.</p>

<pre><code>        OP *    ck_rvconst(OP *o)</code></pre>

</dd>
<dt id="ck_sassign">ck_sassign </dt>
<dd>

<p>CHECK callback for sassign (s2 S S &quot;(:Scalar,:Scalar):Scalar&quot;)</p>

<p>Esp. handles state var initialization and tries to optimize away the assignment for a lexical <code>$_</code> via <a href="#maybe_targlex">&quot;maybe_targlex&quot;</a>.</p>

<p>Checks types.</p>

<pre><code>        OP *    ck_sassign(OP *o)</code></pre>

</dd>
<dt id="ck_smartmatch">ck_smartmatch </dt>
<dd>

<p>CHECK callback for smartmatch (s2)</p>

<p>Rearranges the kids if not SPECIAL, and optimizes the runtime MATCH to a compile-time QR. OP * ck_smartmatch(OP *o)</p>

</dd>
<dt id="ck_spair">ck_spair </dt>
<dd>

<p>CHECK callback for chop, chomp and refgen with optional lists</p>

<p>Transforms single-element lists into the single argument variant op srefgen, schop, schomp.</p>

<pre><code>        OP *    ck_spair(OP *o)</code></pre>

</dd>
<dt id="ck_subr">ck_subr </dt>
<dd>

<p>CHECK callback for entersub, enterxssub, both (dm1 L). See also <a href="#ck_method">&quot;ck_method&quot;</a> OP * ck_subr(OP *o)</p>

</dd>
<dt id="ck_substr">ck_substr </dt>
<dd>

<p>CHECK callback for substr (st@ S S S? S?) turning for the 4 arg variant into an lvalue sub. OP * ck_substr(OP *o)</p>

</dd>
<dt id="ck_svconst">ck_svconst </dt>
<dd>

<p>CHECK callback for const (ps$ &quot;():Scalar&quot;) and hintseval (s$)</p>

<p>Turns on COW and READONLY for the scalar. OP * ck_svconst(OP *o)</p>

</dd>
<dt id="ck_tell">ck_tell </dt>
<dd>

<p>CHECK callback for tell and seek OP * ck_tell(OP *o)</p>

</dd>
<dt id="ck_trunc">ck_trunc </dt>
<dd>

<p>CHECK callback for truncate (is@ S S) truncate really behaves as if it had both &quot;S S&quot; and &quot;F S&quot; i.e. with a bare handle argument turns on SPECIAL and off CONST_STRICT. OP * ck_trunc(OP *o)</p>

</dd>
<dt id="ck_type">ck_type </dt>
<dd>

<p>Check unop and binops for typed args, find specialized match and promote. Forget about native types (escape analysis) here, use the boxed variants. We can only unbox them later in rpeep sequences, by adding unbox...box ops. Set the OpRETTYPE of unops and binops. OP * ck_type(OP *o)</p>

</dd>
<dt id="inplace_aassign">inplace_aassign </dt>
<dd>

<p>Check for in place reverse and sort assignments like &quot;@a = reverse @a&quot; and modify the optree to make them work inplace.</p>

<pre><code>                inplace_aassign;</code></pre>

</dd>
<dt id="io_hints">io_hints </dt>
<dd>

<p>Apply $^H{open_IN} or $^H{open_OUT} io hints, by setting op_private bits for raw or crlf.</p>

<pre><code>        void    io_hints(OP* o)</code></pre>

</dd>
<dt id="is_types_strict">is_types_strict </dt>
<dd>

<p>Check if the current lexical block has <code>use types &#39;strict&#39;</code> enabled.</p>

<pre><code>                is_types_strict;</code></pre>

</dd>
<dt id="match_type1">match_type1 </dt>
<dd>

<p>match an UNOP type with the given arg.</p>

<pre><code>        int     match_type1(const U32 sig, core_types_t arg1)</code></pre>

</dd>
<dt id="match_type2">match_type2 </dt>
<dd>

<p>match an BINOP type with the given args.</p>

<pre><code>        int     match_type2(const U32 sig, core_types_t arg1,
                            core_types_t arg2)</code></pre>

</dd>
<dt id="match_user_type">match_user_type </dt>
<dd>

<pre><code>                                        |NN const char* aname|bool au8</code></pre>

<p>Match a usertype from argument (aname+au8) to the declared usertype name of a variable (dstash). Searches dstash in @aname::ISA (contravariant, for arguments).</p>

<p>On return-type checks the arguments get in reversed (covariant).</p>

<p>Note that old-style package ISA&#39;s are created dynamically. Only classes with compile-time known ISA&#39;s can be checked at compile-time. Which are currently: use base/fields using Internals::HvCLASS, and later the perl6 syntax class Name is Parent {} Todo: Moose syntax match_user_type;</p>

</dd>
<dt id="maybe_multideref">maybe_multideref </dt>
<dd>

<p>Given an op_next chain of ops beginning at &#39;start&#39; that potentially represent a series of one or more aggregate derefs (such as $a-&gt;[1]{$key}), examine the chain, and if appropriate, convert the whole chain to a single OP_MULTIDEREF op (maybe with a few additional ops left in too).</p>

<p>The caller will have already verified that the first few ops in the chain following &#39;start&#39; indicate a multideref candidate, and will have set &#39;orig_o&#39; to the point further on in the chain where the first index expression (if any) begins. &#39;orig_action&#39; specifies what type of beginning has already been determined by the ops between start..orig_o (e.g. $lex_ary[], $pkg_ary-&gt;{}, expr-&gt;[], etc).</p>

<p>&#39;hints&#39; contains any hints flags that need adding (currently just OPpHINT_STRICT_REFS) as found in any rv2av/hv skipped by the caller. void maybe_multideref(OP *start, OP *orig_o, UV orig_action, U8 hints)</p>

</dd>
<dt id="maybe_targlex">maybe_targlex </dt>
<dd>

<p>Sets the possible lexical $_ TARGET_MY optimization, skipping a scalar assignment. OP* maybe_targlex(OP* o)</p>

</dd>
<dt id="mderef_uoob_gvsv">mderef_uoob_gvsv </dt>
<dd>

<p>check the key index sv of the first INDEX_gvsv of a MDEREF_AV, compare it with the given key, and set INDEX_uoob.</p>

<p>Only available without threads. Threaded perls use <a href="#mderef_uoob_targ">&quot;mderef_uoob_targ&quot;</a> instead. bool mderef_uoob_gvsv(OP* o, SV* idx)</p>

</dd>
<dt id="mderef_uoob_targ">mderef_uoob_targ </dt>
<dd>

<p>check the targ of the first INDEX_padsv of a MDEREF_AV, compare it with the given targ, and set INDEX_uoob. bool mderef_uoob_targ(OP* o, PADOFFSET targ)</p>

</dd>
<dt id="op_check_type">_op_check_type </dt>
<dd>

<p>Check if the declared static type of the op (i.e. assignment) from the lhs pn can be fullfilled by the dynamic type of the rhs in OP* o (padsv, const, any return type). If possible add a typecast to o to fullfill it.</p>

<p>Different to arg_check_type a type violation is not fatal, it only throws a compile-time warning when no applicable type-conversion can be applied. Return-types and assignments are passed through the type inferencer and applied to old constructs, not signatures, hence not so strict.</p>

<p>Contravariant: Enables you to use a more generic (less derived) type than originally specified. _op_check_type;</p>

</dd>
<dt id="peep-void-peep-OP-o">peep  void peep(OP* o)</dt>
<dd>

</dd>
<dt id="peep_leaveloop">peep_leaveloop </dt>
<dd>

<p>check loop bounds and possibly turn aelem/mderef/aelemfast_lex into an unchecked faster aelem_u.</p>

<p>1) if index bound to size/arylen, optimize to unchecked aelem_u variants, even without parametrized typed. need to check the right array, and if the loop index is used as is, or within an expression.</p>

<p>2) with static bounds check unrolling.</p>

<p>3) with static ranges and shaped arrays, can possibly optimize to aelem_u</p>

<pre><code>        bool    peep_leaveloop(OP* leave, OP* from, OP* to)</code></pre>

</dd>
<dt id="ret_check_type">ret_check_type </dt>
<dd>

<p>Check if the declared static type of the return type from the lhs pn can be fullfilled by the dynamic type of the rhs in OP* o (padsv, const, any return type). If possible add a typecast to o to fullfill it.</p>

<p>Different to arg_check_type a type violation is not fatal, it only throws a compile-time warning when no applicable type-conversion can be applied. Return-types and assignments are passed through the type inferencer and applied to old constructs, not signatures, hence not so strict.</p>

<p>Covariant: Enables you to use a more derived type than originally specified. ret_check_type;</p>

</dd>
<dt id="rpeep">rpeep </dt>
<dd>

<p>The peephole optimizer. We visit the ops in the order they&#39;re to execute. See the comments at the top of this file for more details about when peep() is called.</p>

<p>Warning: rpeep is not a real peephole optimizer as other compilers implement it due to historic ballast. It started more as a glorified op nullifier. It sets op_opt when done, and does not run it again when it sees this flag at the op. When it&#39;s set it turns the op into NULL.</p>

<p>More important, it sets op_opt to 1 by default, even if it has no intention to nullify (&quot;optimize away&quot;) the current op. Any optimization which wants to keep the op needs to unset op_opt.</p>

<pre><code>        void    rpeep(OP* o)</code></pre>

</dd>
</dl>

<h1 id="Compile-time-scope-hooks">Compile-time scope hooks</h1>

<dl>

<dt id="BhkENTRY">BhkENTRY </dt>
<dd>

<p>NOTE: this function is experimental and may change or be removed without notice.</p>

<p>Return an entry from the BHK structure. <code>which</code> is a preprocessor token indicating which entry to return. If the appropriate flag is not set this will return <code>NULL</code>. The type of the return value depends on which entry you ask for.</p>

<pre><code>        void *  BhkENTRY(BHK *hk, which)</code></pre>

</dd>
<dt id="BhkFLAGS">BhkFLAGS </dt>
<dd>

<p>NOTE: this function is experimental and may change or be removed without notice.</p>

<p>Return the BHK&#39;s flags.</p>

<pre><code>        U32     BhkFLAGS(BHK *hk)</code></pre>

</dd>
<dt id="CALL_BLOCK_HOOKS">CALL_BLOCK_HOOKS </dt>
<dd>

<p>NOTE: this function is experimental and may change or be removed without notice.</p>

<p>Call all the registered block hooks for type <code>which</code>. <code>which</code> is a preprocessing token; the type of <code>arg</code> depends on <code>which</code>.</p>

<pre><code>        void    CALL_BLOCK_HOOKS(which, arg)</code></pre>

</dd>
<dt id="fold_constants">fold_constants </dt>
<dd>

<p>Apply constant folding to a scalar at compile-time, via a fake eval. Returns a new op_folded op which replaces the old constant expression, or the old unfolded op.</p>

<pre><code>        OP*     fold_constants(OP * const o)</code></pre>

</dd>
<dt id="gen_constant_list-OP-gen_constant_list-OP-o">gen_constant_list  OP* gen_constant_list(OP* o)</dt>
<dd>

</dd>
<dt id="jmaybe-OP-jmaybe-OP-o">jmaybe  OP* jmaybe(OP *o)</dt>
<dd>

</dd>
<dt id="localize-OP-localize-OP-o-I32-lex">localize  OP* localize(OP *o, I32 lex)</dt>
<dd>

</dd>
<dt id="op_integerize">op_integerize </dt>
<dd>

<p>Change the optype to the integer variant, when use integer is in scope.</p>

<pre><code>        OP*     op_integerize(OP *o)</code></pre>

</dd>
<dt id="op_std_init">op_std_init </dt>
<dd>

<p>Fixup all temp. pads: apply scalar context, and allocate missing targs.</p>

<pre><code>        OP*     op_std_init(OP *o)</code></pre>

</dd>
</dl>

<h1 id="Custom-Operators">Custom Operators</h1>

<dl>

<dt id="core_prototype">core_prototype </dt>
<dd>

<p>This function assigns the prototype of the named core function to <code>sv</code>, or to a new mortal SV if <code>sv</code> is <code>NULL</code>. It returns the modified <code>sv</code>, or <code>NULL</code> if the core function has no prototype. <code>code</code> is a code as returned by <code>keyword()</code>. It must not be equal to 0.</p>

<pre><code>        SV *    core_prototype(SV *sv, const char *name,
                               const int code,
                               int * const opnum)</code></pre>

</dd>
<dt id="coresub_op-OP-coresub_op-SV-const-coreargssv-const-int-code-const-int-opnum">coresub_op  OP * coresub_op(SV *const coreargssv, const int code, const int opnum)</dt>
<dd>

</dd>
<dt id="report_redefined_cv-void-report_redefined_cv-const-SV-name-const-CV-old_cv-SV-const-new_const_svp">report_redefined_cv  void report_redefined_cv(const SV *name, const CV *old_cv, SV * const *new_const_svp)</dt>
<dd>

</dd>
</dl>

<h1 id="CV-Manipulation-Functions">CV Manipulation Functions</h1>

<dl>

<dt id="check_type_and_open">check_type_and_open </dt>
<dd>

<p>Returns a PerlIO* object when the perl script name could be opened for reading. If not NULL.</p>

<pre><code>        PerlIO * check_type_and_open(SV *name)</code></pre>

</dd>
<dt id="create_eval_scope">create_eval_scope </dt>
<dd>

<p>NOTE: this function is experimental and may change or be removed without notice.</p>

<p>Common-ish code salvaged from Perl_call_sv and pp_entertry, because it was also needed by Perl_fold_constants. void create_eval_scope(OP *retop, U32 flags)</p>

</dd>
<dt id="delete_eval_scope">delete_eval_scope </dt>
<dd>

<p>NOTE: this function is experimental and may change or be removed without notice.</p>

<p>Common code for Perl_call_sv and Perl_fold_constants, put here to keep it close to the related Perl_create_eval_scope. void delete_eval_scope()</p>

</dd>
<dt id="docatch">docatch </dt>
<dd>

<p>Check for the cases 0 or 3 of cur_env.je_ret, only used inside an eval context.</p>

<p>0 is used as continue inside eval,</p>

<p>3 is used for a die caught by an inner eval - continue inner loop</p>

<p>See <i>cop.h</i>: je_mustcatch, when set at any runlevel to TRUE, means eval ops must establish a local jmpenv to handle exception traps.</p>

<pre><code>        OP*     docatch(OP *o)</code></pre>

</dd>
<dt id="doeval_compile">doeval_compile </dt>
<dd>

<p>Compile a require/do or an eval &#39;&#39;.</p>

<p>outside is the lexically enclosing CV (if any) that invoked us. seq is the current COP scope value. hh is the saved hints hash, if any.</p>

<p>Returns a bool indicating whether the compile was successful; if so, PL_eval_start contains the first op of the compiled code; otherwise, pushes undef.</p>

<p>This function is called from two places: pp_require and pp_entereval. These can be distinguished by whether PL_op is entereval.</p>

<pre><code>        bool    doeval_compile(U8 gimme, CV* outside, U32 seq,
                               HV* hh)</code></pre>

</dd>
<dt id="doopen_pm">doopen_pm </dt>
<dd>

<p>Returns a PerlIO* object when the perl module could be opened for reading. Includes optional compiled module .pmc handling.</p>

<pre><code>        PerlIO * doopen_pm(SV *name, bool pmc)</code></pre>

</dd>
<dt id="path_is_searchable">path_is_searchable </dt>
<dd>

<p>require doesn&#39;t search for absolute names, or when the name is explicitly relative the current directory. bool path_is_searchable(const char *name)</p>

</dd>
<dt id="require_file">require_file </dt>
<dd>

<p>Handle <code>require Foo::Bar</code>, <code>require &quot;Foo/Bar.pm&quot;</code> and <code>do &quot;Foo.pm&quot;</code>.</p>

<p>The first form will have already been converted at compile time to the second form. OP * require_file(SV *sv)</p>

</dd>
<dt id="require_version">require_version </dt>
<dd>

<p>Implements &#39;require 5.010001&#39;, the version check part of require. OP * require_version(SV *sv)</p>

</dd>
<dt id="try_yyparse">try_yyparse </dt>
<dd>

<p>Run yyparse() in a setjmp wrapper. Returns: 0: yyparse() successful 1: yyparse() failed 3: yyparse() died</p>

<pre><code>        int     try_yyparse(int gramtype)</code></pre>

</dd>
</dl>

<h1 id="CV-reference-counts-and-CvOUTSIDE">CV reference counts and CvOUTSIDE</h1>

<dl>

<dt id="CvWEAKOUTSIDE">CvWEAKOUTSIDE </dt>
<dd>

<p>Each CV has a pointer, <code>CvOUTSIDE()</code>, to its lexically enclosing CV (if any). Because pointers to anonymous sub prototypes are stored in <code>&amp;</code> pad slots, it is a possible to get a circular reference, with the parent pointing to the child and vice-versa. To avoid the ensuing memory leak, we do not increment the reference count of the CV pointed to by <code>CvOUTSIDE</code> in the <i>one specific instance</i> that the parent has a <code>&amp;</code> pad slot pointing back to us. In this case, we set the <code>CvWEAKOUTSIDE</code> flag in the child. This allows us to determine under what circumstances we should decrement the refcount of the parent when freeing the child.</p>

<p>There is a further complication with non-closure anonymous subs (i.e. those that do not refer to any lexicals outside that sub). In this case, the anonymous prototype is shared rather than being cloned. This has the consequence that the parent may be freed while there are still active children, <i>e.g.</i>,</p>

<pre><code>    BEGIN { $a = sub { eval &#39;$x&#39; } }</code></pre>

<p>In this case, the BEGIN is freed immediately after execution since there are no active references to it: the anon sub prototype has <code>CvWEAKOUTSIDE</code> set since it&#39;s not a closure, and $a points to the same CV, so it doesn&#39;t contribute to BEGIN&#39;s refcount either. When $a is executed, the <code>eval &#39;$x&#39;</code> causes the chain of <code>CvOUTSIDE</code>s to be followed, and the freed BEGIN is accessed.</p>

<p>To avoid this, whenever a CV and its associated pad is freed, any <code>&amp;</code> entries in the pad are explicitly removed from the pad, and if the refcount of the pointed-to anon sub is still positive, then that child&#39;s <code>CvOUTSIDE</code> is set to point to its grandparent. This will only occur in the single specific case of a non-closure anon prototype having one or more active references (such as <code>$a</code> above).</p>

<p>One other thing to consider is that a CV may be merely undefined rather than freed, eg <code>undef &amp;foo</code>. In this case, its refcount may not have reached zero, but we still delete its pad and its <code>CvROOT</code> etc. Since various children may still have their <code>CvOUTSIDE</code> pointing at this undefined CV, we keep its own <code>CvOUTSIDE</code> for the time being, so that the chain of lexical scopes is unbroken. For example, the following should print 123:</p>

<pre><code>    my $x = 123;
    sub tmp { sub { eval &#39;$x&#39; } }
    my $a = tmp();
    undef &amp;tmp;
    print  $a-&gt;();

        bool    CvWEAKOUTSIDE(CV *cv)</code></pre>

</dd>
</dl>

<h1 id="Debugging-Utilities">Debugging Utilities</h1>

<dl>

<dt id="append_gv_name">append_gv_name </dt>
<dd>

<p>Append to the out SV the name of the gv.</p>

<pre><code>        void    append_gv_name(GV *gv, SV *out)</code></pre>

</dd>
<dt id="append_padvar">append_padvar </dt>
<dd>

<p>Append to the out SV, the names of the n lexicals starting at offset off in the CV * cv.</p>

<pre><code>        void    append_padvar(PADOFFSET off, CV *cv, SV *out,
                              int n, bool paren,
                              char force_sigil)</code></pre>

</dd>
<dt id="av_dump">av_dump </dt>
<dd>

<p>Dump all the av values. sv_dump dumps only a limited amount of keys.</p>

<p>Only available with <code>-DDEBUGGING</code>.</p>

<pre><code>        void    av_dump(SV* av)</code></pre>

</dd>
<dt id="deb_hechain">deb_hechain </dt>
<dd>

<p>NOTE: this function is experimental and may change or be removed without notice.</p>

<p>Print the HE chain.</p>

<p>Only avalaible with <code>-DDEBUGGING</code>.</p>

<pre><code>        void    deb_hechain(HE* entry)</code></pre>

</dd>
<dt id="deb_hek">deb_hek </dt>
<dd>

<p>NOTE: this function is experimental and may change or be removed without notice.</p>

<p>Print the HEK key and value, along with the hash and flags.</p>

<p>Only avalaible with <code>-DDEBUGGING</code>.</p>

<pre><code>        void    deb_hek(HEK* hek, SV* val)</code></pre>

</dd>
<dt id="deb_padvar">deb_padvar </dt>
<dd>

<p>Print the names of the n lexical vars starting at pad offset off.</p>

<pre><code>        void    deb_padvar(PADOFFSET off, int n, bool paren)</code></pre>

</dd>
<dt id="hv_dump">hv_dump </dt>
<dd>

<p>Dump all the hv keys and optionally values. sv_dump dumps only a limited amount of keys.</p>

<p>Only available with <code>-DDEBUGGING</code>.</p>

<pre><code>        void    hv_dump(SV* sv, bool with_values)</code></pre>

</dd>
<dt id="multideref_stringify">multideref_stringify </dt>
<dd>

<p>Return a temporary SV containing a stringified representation of the op_aux field of a MULTIDEREF op, associated with CV cv</p>

<pre><code>        SV*     multideref_stringify(const OP* o, CV *cv)</code></pre>

</dd>
<dt id="sequence_num">sequence_num </dt>
<dd>

<p>Return a unique integer to represent the address of op o. If it already exists in PL_op_sequence, just return it; otherwise add it.</p>

<pre><code> *** Note that this isn&#39;t thread-safe.
        UV      sequence_num(const OP *o)</code></pre>

</dd>
<dt id="signature_stringify">signature_stringify </dt>
<dd>

<p>Return a temporary SV containing a stringified representation of the op_aux field of a SIGNATURE op, associated with CV cv.</p>

<pre><code>        SV*     signature_stringify(const OP* o, CV *cv)</code></pre>

</dd>
</dl>

<h1 id="Embedding-Functions">Embedding Functions</h1>

<dl>

<dt id="cv_dump">cv_dump </dt>
<dd>

<p>dump the contents of a CV</p>

<pre><code>        void    cv_dump(CV *cv, const char *title)</code></pre>

</dd>
<dt id="cv_forget_slab">cv_forget_slab </dt>
<dd>

<p>When a CV has a reference count on its slab (<code>CvSLABBED</code>), it is responsible for making sure it is freed. (Hence, no two CVs should ever have a reference count on the same slab.) The CV only needs to reference the slab during compilation. Once it is compiled and <code>CvROOT</code> attached, it has finished its job, so it can forget the slab.</p>

<pre><code>        void    cv_forget_slab(CV *cv)</code></pre>

</dd>
<dt id="do_dump_pad">do_dump_pad </dt>
<dd>

<p>Dump the contents of a padlist</p>

<pre><code>        void    do_dump_pad(I32 level, PerlIO *file,
                            PADLIST *padlist, int full)</code></pre>

</dd>
<dt id="open_script">open_script </dt>
<dd>

<pre><code>        PerlIO * open_script(const char *scriptname,
                             bool dosearch, bool *suidscript)</code></pre>

</dd>
<dt id="pad_alloc_name">pad_alloc_name </dt>
<dd>

<p>Allocates a place in the currently-compiling pad (via <a href="/cperl/perlapi.html#pad_alloc">&quot;pad_alloc&quot; in perlapi</a>) and then stores a name for that entry. <code>name</code> is adopted and becomes the name entry; it must already contain the name string. <code>typestash</code> and <code>ourstash</code> and the <code>padadd_STATE</code> flag get added to <code>name</code>. None of the other processing of <a href="/pod/perlapi.html#pad_add_name_pvn">&quot;pad_add_name_pvn&quot; in perlapi</a> is done. Returns the offset of the allocated pad slot.</p>

<pre><code>        PADOFFSET pad_alloc_name(PADNAME *name, U32 flags,
                                 HV *typestash, HV *ourstash)</code></pre>

</dd>
<dt id="pad_block_start">pad_block_start </dt>
<dd>

<p>Update the pad compilation state variables on entry to a new block.</p>

<pre><code>        void    pad_block_start(int full)</code></pre>

</dd>
<dt id="pad_check_dup">pad_check_dup </dt>
<dd>

<p>Check for duplicate declarations: report any of:</p>

<pre><code>     * a &#39;my&#39; in the current scope with the same name;
     * an &#39;our&#39; (anywhere in the pad) with the same name and the
       same stash as &#39;ourstash&#39;</code></pre>

<p><code>is_our</code> indicates that the name to check is an <code>&quot;our&quot;</code> declaration.</p>

<pre><code>        void    pad_check_dup(PADNAME *name, U32 flags,
                              const HV *ourstash)</code></pre>

</dd>
<dt id="pad_findlex">pad_findlex </dt>
<dd>

<p>Find a named lexical anywhere in a chain of nested pads. Add fake entries in the inner pads if it&#39;s found in an outer one.</p>

<p>Returns the offset in the bottom pad of the lex or the fake lex. <code>cv</code> is the CV in which to start the search, and seq is the current <code>cop_seq</code> to match against. If <code>warn</code> is true, print appropriate warnings. The <code>out_</code>* vars return values, and so are pointers to where the returned values should be stored. <code>out_capture</code>, if non-null, requests that the innermost instance of the lexical is captured; <code>out_name</code> is set to the innermost matched pad name or fake pad name; <code>out_flags</code> returns the flags normally associated with the <code>PARENT_FAKELEX_FLAGS</code> field of a fake pad name.</p>

<p>Note that <code>pad_findlex()</code> is recursive; it recurses up the chain of CVs, then comes back down, adding fake entries as it goes. It has to be this way because fake names in anon protoypes have to store in <code>xpadn_low</code> the index into the parent pad.</p>

<pre><code>        PADOFFSET pad_findlex(const char *namepv,
                              STRLEN namelen, U32 flags,
                              const CV* cv, U32 seq, int warn,
                              SV** out_capture,
                              PADNAME** out_name,
                              int *out_flags)</code></pre>

</dd>
<dt id="pad_fixup_inner_anons">pad_fixup_inner_anons </dt>
<dd>

<p>For any anon CVs in the pad, change <code>CvOUTSIDE</code> of that CV from <code>old_cv</code> to <code>new_cv</code> if necessary. Needed when a newly-compiled CV has to be moved to a pre-existing CV struct.</p>

<pre><code>        void    pad_fixup_inner_anons(PADLIST *padlist,
                                      CV *old_cv, CV *new_cv)</code></pre>

</dd>
<dt id="pad_free">pad_free </dt>
<dd>

<p>Free the SV at offset po in the current pad.</p>

<pre><code>        void    pad_free(PADOFFSET po)</code></pre>

</dd>
<dt id="pad_leavemy">pad_leavemy </dt>
<dd>

<p>Cleanup at end of scope during compilation: set the max seq number for lexicals in this scope and warn of any lexicals that never got introduced.</p>

<pre><code>        void    pad_leavemy()</code></pre>

</dd>
<dt id="padlist_dup">padlist_dup </dt>
<dd>

<p>Duplicates a pad.</p>

<pre><code>        PADLIST * padlist_dup(PADLIST *srcpad,
                              CLONE_PARAMS *param)</code></pre>

</dd>
<dt id="padname_dup">padname_dup </dt>
<dd>

<p>Duplicates a pad name.</p>

<pre><code>        PADNAME * padname_dup(PADNAME *src, CLONE_PARAMS *param)</code></pre>

</dd>
<dt id="padnamelist_dup">padnamelist_dup </dt>
<dd>

<p>Duplicates a pad name list.</p>

<pre><code>        PADNAMELIST * padnamelist_dup(PADNAMELIST *srcpad,
                                      CLONE_PARAMS *param)</code></pre>

</dd>
<dt id="pad_push">pad_push </dt>
<dd>

<p>Push a new pad frame onto the padlist, unless there&#39;s already a pad at this depth, in which case don&#39;t bother creating a new one. Then give the new pad an <code>@_</code> in slot zero.</p>

<pre><code>        void    pad_push(PADLIST *padlist, int depth)</code></pre>

</dd>
<dt id="pad_reset">pad_reset </dt>
<dd>

<p>Mark all the current temporaries for reuse</p>

<pre><code>        void    pad_reset()</code></pre>

</dd>
<dt id="pad_swipe">pad_swipe </dt>
<dd>

<p>Abandon the tmp in the current pad at offset <code>po</code> and replace with a new one.</p>

<pre><code>        void    pad_swipe(PADOFFSET po, bool refadjust)</code></pre>

</dd>
</dl>

<h1 id="Functions-in-file-op.c">Functions in file op.c</h1>

<dl>

<dt id="new_slab">new_slab </dt>
<dd>

<p>Creates a new memory region, a slab, for ops, with room for sz pointers. sz starts with PERL_SLAB_SIZE (=64) and is then extended by factor two in Slab_Alloc().</p>

<pre><code>                new_slab;</code></pre>

</dd>
<dt id="no_fh_allowed">no_fh_allowed </dt>
<dd>

<p>Throws a parser error: Missing comma after first argument to %s function for an op which does not take an optional comma-less filehandle argument. i.e. not <code>print $fh arg</code>, rather <code>call $fh, $arg</code>.</p>

<pre><code>                no_fh_allowed;</code></pre>

</dd>
<dt id="op_next_nn">op_next_nn </dt>
<dd>

<p>Returns the next non-NULL op, skipping all NULL ops in the chain.</p>

<pre><code>        OP*     op_next_nn</code></pre>

</dd>
<dt id="opslab_force_free">opslab_force_free </dt>
<dd>

<p>Forcefully frees the slab area, even if there are still live OPs in it. Frees all the containing OPs.</p>

<p>NOTE: the perl_ form of this function is deprecated.</p>

<pre><code>        void    opslab_force_free(OPSLAB *slab)</code></pre>

</dd>
<dt id="opslab_free">opslab_free </dt>
<dd>

<p>Frees the slab area.</p>

<p>NOTE: the perl_ form of this function is deprecated.</p>

<pre><code>        void    opslab_free(OPSLAB *slab)</code></pre>

</dd>
<dt id="opslab_free_nopad">opslab_free_nopad </dt>
<dd>

<p>Frees the slab area, embedded into temporary disabling PL_comppad.</p>

<p>NOTE: the perl_ form of this function is deprecated.</p>

<pre><code>        void    opslab_free_nopad(OPSLAB *slab)</code></pre>

</dd>
<dt id="prune_chain_head">prune_chain_head </dt>
<dd>

<p>remove any leading &quot;empty&quot; ops from the op_next chain whose first node&#39;s address is stored in op_p. Store the updated address of the first node in op_p.</p>

<pre><code>                prune_chain_head;</code></pre>

</dd>
<dt id="Slab_Alloc">Slab_Alloc </dt>
<dd>

<p>Creates a new memory region, a slab, for some ops, with room for sz pointers. sz starts with PERL_SLAB_SIZE (=64) and is then extended by factor two.</p>

<p>NOTE: the perl_ form of this function is deprecated.</p>

<pre><code>        void*   Slab_Alloc(size_t sz)</code></pre>

</dd>
<dt id="Slab_Free">Slab_Free </dt>
<dd>

<p>Free memory for the slabbed op.</p>

<p>NOTE: the perl_ form of this function is deprecated.</p>

<pre><code>        void    Slab_Free(void *op)</code></pre>

</dd>
<dt id="typename">typename </dt>
<dd>

<p>Returns the sanitized typename of the stash of the padname type, without main:: prefix.</p>

<pre><code>                typename;</code></pre>

</dd>
</dl>

<h1 id="GV-Functions">GV Functions</h1>

<dl>

<dt id="gv_magicalize">gv_magicalize </dt>
<dd>

<pre><code>                     |STRLEN len|const svtype sv_type

 * gv_magicalize() is called by gv_fetchpvn_flags when creating
 * a new GV, gv is NN.
 * Note that it does not insert the GV into the stash prior to
 * magicalization, which some variables require need in order
 * to work (like $[, %+, %-, %!), so callers must take care of
 * that.
 * 
 * It returns true if the gv did turn out to be magical one; i.e.,
 * if gv_magicalize actually did something.
 */
PERL_STATIC_INLINE bool
S_gv_magicalize(pTHX_ GV *gv, HV *stash, const char *name, STRLEN len,
                      const svtype sv_type)
{
    I32 paren;

    PERL_ARGS_ASSERT_GV_MAGICALIZE;
    
    if (stash != PL_defstash) { /* not the main stash */
        /* We only have to check for a few names here: a, b, EXPORT*, ISA
           and VERSION. All the others apply only to the main stash or to
           CORE (which is checked right after this). */
        if (len) {
            switch (*name) {
            case &#39;E&#39;:
                if (
                    len &gt;= 6 &amp;&amp; name[1] == &#39;X&#39; &amp;&amp;
                    (memEQs(name, len, &quot;EXPORT&quot;)
                    ||memEQs(name, len, &quot;EXPORT_OK&quot;)
                    ||memEQs(name, len, &quot;EXPORT_FAIL&quot;)
                    ||memEQs(name, len, &quot;EXPORT_TAGS&quot;))
                )
                    GvMULTI_on(gv);
                break;
            case &#39;I&#39;:
                if (memEQs(name, len, &quot;ISA&quot;))
                    gv_magicalize_isa(gv);
                break;
            case &#39;V&#39;:
                if (memEQs(name, len, &quot;VERSION&quot;))
                    GvMULTI_on(gv);
                break;
            case &#39;a&#39;:
                if (stash == PL_debstash &amp;&amp; len==4 &amp;&amp; memEQc(name,&quot;args&quot;)) {
                    GvMULTI_on(gv_AVadd(gv));
                    break;
                }
                /* FALLTHROUGH for a */
            case &#39;b&#39;:
                if (len == 1 &amp;&amp; sv_type == SVt_PV)
                    GvMULTI_on(gv);
                /* FALLTHROUGH */
            default:
                goto try_core;
            }
            goto ret;
        }
      try_core:
        if (len &gt; 1 /* shortest is uc */ &amp;&amp; HvNAMELEN_get(stash) == 4) {
            /* Avoid null warning: */
            const char * const stashname = HvNAME(stash); assert(stashname);
            if (memEQc(stashname, &quot;CORE&quot;))
                S_maybe_add_coresub(aTHX_ 0, gv, name, len);
        }
    }
    else if (len &gt; 1) {
#ifndef EBCDIC
        if (*name &gt; &#39;V&#39; ) {
            NOOP;
            /* Nothing else to do.
               The compiler will probably turn the switch statement into a
               branch table. Make sure we avoid even that small overhead for
               the common case of lower case variable names.  (On EBCDIC
               platforms, we can&#39;t just do:
                 if (NATIVE_TO_ASCII(*name) &gt; NATIVE_TO_ASCII(&#39;V&#39;) ) {
               because cases like &#39;\027&#39; in the switch statement below are
               C1 (non-ASCII) controls on those platforms, so the remapping
               would make them larger than &#39;V&#39;)
             */
        } else
#endif
        {
            switch (*name) {
            case &#39;A&#39;:
                if (strEQc(name, &quot;ARGV&quot;))
                    IoFLAGS(GvIOn_NN(gv)) |= IOf_ARGV|IOf_START;
                else if (strEQc(name, &quot;ARGVOUT&quot;))
                    GvMULTI_on(gv);
                break;
            case &#39;E&#39;:
                if (
                    len &gt;= 6 &amp;&amp; name[1] == &#39;X&#39; &amp;&amp;
                    (memEQs(name, len, &quot;EXPORT&quot;)
                    ||memEQs(name, len, &quot;EXPORT_OK&quot;)
                    ||memEQs(name, len, &quot;EXPORT_FAIL&quot;)
                    ||memEQs(name, len, &quot;EXPORT_TAGS&quot;))
                )
                    GvMULTI_on(gv);
                break;
            case &#39;I&#39;:
                if (strEQc(name, &quot;ISA&quot;)) {
                    gv_magicalize_isa(gv);
                }
                break;
            case &#39;S&#39;:
                if (strEQc(name, &quot;SIG&quot;)) {
                    HV *hv;
                    I32 i;
                    if (!PL_psig_name) {
                        Newxz(PL_psig_name, 2 * SIG_SIZE, SV*);
                        Newxz(PL_psig_pend, SIG_SIZE, int);
                        PL_psig_ptr = PL_psig_name + SIG_SIZE;
                    } else {
                        /* I think that the only way to get here is to re-use an
                           embedded perl interpreter, where the previous
                           use didn&#39;t clean up fully because
                           PL_perl_destruct_level was 0. I&#39;m not sure that we
                           &quot;support&quot; that, in that I suspect in that scenario
                           there are sufficient other garbage values left in the
                           interpreter structure that something else will crash
                           before we get here. I suspect that this is one of
                           those &quot;doctor, it hurts when I do this&quot; bugs.  */
                        Zero(PL_psig_name, 2 * SIG_SIZE, SV*);
                        Zero(PL_psig_pend, SIG_SIZE, int);
                    }
                    GvMULTI_on(gv);
                    hv = GvHVn(gv);
                    hv_magic(hv, NULL, PERL_MAGIC_sig);
                    for (i = 1; i &lt; SIG_SIZE; i++) {
                        SV * const * const init = hv_fetch(hv, PL_sig_name[i], strlen(PL_sig_name[i]), 1);
                        if (init)
                            sv_setsv(*init, UNDEF);
                    }
                }
                break;
            case &#39;V&#39;:
                if (strEQc(name, &quot;VERSION&quot;))
                    GvMULTI_on(gv);
                break;
            case &#39;\003&#39;:        /* $^CHILD_ERROR_NATIVE */
                if (strEQc(name, &quot;\003HILD_ERROR_NATIVE&quot;))
                    goto magicalize;
                                /* @{^CAPTURE} %{^CAPTURE} */
                if (memEQs(name, len, &quot;\003APTURE&quot;)) {
                    AV* const av = GvAVn(gv);
                    UV uv= *name;

                    sv_magic(MUTABLE_SV(av), (SV*)uv, PERL_MAGIC_regdata, NULL, 0);
                    SvREADONLY_on(av);

                    if (sv_type == SVt_PVHV || sv_type == SVt_PVGV)
                        require_tie_mod_s(gv, &#39;-&#39;, &quot;Tie::Hash::NamedCapture&quot;,0);

                } else          /* %{^CAPTURE_ALL} */
                if (memEQs(name, len, &quot;\003APTURE_ALL&quot;)) {
                    if (sv_type == SVt_PVHV || sv_type == SVt_PVGV)
                        require_tie_mod_s(gv, &#39;+&#39;, &quot;Tie::Hash::NamedCapture&quot;,0);
                }
                break;
            case &#39;\005&#39;:        /* $^ENCODING */
                if (strEQc(name, &quot;\005NCODING&quot;))
                    goto magicalize;
                if (strEQc(name, &quot;\005_NCODING&quot;))
                    goto magicalize;
                break;
            case &#39;\007&#39;:        /* $^GLOBAL_PHASE */
                if (strEQc(name, &quot;\007LOBAL_PHASE&quot;))
                    goto ro_magicalize;
                break;
            case &#39;\014&#39;:        /* $^LAST_FH */
                if (strEQc(name, &quot;\014AST_FH&quot;))
                    goto ro_magicalize;
                break;
            case &#39;\015&#39;:        /* $^MATCH */
                if (strEQc(name, &quot;\015ATCH&quot;)) {
                    paren = RX_BUFF_IDX_CARET_FULLMATCH;
                    goto storeparen;
                }
                break;
            case &#39;\017&#39;:        /* $^OPEN */
                if (strEQc(name, &quot;\017PEN&quot;))
                    goto magicalize;
                break;
            case &#39;\020&#39;:        /* $^PREMATCH  $^POSTMATCH */
                if (strEQc(name, &quot;\020REMATCH&quot;)) {
                    paren = RX_BUFF_IDX_CARET_PREMATCH;
                    goto storeparen;
                }
                if (strEQc(name, &quot;\020OSTMATCH&quot;)) {
                    paren = RX_BUFF_IDX_CARET_POSTMATCH;
                    goto storeparen;
                }
                break;
            case &#39;\024&#39;:        /* ${^TAINT} */
                if (strEQc(name, &quot;\024AINT&quot;))
                    goto ro_magicalize;
                break;
            case &#39;\025&#39;:        /* ${^UNICODE}, ${^UTF8LOCALE} */
                if (strEQc(name, &quot;\025NICODE&quot;))
                    goto ro_magicalize;
                if (strEQc(name, &quot;\025TF8LOCALE&quot;))
                    goto ro_magicalize;
                if (strEQc(name, &quot;\025TF8CACHE&quot;))
                    goto magicalize;
                break;
            case &#39;\027&#39;:        /* $^WARNING_BITS */
                if (strEQc(name, &quot;\027ARNING_BITS&quot;))
                    goto magicalize;
#ifdef WIN32
                else if (strEQc(name, &quot;\025IN32_SLOPPY_STAT&quot;))
                    goto magicalize;
#endif
                break;
            case &#39;1&#39;:
            case &#39;2&#39;:
            case &#39;3&#39;:
            case &#39;4&#39;:
            case &#39;5&#39;:
            case &#39;6&#39;:
            case &#39;7&#39;:
            case &#39;8&#39;:
            case &#39;9&#39;:
                {
                    /* Ensures that we have an all-digit variable, ${&quot;1foo&quot;} fails
                       this test  */
                    UV uv;
                    if (!grok_atoUV(name, &amp;uv, NULL) || uv &gt; I32_MAX)
                        goto ret;
                    if (UNLIKELY(uv &gt; I32_MAX))
                        Perl_croak(aTHX_ &quot;panic: gv name too long (%&quot; UVuf &quot;)&quot;, uv);
                    paren = (I32)uv;
                    goto storeparen;
                }
            }
        }
    } else {
        /* Names of length 1.  (Or 0. But name is NUL terminated, so that will
           be case &#39;\0&#39; in this switch statement (ie a default case)  */
        switch (*name) {
        case &#39;&amp;&#39;:               /* $&amp; */
            paren = RX_BUFF_IDX_FULLMATCH;
            goto sawampersand;
        case &#39;`&#39;:               /* $` */
            paren = RX_BUFF_IDX_PREMATCH;
            goto sawampersand;
        case &#39;\&#39;&#39;:              /* $&#39; */
            paren = RX_BUFF_IDX_POSTMATCH;
        sawampersand:
#ifdef PERL_SAWAMPERSAND
            if (!(
                sv_type == SVt_PVAV ||
                sv_type == SVt_PVHV ||
                sv_type == SVt_PVCV ||
                sv_type == SVt_PVFM ||
                sv_type == SVt_PVIO
                )) { PL_sawampersand |=
                        (*name == &#39;`&#39;)
                            ? SAWAMPERSAND_LEFT
                            : (*name == &#39;&amp;&#39;)
                                ? SAWAMPERSAND_MIDDLE
                                : SAWAMPERSAND_RIGHT;
                }
#endif
            goto storeparen;
        case &#39;1&#39;:               /* $1 */
        case &#39;2&#39;:               /* $2 */
        case &#39;3&#39;:               /* $3 */
        case &#39;4&#39;:               /* $4 */
        case &#39;5&#39;:               /* $5 */
        case &#39;6&#39;:               /* $6 */
        case &#39;7&#39;:               /* $7 */
        case &#39;8&#39;:               /* $8 */
        case &#39;9&#39;:               /* $9 */
            paren = *name - &#39;0&#39;;

        storeparen:
            /* Flag the capture variables with a NULL mg_ptr
               Use mg_len for the array index to lookup.  */
            sv_magic(GvSVn(gv), MUTABLE_SV(gv), PERL_MAGIC_sv, NULL, paren);
            break;

        case &#39;:&#39;:               /* $: */
            sv_setpv(GvSVn(gv),PL_chopset);
            goto magicalize;

        case &#39;?&#39;:               /* $? */
#ifdef COMPLEX_STATUS
            SvUPGRADE(GvSVn(gv), SVt_PVLV);
#endif
            goto magicalize;

        case &#39;!&#39;:               /* $! */
            GvMULTI_on(gv);
            /* If %! has been used, automatically load Errno.pm. */

            sv_magic(GvSVn(gv), MUTABLE_SV(gv), PERL_MAGIC_sv, name, len);

            /* magicalization must be done before require_tie_mod_s is called */
            if (sv_type == SVt_PVHV || sv_type == SVt_PVGV)
                require_tie_mod_s(gv, &#39;!&#39;, &quot;Errno&quot;, 1);

            break;
        case &#39;-&#39;:               /* $-, %-, @- */
        case &#39;+&#39;:               /* $+, %+, @+ */
            GvMULTI_on(gv); /* no used once warnings here */
            {   /* $- $+ */
                sv_magic(GvSVn(gv), MUTABLE_SV(gv), PERL_MAGIC_sv, name, len);
                if (*name == &#39;+&#39;)
                    SvREADONLY_on(GvSVn(gv));
            }
            {   /* %- %+ */
                if (sv_type == SVt_PVHV || sv_type == SVt_PVGV)
                    require_tie_mod_s(gv, *name, &quot;Tie::Hash::NamedCapture&quot;,0);
            }
            {   /* @- @+ */
                AV* const av = GvAVn(gv);
                const UV uv = (UV)*name;

                sv_magic(MUTABLE_SV(av), (SV*)uv, PERL_MAGIC_regdata, NULL, 0);
                SvREADONLY_on(av);
            }
            break;
        case &#39;*&#39;:               /* $* */
        case &#39;#&#39;:               /* $# */
            if (sv_type == SVt_PV)
                /* diag_listed_as: $* is no longer supported */
                Perl_ck_warner_d(aTHX_ packWARN2(WARN_DEPRECATED, WARN_SYNTAX),
                                 &quot;$%c is no longer supported&quot;, *name);
            break;
        case &#39;\010&#39;:    /* $^H */
            {
                HV *const hv = GvHVn(gv);
                hv_magic(hv, NULL, PERL_MAGIC_hints);
            }
            goto magicalize;
        case &#39;[&#39;:               /* $[ */
            if ((sv_type == SVt_PV || sv_type == SVt_PVGV)
             &amp;&amp; FEATURE_ARYBASE_IS_ENABLED) {
                require_tie_mod_s(gv,&#39;[&#39;,&quot;arybase&quot;,0);
            }
            else goto magicalize;
            break;
        case &#39;\023&#39;:    /* $^S */
        ro_magicalize:
            SvREADONLY_on(GvSVn(gv));
            /* FALLTHROUGH */
        case &#39;0&#39;:               /* $0 */
        case &#39;^&#39;:               /* $^ */
        case &#39;~&#39;:               /* $~ */
        case &#39;=&#39;:               /* $= */
        case &#39;%&#39;:               /* $% */
        case &#39;.&#39;:               /* $. */
        case &#39;(&#39;:               /* $( */
        case &#39;)&#39;:               /* $) */
        case &#39;&lt;&#39;:               /* $&lt; */
        case &#39;&gt;&#39;:               /* $&gt; */
        case &#39;\\&#39;:              /* $\ */
        case &#39;/&#39;:               /* $/ */
        case &#39;|&#39;:               /* $| */
        case &#39;$&#39;:               /* $$ */
        case &#39;\001&#39;:    /* $^A */
        case &#39;\003&#39;:    /* $^C */
        case &#39;\004&#39;:    /* $^D */
        case &#39;\005&#39;:    /* $^E */
        case &#39;\006&#39;:    /* $^F */
        case &#39;\011&#39;:    /* $^I, NOT \t in EBCDIC */
        case &#39;\016&#39;:    /* $^N */
        case &#39;\017&#39;:    /* $^O */
        case &#39;\020&#39;:    /* $^P */
        case &#39;\024&#39;:    /* $^T */
        case &#39;\027&#39;:    /* $^W */
        magicalize:
            sv_magic(GvSVn(gv), MUTABLE_SV(gv), PERL_MAGIC_sv, name, len);
            break;

        case &#39;\014&#39;:    /* $^L */
            sv_setpvs(GvSVn(gv),&quot;\f&quot;);
            break;
        case &#39;;&#39;:               /* $; */
            sv_setpvs(GvSVn(gv),&quot;\034&quot;);
            break;
        case &#39;]&#39;:               /* $] */
        {
            SV * const sv = GvSV(gv);
            if (!sv_derived_from(PL_patchlevel, &quot;version&quot;))
                upg_version(PL_patchlevel, TRUE);
            GvSV(gv) = vnumify(PL_patchlevel);
            SvREADONLY_on(GvSV(gv));
            SvREFCNT_dec(sv);
        }
        break;
        case &#39;\026&#39;:    /* $^V */
        {
            SV * const sv = GvSV(gv);
            GvSV(gv) = new_version(PL_patchlevel);
            SvREADONLY_on(GvSV(gv));
            SvREFCNT_dec(sv);
        }
        break;
        case &#39;a&#39;:
        case &#39;b&#39;:
            if (sv_type == SVt_PV)
                GvMULTI_on(gv);
        }
    }

   ret:
    /* Return true if we actually did something.  */
    {
        const GP* const gp = GvGP(gv);
        return gp-&gt;gp_av || gp-&gt;gp_hv || gp-&gt;gp_io || gp-&gt;gp_cv
            || ( gp-&gt;gp_sv &amp;&amp; (SvOK(gp-&gt;gp_sv) || SvMAGICAL(gp-&gt;gp_sv)));
    }
}</code></pre>

<p>/* If we do ever start using this later on in the file, we need to make sure we don&rsquo;t accidentally use the wrong definition. */ #undef SvREADONLY_on</p>

<p>/* This function is called when the stash already holds the GV of the magic * variable we&#39;re looking for, but we need to check that it has the correct * kind of magic. For example, if someone first uses $! and then %!, the * latter would end up here, and we add the Errno tie to the HASH slot of * the *! glob. */ PERL_STATIC_INLINE void S_maybe_multimagic_gv(pTHX_ GV *gv, const char *name, const svtype sv_type) { PERL_ARGS_ASSERT_MAYBE_MULTIMAGIC_GV;</p>

<pre><code>    if (sv_type == SVt_PVHV || sv_type == SVt_PVGV) {
        if (*name == &#39;!&#39;)
            require_tie_mod_s(gv, &#39;!&#39;, &quot;Errno&quot;, 1);
        else if (*name == &#39;-&#39; || *name == &#39;+&#39;)
            require_tie_mod_s(gv, *name, &quot;Tie::Hash::NamedCapture&quot;, 0);
    } else if (sv_type == SVt_PV) {
        if (*name == &#39;*&#39; || *name == &#39;#&#39;) {
            /* diag_listed_as: $* is no longer supported */
            Perl_ck_warner_d(aTHX_ packWARN2(WARN_DEPRECATED,
                                             WARN_SYNTAX),
                             &quot;$%c is no longer supported&quot;, *name);
        }
    }
    if (sv_type==SVt_PV || sv_type==SVt_PVGV) {
      switch (*name) {
      case &#39;[&#39;:
          require_tie_mod_s(gv,&#39;[&#39;,&quot;arybase&quot;,0);
          break;
#ifdef PERL_SAWAMPERSAND
      case &#39;`&#39;:
          PL_sawampersand |= SAWAMPERSAND_LEFT;
          (void)GvSVn(gv);
          break;
      case &#39;&amp;&#39;:
          PL_sawampersand |= SAWAMPERSAND_MIDDLE;
          (void)GvSVn(gv);
          break;
      case &#39;\&#39;&#39;:
          PL_sawampersand |= SAWAMPERSAND_RIGHT;
          (void)GvSVn(gv);
          break;
#endif
      }
    }
}</code></pre>

<p>GV * Perl_gv_fetchpvn_flags(pTHX_ const char *nambeg, STRLEN full_len, I32 flags, const svtype sv_type) { const char *name = nambeg; const char *const name_end = nambeg + full_len; GV *gv = NULL; GV**gvp; HV *stash = NULL; STRLEN len; const I32 no_init = flags &amp; (GV_NOADD_NOINIT | GV_NOINIT); const I32 no_expand = flags &amp; GV_NOEXPAND; const I32 add = flags &amp; ~GV_NOADD_MASK; const U32 is_utf8 = flags &amp; SVf_UTF8; U32 faking_it; bool addmg = cBOOL(flags &amp; GV_ADDMG);</p>

<pre><code>    PERL_ARGS_ASSERT_GV_FETCHPVN_FLAGS;

     /* If we have GV_NOTQUAL, the caller promised that
      * there is no stash, so we can skip the check.
      * Similarly if full_len is 0, since then we&#39;re
      * dealing with something like *{&quot;&quot;} or &quot;&quot;-&gt;foo()
      */
    if ((flags &amp; GV_NOTQUAL) || !full_len)
        len = full_len;
    else if (parse_gv_stash_name(&amp;stash, &amp;gv, &amp;name, &amp;len, nambeg, full_len, is_utf8, add)) {
        if (name == name_end) return gv;
    }
    else
        return NULL;

    if (!stash &amp;&amp; !find_default_stash(&amp;stash, name, len, is_utf8, add, sv_type))
        return NULL;
    if (SvTYPE(stash) != SVt_PVHV)
        return NULL;
    
    /* By this point we should have a stash and a name */
    /* On protected stashes and !add try exists first */
    if (SvREADONLY(stash) &amp;&amp; !add)
        if (!hv_exists(stash, name, is_utf8 ? -(I32)len : (I32)len)) {
            if (addmg) gv = (GV *)newSV(0);
            else return NULL;
        }
    gvp = (GV**)hv_fetch(stash, name, is_utf8 ? -(I32)len : (I32)len,add);
    if (!gvp || *gvp == (const GV *)UNDEF) {
        if (addmg) gv = (GV *)newSV(0);
        else return NULL;
    }
    else gv = *gvp, addmg = 0;
    /* From this point on, addmg means gv has not been inserted in the
       symtab yet. */

    if (SvTYPE(gv) == SVt_PVGV) {
        /* The GV already exists, so return it, but check if we need to do
         * anything else with it before that.
         */
        if (add) {
            /* This is the heuristic that handles if a variable triggers the
             * &#39;used only once&#39; warning.  If there&#39;s already a GV in the stash
             * with this name, then we assume that the variable has been used
             * before and turn its MULTI flag on.
             * It&#39;s a heuristic because it can easily be &quot;tricked&quot;, like with
             * BEGIN { $a = 1; $::{foo} = *a }; () = $foo
             * not warning about $main::foo being used just once
             */
            GvMULTI_on(gv);
            gv_init_svtype(gv, sv_type);
            /* You reach this path once the typeglob has already been created,
               either by the same or a different sigil.  If this path didn&#39;t
               exist, then (say) referencing $! first, and %! second would
               mean that %! was not handled correctly.  */
            if (len == 1 &amp;&amp; stash == PL_defstash) {
                maybe_multimagic_gv(gv, name, sv_type);
            }
            else if (len == 3 &amp;&amp; sv_type == SVt_PVAV
                  &amp;&amp; strEQc(name, &quot;ISA&quot;)
                  &amp;&amp; (!GvAV(gv) || !SvSMAGICAL(GvAV(gv))))
                gv_magicalize_isa(gv);
        }
        return gv;
    } else if (no_init) {
        assert(!addmg);
        return gv;
    }
    /* If GV_NOEXPAND is true and what we got off the stash is a ref,
     * don&#39;t expand it to a glob. This is an optimization so that things
     * copying constants over, like Exporter, don&#39;t have to be rewritten
     * to take into account that you can store more than just globs in
     * stashes.
     */
    else if (no_expand &amp;&amp; SvROK(gv)) {
        assert(!addmg);
        return gv;
    }

    /* Adding a new symbol.
       Unless of course there was already something non-GV here, in which case
       we want to behave as if there was always a GV here, containing some sort
       of subroutine.
       Otherwise we run the risk of creating things like GvIO, which can cause
       subtle bugs. eg the one that tripped up SQL::Translator  */

    faking_it = SvOK(gv);

    if (add &amp; GV_ADDWARN)
        Perl_ck_warner_d(aTHX_ packWARN(WARN_INTERNAL),
                &quot;Had to create %&quot; UTF8f &quot; unexpectedly&quot;,
                 UTF8fARG(is_utf8, name_end-nambeg, nambeg));
    gv_init_pvn(gv, stash, name, len, (add &amp; GV_ADDMULTI)|is_utf8);

    if (   full_len != 0
        &amp;&amp; isIDFIRST_lazy_if_safe(name, name + full_len, is_utf8)
        &amp;&amp; !ckWARN(WARN_ONCE) )
    {
        GvMULTI_on(gv) ;
    }

    /* set up magic where warranted */
    if ( gv_magicalize(gv, stash, name, len, sv_type) ) {
        /* See 23496c6 */
        if (addmg) {
                /* gv_magicalize magicalised this gv, so we want it
                 * stored in the symtab.
                 * Effectively the caller is asking, &lsquo;Does this gv exist?&rsquo; 
                 * And we respond, &lsquo;Er, *now* it does!&rsquo;
                 */
                (void)hv_store(stash,name,len,(SV *)gv,0);
        }
    }
    else if (addmg) {
                /* The temporary GV created above */
                SvREFCNT_dec_NN(gv);
                gv = NULL;
    }
    
    if (gv) gv_init_svtype(gv, faking_it ? SVt_PVCV : sv_type);
    return gv;
}</code></pre>

<p>void Perl_gv_fullname4(pTHX_ SV *sv, const GV *gv, const char *prefix, bool keepmain) { const char *name; const HV * const hv = GvSTASH(gv);</p>

<pre><code>    PERL_ARGS_ASSERT_GV_FULLNAME4;

    sv_setpv(sv, prefix ? prefix : &quot;&quot;);

    if (hv &amp;&amp; (name = HvNAME(hv))) {
        const STRLEN len = HvNAMELEN(hv);
        if (keepmain || strnNE(name, &quot;main&quot;, len)) {
            sv_catpvn_flags(sv,name,len,HvNAMEUTF8(hv)?SV_CATUTF8:SV_CATBYTES);
            sv_catpvs(sv,&quot;::&quot;);
        }
    }
    else sv_catpvs(sv,&quot;__ANON__::&quot;);
    sv_catsv(sv,sv_2mortal(newSVhek(GvNAME_HEK(gv))));
}</code></pre>

<p>void Perl_gv_efullname4(pTHX_ SV *sv, const GV *gv, const char *prefix, bool keepmain) { const GV * const egv = GvEGVx(gv);</p>

<pre><code>    PERL_ARGS_ASSERT_GV_EFULLNAME4;

    gv_fullname4(sv, egv ? egv : gv, prefix, keepmain);
}</code></pre>

<p>/* gv_magicalize;</p>

</dd>
<dt id="gv_try_downgrade">gv_try_downgrade </dt>
<dd>

<p>NOTE: this function is experimental and may change or be removed without notice.</p>

<p>If the typeglob <code>gv</code> can be expressed more succinctly, by having something other than a real GV in its place in the stash, replace it with the optimised form. Basic requirements for this are that <code>gv</code> is a real typeglob, is sufficiently ordinary, and is only referenced from its package. This function is meant to be used when a GV has been looked up in part to see what was there, causing upgrading, but based on what was found it turns out that the real GV isn&#39;t required after all.</p>

<p>If <code>gv</code> is a completely empty typeglob, it is deleted from the stash.</p>

<p>If <code>gv</code> is a typeglob containing only a sufficiently-ordinary constant sub, the typeglob is replaced with a scalar-reference placeholder that more compactly represents the same thing.</p>

<pre><code>        void    gv_try_downgrade(GV* gv)</code></pre>

</dd>
</dl>

<h1 id="Hash-Manipulation-Functions">Hash Manipulation Functions</h1>

<dl>

<dt id="hv_backreferences_p">hv_backreferences_p </dt>
<dd>

<p>NOTE: this function is experimental and may change or be removed without notice.</p>

<p>Returns the modifiable pointer to the field holding the AV* of backreferences. See also <a href="/cperl/perlapi.html#sv_get_backrefs">&quot;sv_get_backrefs&quot; in perlapi</a>.</p>

<pre><code>        AV**    hv_backreferences_p(HV *hv)</code></pre>

</dd>
<dt id="hv_ename_add">hv_ename_add </dt>
<dd>

<p>Adds a name to a stash&#39;s internal list of effective names. See <code><a href="#hv_ename_delete">&quot;hv_ename_delete&quot;</a></code>.</p>

<p>This is called when a stash is assigned to a new location in the symbol table.</p>

<pre><code>        void    hv_ename_add(HV *hv, const char *name, U32 len,
                             U32 flags)</code></pre>

</dd>
<dt id="hv_ename_delete">hv_ename_delete </dt>
<dd>

<p>Removes a name from a stash&#39;s internal list of effective names. If this is the name returned by <code>HvENAME</code>, then another name in the list will take its place (<code>HvENAME</code> will use it).</p>

<p>This is called when a stash is deleted from the symbol table.</p>

<pre><code>        void    hv_ename_delete(HV *hv, const char *name,
                                U32 len, U32 flags)</code></pre>

</dd>
<dt id="hv_kill_backrefs">hv_kill_backrefs </dt>
<dd>

<p>NOTE: this function is experimental and may change or be removed without notice.</p>

<p>Calls <a href="#sv_kill_backrefs">&quot;sv_kill_backrefs&quot;</a> on the hash backreferences, and frees it.</p>

<pre><code>        void    hv_kill_backrefs(HV *hv)</code></pre>

</dd>
<dt id="hv_placeholders_p">hv_placeholders_p </dt>
<dd>

<p>Returns the pointer to modifiable field to the count of hash placeholders, the deleted elements. Used as <code>HvPLACEHOLDERS(hv)++</code></p>

<pre><code>        SSize_t* hv_placeholders_p(HV *hv)</code></pre>

</dd>
<dt id="refcounted_he_chain_2hv">refcounted_he_chain_2hv </dt>
<dd>

<p>Generates and returns a <code>HV *</code> representing the content of a <code>refcounted_he</code> chain. <code>flags</code> is currently unused and must be zero.</p>

<pre><code>        HV *    refcounted_he_chain_2hv(
                    const struct refcounted_he *c, U32 flags
                )</code></pre>

</dd>
<dt id="refcounted_he_fetch_pv">refcounted_he_fetch_pv </dt>
<dd>

<p>Like <a href="#refcounted_he_fetch_pvn">&quot;refcounted_he_fetch_pvn&quot;</a>, but takes a nul-terminated string instead of a string/length pair.</p>

<pre><code>        SV *    refcounted_he_fetch_pv(
                    const struct refcounted_he *chain,
                    const char *key, U32 hash, U32 flags
                )</code></pre>

</dd>
<dt id="refcounted_he_fetch_pvn">refcounted_he_fetch_pvn </dt>
<dd>

<p>Search along a <code>refcounted_he</code> chain for an entry with the key specified by <code>keypv</code> and <code>keylen</code>. If <code>flags</code> has the <code>REFCOUNTED_HE_KEY_UTF8</code> bit set, the key octets are interpreted as UTF-8, otherwise they are interpreted as Latin-1. <code>hash</code> is a precomputed hash of the key string, or zero if it has not been precomputed. Returns a mortal scalar representing the value associated with the key, or <code>PLACEHOLDER</code> if there is no value associated with the key.</p>

<pre><code>        SV *    refcounted_he_fetch_pvn(
                    const struct refcounted_he *chain,
                    const char *keypv, STRLEN keylen, U32 hash,
                    U32 flags
                )</code></pre>

</dd>
<dt id="refcounted_he_fetch_pvs">refcounted_he_fetch_pvs </dt>
<dd>

<p>Like <a href="#refcounted_he_fetch_pvn">&quot;refcounted_he_fetch_pvn&quot;</a>, but takes a <code>NUL</code>-terminated literal string instead of a string/length pair, and no precomputed hash.</p>

<pre><code>        SV *    refcounted_he_fetch_pvs(
                    const struct refcounted_he *chain,
                    const char *key, U32 flags
                )</code></pre>

</dd>
<dt id="refcounted_he_fetch_sv">refcounted_he_fetch_sv </dt>
<dd>

<p>Like <a href="#refcounted_he_fetch_pvn">&quot;refcounted_he_fetch_pvn&quot;</a>, but takes a Perl scalar instead of a string/length pair.</p>

<pre><code>        SV *    refcounted_he_fetch_sv(
                    const struct refcounted_he *chain, SV *key,
                    U32 hash, U32 flags
                )</code></pre>

</dd>
<dt id="refcounted_he_free">refcounted_he_free </dt>
<dd>

<p>Decrements the reference count of a <code>refcounted_he</code> by one. If the reference count reaches zero the structure&#39;s memory is freed, which (recursively) causes a reduction of its parent <code>refcounted_he</code>&#39;s reference count. It is safe to pass a null pointer to this function: no action occurs in this case.</p>

<pre><code>        void    refcounted_he_free(struct refcounted_he *he)</code></pre>

</dd>
<dt id="refcounted_he_inc">refcounted_he_inc </dt>
<dd>

<p>Increment the reference count of a <code>refcounted_he</code>. The pointer to the <code>refcounted_he</code> is also returned. It is safe to pass a null pointer to this function: no action occurs and a null pointer is returned.</p>

<pre><code>        struct refcounted_he * refcounted_he_inc(
                                   struct refcounted_he *he
                               )</code></pre>

</dd>
<dt id="refcounted_he_new_pv">refcounted_he_new_pv </dt>
<dd>

<p>Like <a href="#refcounted_he_new_pvn">&quot;refcounted_he_new_pvn&quot;</a>, but takes a nul-terminated string instead of a string/length pair.</p>

<pre><code>        struct refcounted_he * refcounted_he_new_pv(
                                   struct refcounted_he *parent,
                                   const char *key, U32 hash,
                                   SV *value, U32 flags
                               )</code></pre>

</dd>
<dt id="refcounted_he_new_pvn">refcounted_he_new_pvn </dt>
<dd>

<p>Creates a new <code>refcounted_he</code>. This consists of a single key/value pair and a reference to an existing <code>refcounted_he</code> chain (which may be empty), and thus forms a longer chain. When using the longer chain, the new key/value pair takes precedence over any entry for the same key further along the chain.</p>

<p>The new key is specified by <code>keypv</code> and <code>keylen</code>. If <code>flags</code> has the <code>REFCOUNTED_HE_KEY_UTF8</code> bit set, the key octets are interpreted as UTF-8, otherwise they are interpreted as Latin-1. <code>hash</code> is a precomputed hash of the key string, or zero if it has not been precomputed.</p>

<p><code>value</code> is the scalar value to store for this key. <code>value</code> is copied by this function, which thus does not take ownership of any reference to it, and later changes to the scalar will not be reflected in the value visible in the <code>refcounted_he</code>. Complex types of scalar will not be stored with referential integrity, but will be coerced to strings. <code>value</code> may be either null or <code>PLACEHOLDER</code> to indicate that no value is to be associated with the key; this, as with any non-null value, takes precedence over the existence of a value for the key further along the chain.</p>

<p><code>parent</code> points to the rest of the <code>refcounted_he</code> chain to be attached to the new <code>refcounted_he</code>. This function takes ownership of one reference to <code>parent</code>, and returns one reference to the new <code>refcounted_he</code>.</p>

<pre><code>        struct refcounted_he * refcounted_he_new_pvn(
                                   struct refcounted_he *parent,
                                   const char *keypv,
                                   STRLEN keylen, U32 hash,
                                   SV *value, U32 flags
                               )</code></pre>

</dd>
<dt id="refcounted_he_new_pvs">refcounted_he_new_pvs </dt>
<dd>

<p>Like <a href="#refcounted_he_new_pvn">&quot;refcounted_he_new_pvn&quot;</a>, but takes a <code>NUL</code>-terminated literal string instead of a string/length pair, and no precomputed hash.</p>

<pre><code>        struct refcounted_he * refcounted_he_new_pvs(
                                   struct refcounted_he *parent,
                                   const char *key, SV *value,
                                   U32 flags
                               )</code></pre>

</dd>
<dt id="refcounted_he_new_sv">refcounted_he_new_sv </dt>
<dd>

<p>Like <a href="#refcounted_he_new_pvn">&quot;refcounted_he_new_pvn&quot;</a>, but takes a Perl scalar instead of a string/length pair.</p>

<pre><code>        struct refcounted_he * refcounted_he_new_sv(
                                   struct refcounted_he *parent,
                                   SV *key, U32 hash, SV *value,
                                   U32 flags
                               )</code></pre>

</dd>
</dl>

<h1 id="Hook-manipulation">Hook manipulation</h1>

<dl>

<dt id="const_av_xsub">const_av_xsub </dt>
<dd>

<p>Efficient sub that returns a constant array value.</p>

<pre><code>        void    const_av_xsub(CV* cv)</code></pre>

</dd>
<dt id="const_sv_xsub">const_sv_xsub </dt>
<dd>

<p>Efficient sub that returns a constant scalar value.</p>

<pre><code>        void    const_sv_xsub(CV* cv)</code></pre>

</dd>
</dl>

<h1 id="IO-Functions">IO Functions</h1>

<dl>

<dt id="start_glob">start_glob </dt>
<dd>

<p>NOTE: this function is experimental and may change or be removed without notice.</p>

<p>Function called by <code>do_readline</code> to spawn a glob (or do the glob inside perl on VMS). This code used to be inline, but now perl uses <code>File::Glob</code> this glob starter is only used by miniperl during the build process, or when PERL_EXTERNAL_GLOB is defined. Moving it away shrinks <i>pp_hot.c</i>; shrinking <i>pp_hot.c</i> helps speed perl up.</p>

<pre><code>        PerlIO* start_glob(SV *tmpglob, IO *io)</code></pre>

</dd>
</dl>

<h1 id="Lexer-interface">Lexer interface</h1>

<dl>

<dt id="find_in_coretypes">find_in_coretypes </dt>
<dd>

<p>NOTE: this function is experimental and may change or be removed without notice.</p>

<p>Check for and autocreate coretypes. Some of them inherited, setting the ISA. Returns NULL if the name is not a coretype. NOTE: the perl_ form of this function is deprecated.</p>

<pre><code>        HV *    find_in_coretypes(const char *pkgname,
                                  STRLEN len)</code></pre>

</dd>
<dt id="parse_subsignature">parse_subsignature </dt>
<dd>

<p>Parse a sequence of zero or more Perl signature arguments, everything between the <code>()</code> parentheses, seperated by &#39;,&#39;, with optional &#39;=&#39; or &#39;?&#39; default values and ending slurpy params (&#39;@&#39; or &#39;%&#39;).</p>

<pre><code>    sub f ($a, $b = 1) {...}</code></pre>

<p>Return an OP_LINESEQ op, which has as its children, an OP_SIGNATURE, plus 0 or more (sassign, nextstate) pairs for each default arg expression that can&#39;t be optimised into the OP_SIGNATURE. Returns NULL on error.</p>

<p>It gives the OP_SIGNATURE op an op_aux array, which contains collections of actions and args; the args being things like what pad ranges to introduce, and simple default args such as an integer constant, an SV constant, or a simple lex or package var.</p>

<p>Note that we attach this data to CV via an OP_SIGNATURE rather than directly attaching it to the CV, so that it doesn&#39;t need copying each time a new thread is cloned.</p>

<p>Done: - perl6-like optional args: ($opt?) i.e. ($opt=undef) - types in leading position (int $i) - attributes (:const, types), ($i :int :const) - no double copies into @_ - scalar references compiled to direct access, not just copies (\$a) =&gt; my $a = $_[0]. Todo: - error in ck_subr when @_/$_[] in signatured bodies is used</p>

<p>NOTE: the perl_ form of this function is deprecated.</p>

<pre><code>        OP *    parse_subsignature()</code></pre>

</dd>
<dt id="validate_proto">validate_proto </dt>
<dd>

<p>NOTE: this function is experimental and may change or be removed without notice.</p>

<p>This function performs syntax checking on a prototype, <code>proto</code>. If <code>warn</code> is true, any illegal characters or mismatched brackets will trigger illegalproto warnings, declaring that they were detected in the prototype for <code>name</code>.</p>

<p>The return value is <code>true</code> if this is a valid prototype, and <code>false</code> if it is not, regardless of whether <code>warn</code> was <code>true</code> or <code>false</code>.</p>

<p>Note that <code>NULL</code> is a valid <code>proto</code> and will always return <code>true</code>.</p>

<p>NOTE: the perl_ form of this function is deprecated.</p>

<pre><code>        bool    validate_proto(SV *name, SV *proto, bool warn)</code></pre>

</dd>
</dl>

<h1 id="Magical-Functions">Magical Functions</h1>

<dl>

<dt id="magic_clearhint">magic_clearhint </dt>
<dd>

<p>Triggered by a delete from <code>%^H</code>, records the key to <code>PL_compiling.cop_hints_hash</code>.</p>

<pre><code>        int     magic_clearhint(SV* sv, MAGIC* mg)</code></pre>

</dd>
<dt id="magic_clearhints">magic_clearhints </dt>
<dd>

<p>Triggered by clearing <code>%^H</code>, resets <code>PL_compiling.cop_hints_hash</code>.</p>

<pre><code>        int     magic_clearhints(SV* sv, MAGIC* mg)</code></pre>

</dd>
<dt id="magic_methcall">magic_methcall </dt>
<dd>

<p>Invoke a magic method (like FETCH).</p>

<p><code>sv</code> and <code>mg</code> are the tied thingy and the tie magic.</p>

<p><code>meth</code> is the name of the method to call.</p>

<p><code>argc</code> is the number of args (in addition to $self) to pass to the method.</p>

<p>The <code>flags</code> can be:</p>

<pre><code>    G_DISCARD     invoke method with G_DISCARD flag and don&#39;t
                  return a value
    G_UNDEF_FILL  fill the stack with argc pointers to
                  PL_sv_undef</code></pre>

<p>The arguments themselves are any values following the <code>flags</code> argument.</p>

<p>Returns the SV (if any) returned by the method, or <code>NULL</code> on failure.</p>

<pre><code>        SV*     magic_methcall(SV *sv, const MAGIC *mg,
                               SV *meth, U32 flags, U32 argc,
                               ...)</code></pre>

</dd>
<dt id="magic_sethint">magic_sethint </dt>
<dd>

<p>Triggered by a store to <code>%^H</code>, records the key/value pair to <code>PL_compiling.cop_hints_hash</code>. It is assumed that hints aren&#39;t storing anything that would need a deep copy. Maybe we should warn if we find a reference.</p>

<pre><code>        int     magic_sethint(SV* sv, MAGIC* mg)</code></pre>

</dd>
<dt id="mg_localize">mg_localize </dt>
<dd>

<p>Copy some of the magic from an existing SV to new localized version of that SV. Container magic (<i>e.g.</i>, <code>%ENV</code>, <code>$1</code>, <code>tie</code>) gets copied, value magic doesn&#39;t (<i>e.g.</i>, <code>taint</code>, <code>pos</code>).</p>

<p>If <code>setmagic</code> is false then no set magic will be called on the new (empty) SV. This typically means that assignment will soon follow (e.g. <span style="white-space: nowrap;"><code>&#39;local $x = $y&#39;</code></span>), and that will handle the magic.</p>

<pre><code>        void    mg_localize(SV* sv, SV* nsv, bool setmagic)</code></pre>

</dd>
</dl>

<h1 id="Miscellaneous-Functions">Miscellaneous Functions</h1>

<dl>

<dt id="closest_cop">closest_cop </dt>
<dd>

<p>Look for curop starting from o. cop is the last COP we&#39;ve seen. opnext means that curop is actually the -&gt;op_next of the op we are seeking.</p>

<p>NOTE: the perl_ form of this function is deprecated.</p>

<pre><code>        const COP* closest_cop(const COP *cop, const OP *o,
                               const OP *curop, bool opnext)</code></pre>

</dd>
<dt id="free_c_backtrace">free_c_backtrace </dt>
<dd>

<p>Deallocates a backtrace received from get_c_bracktrace.</p>

<pre><code>        void    free_c_backtrace(Perl_c_backtrace* bt)</code></pre>

</dd>
<dt id="get_c_backtrace">get_c_backtrace </dt>
<dd>

<p>Collects the backtrace (aka &quot;stacktrace&quot;) into a single linear malloced buffer, which the caller <b>must</b> <code>Perl_free_c_backtrace()</code>.</p>

<p>Scans the frames back by <span style="white-space: nowrap;"><code>depth + skip</code></span>, then drops the <code>skip</code> innermost, returning at most <code>depth</code> frames.</p>

<pre><code>        Perl_c_backtrace* get_c_backtrace(int max_depth,
                                          int skip)</code></pre>

</dd>
<dt id="get_db_sub">get_db_sub </dt>
<dd>

<p>Stores the called <code>cv</code> in $DB::sub, either as name or as CV ptr (with NONAME, an anon sub).</p>

<p><code>sv</code> contains the entersub argument from the stack, which is either a CVREF or a GV, or NULL if called via goto. It is not really needed.</p>

<p>In the debugger entersub does not call the function, but &amp;DB::sub which then calls the cv.</p>

<pre><code>        void    get_db_sub(SV *sv, CV *cv)</code></pre>

</dd>
</dl>

<h1 id="MRO-Functions">MRO Functions</h1>

<dl>

<dt id="mro_get_linear_isa_dfs">mro_get_linear_isa_dfs </dt>
<dd>

<p>Returns the Depth-First Search linearization of <code>@ISA</code> the given stash. The return value is a read-only AV*. <code>level</code> should be 0 (it is used internally in this function&#39;s recursion).</p>

<p>You are responsible for <code>SvREFCNT_inc()</code> on the return value if you plan to store it anywhere semi-permanently (otherwise it might be deleted out from under you the next time the cache is invalidated).</p>

<pre><code>        AV*     mro_get_linear_isa_dfs(HV* stash, U32 level)</code></pre>

</dd>
<dt id="mro_package_moved">mro_package_moved </dt>
<dd>

<p>Call this function to signal to a stash that it has been assigned to another spot in the stash hierarchy. <code>stash</code> is the stash that has been assigned. <code>oldstash</code> is the stash it replaces, if any. <code>gv</code> is the glob that is actually being assigned to.</p>

<p>This can also be called with a null first argument to indicate that <code>oldstash</code> has been deleted.</p>

<p>This function invalidates isa caches on the old stash, on all subpackages nested inside it, and on the subclasses of all those, including non-existent packages that have corresponding entries in <code>stash</code>.</p>

<p>It also sets the effective names (<code>HvENAME</code>) on all the stashes as appropriate.</p>

<p>If the <code>gv</code> is present and is not in the symbol table, then this function simply returns. This checked will be skipped if <code>flags &amp; 1</code>.</p>

<pre><code>        void    mro_package_moved(HV * const stash,
                                  HV * const oldstash,
                                  const GV * const gv,
                                  U32 flags)</code></pre>

</dd>
</dl>

<h1 id="Optree-construction">Optree construction</h1>

<dl>

<dt id="force_list">force_list </dt>
<dd>

<p>promote o and any siblings to be a list if its not already; i.e.</p>

<pre><code> o - A - B</code></pre>

<p>becomes</p>

<pre><code> list
   |
 pushmark - o - A - B</code></pre>

<p>If nullit it true, the list op is nulled. OP* force_list(OP* arg, bool nullit)</p>

</dd>
</dl>

<h1 id="Optree-Manipulation-Functions">Optree Manipulation Functions</h1>

<dl>

<dt id="alloc_LOGOP">alloc_LOGOP </dt>
<dd>

<p>NOTE: this function is experimental and may change or be removed without notice.</p>

<p>lowest-level newLOGOP-style function - just allocates and populates the struct. Higher-level stuff should be done by S_new_logop() / newLOGOP(). This function exists mainly to avoid op_first assignment being spread throughout this file.</p>

<p>NOTE: the perl_ form of this function is deprecated.</p>

<pre><code>        LOGOP*  alloc_LOGOP(I32 type, OP *first, OP *other)</code></pre>

</dd>
<dt id="apply_attrs">apply_attrs </dt>
<dd>

<p>Calls the attribute importer with the target and a list of attributes. As manually done via <code>use attributes $pkg, $rv, @attrs</code>.</p>

<pre><code>        void    apply_attrs(HV *stash, SV *target, OP *attrs)</code></pre>

</dd>
<dt id="apply_attrs_my">apply_attrs_my </dt>
<dd>

<p>Similar to <a href="#apply_attrs">&quot;apply_attrs&quot;</a> calls the attribute importer with the target, which must be a lexical and a list of attributes. As manually done via <code>use attributes $pkg, $rv, @attrs</code>.</p>

<p>Returns the list of attributes in the **imopsp argument.</p>

<pre><code>        void    apply_attrs_my(HV *stash, OP *target, OP *attrs,
                               OP **imopsp)</code></pre>

</dd>
<dt id="bind_match-OP-bind_match-I32-type-OP-left-OP-right">bind_match  OP* bind_match(I32 type, OP *left, OP *right)</dt>
<dd>

</dd>
<dt id="cant_declare-void-cant_declare-OP-o">cant_declare  void cant_declare(OP* o)</dt>
<dd>

</dd>
<dt id="check_hash_fields_and_hekify">check_hash_fields_and_hekify </dt>
<dd>

<p>for a helem/hslice/kvslice, if its a fixed hash, croak on invalid const fields. Also, convert CONST keys to HEK-in-SVs. rop is the op that retrieves the hash; key_op is the first key</p>

<pre><code>                check_hash_fields_and_hekify;</code></pre>

</dd>
<dt id="dup_attrlist">dup_attrlist </dt>
<dd>

<p>Return a copy of an attribute list, i.e. a CONST or LIST with a list of CONST values.</p>

<pre><code>        OP *    dup_attrlist(OP *o)</code></pre>

</dd>
<dt id="finalize_op">finalize_op </dt>
<dd>

<p>Calls several op-specific finalizers, warnings and fixups.</p>

<pre><code>        void    finalize_op(OP* o)</code></pre>

</dd>
<dt id="finalize_optree">finalize_optree </dt>
<dd>

<p>This function finalizes the optree. Should be called directly after the complete optree is built. It does some additional checking which can&#39;t be done in the normal <code>ck_</code>xxx functions and makes the tree thread-safe.</p>

<pre><code>        void    finalize_optree(OP* o)</code></pre>

</dd>
<dt id="invert">invert </dt>
<dd>

<p>Add a unary NOT op in front, inverting the op.</p>

<pre><code>        OP*     invert(OP* cmd)</code></pre>

</dd>
<dt id="list">list </dt>
<dd>

<p>Sets list context for the op.</p>

<pre><code>        OP*     list(OP* o)</code></pre>

</dd>
<dt id="listkids">listkids </dt>
<dd>

<p>Sets list context for all kids.</p>

<pre><code>        OP*     listkids(OP* o)</code></pre>

</dd>
<dt id="maybe_op_signature">maybe_op_signature </dt>
<dd>

<p>Does fake_signatures. If the sub starts with &#39;my (...) = @_&#39;, replace those ops with an OP_SIGNATURE.</p>

<p>Cannot handle shift as this leaves leftover args.</p>

<pre><code>                maybe_op_signature;</code></pre>

</dd>
<dt id="modkids">modkids </dt>
<dd>

<p>Sets lvalue context for all kids.</p>

<pre><code>        OP*     modkids(OP *o, I32 type)</code></pre>

</dd>
<dt id="move_proto_attr-void-move_proto_attr-OP-proto-OP-attrs-const-GV-name">move_proto_attr  void move_proto_attr(OP **proto, OP **attrs, const GV *name)</dt>
<dd>

</dd>
<dt id="my_attrs-OP-my_attrs-OP-o-OP-attrs">my_attrs  OP * my_attrs(OP *o, OP *attrs)</dt>
<dd>

</dd>
<dt id="my_kid-OP-my_kid-OP-o-OP-attrs-OP-imopsp">my_kid  OP * my_kid(OP *o, OP *attrs, OP **imopsp)</dt>
<dd>

</dd>
<dt id="op_clear">op_clear </dt>
<dd>

<p>free all the SVs (gv, pad, ...) attached to the op.</p>

<p>NOTE: the perl_ form of this function is deprecated.</p>

<pre><code>        void    op_clear(OP* o)</code></pre>

</dd>
<dt id="op_clear_gv">op_clear_gv </dt>
<dd>

<p>free a GV attached to an OP</p>

<pre><code>        void    op_clear_gv(OP* o, PADOFFSET *ixp)</code></pre>

</dd>
<dt id="op_relocate_sv">op_relocate_sv </dt>
<dd>

<p>Relocate sv to the pad for thread safety. Despite being a &quot;constant&quot;, the SV is written to, for reference counts, sv_upgrade() etc.</p>

<pre><code>        void    op_relocate_sv(SV** svp, PADOFFSET* targp)</code></pre>

</dd>
<dt id="op_sibling_newUNOP">op_sibling_newUNOP </dt>
<dd>

<p>replace the sibling following start with a new UNOP, which becomes the parent of the original sibling; e.g.</p>

<pre><code>   op_sibling_newUNOP(P, A, unop-args...)
  
   P              P
   |      becomes |
   A-B-C          A-U-C
                    |
                    B</code></pre>

<p>where U is the new UNOP.</p>

<p>parent and start args are the same as for op_sibling_splice(); type and flags args are as newUNOP().</p>

<p>Returns the new UNOP.</p>

<pre><code>                op_sibling_newUNOP;</code></pre>

</dd>
<dt id="op_unscope">op_unscope </dt>
<dd>

<p>NOTE: this function is experimental and may change or be removed without notice.</p>

<p>Nullify all state ops in the kids of a lineseq.</p>

<pre><code>        OP*     op_unscope(OP* o)</code></pre>

</dd>
<dt id="postprocess_optree">postprocess_optree </dt>
<dd>

<p>do the post-compilation processing of an op_tree with specified root and start (startp may be updated):</p>

<pre><code>  * attach it to cv (if non-null)
  * set refcnt
  * run peep, finalize etc
  * tidy pad

                postprocess_optree;</code></pre>

</dd>
<dt id="prefinalize_op">prefinalize_op </dt>
<dd>

<p>per op-level helper function for Perl_finalize_optree()</p>

<pre><code>        void    prefinalize_op(CV *cv, OP* o)</code></pre>

</dd>
<dt id="prefinalize_optree">prefinalize_optree </dt>
<dd>

<p>This function is like finalize_optree(), but is called prior to the peephole optimiser being called (finalize_optree() is called after peep()). Thus it gives you access to the optree before optimisations.</p>

<p>If non-null, cv is the CV which the optree is attached to.</p>

<pre><code>        void    prefinalize_optree(CV* cv, OP* o)</code></pre>

</dd>
<dt id="refkids">refkids </dt>
<dd>

<p>Sets ref context for all kids.</p>

<pre><code>        OP*     refkids(OP* o, I32 type)</code></pre>

</dd>
<dt id="sawparens-OP-sawparens-OP-o">sawparens  OP* sawparens(OP* o)</dt>
<dd>

</dd>
<dt id="scalarboolean">scalarboolean </dt>
<dd>

<p>Checks boolean context for the op, merely for syntax warnings.</p>

<p>Note: We cannot <a href="#set_boolean">&quot;set_boolean&quot;</a> context here, as some ops still require the non-boolified stackvalue. See <a href="#check_for_bool_cxt">&quot;check_for_bool_cxt&quot;</a>.</p>

<pre><code>                scalarboolean;</code></pre>

</dd>
<dt id="scalarkids">scalarkids </dt>
<dd>

<p>Sets scalar context for all kids.</p>

<pre><code>                scalarkids;</code></pre>

</dd>
<dt id="scalarseq">scalarseq </dt>
<dd>

<p>Sets scalar void context for scalar sequences: lineseq, scope, leave and leavetry.</p>

<pre><code>        OP*     scalarseq(OP* o)</code></pre>

</dd>
<dt id="scalarvoid">scalarvoid </dt>
<dd>

<p>Assigns scalar void context to the optree, i.e. it takes only a scalar argument, no list and returns nothing.</p>

<pre><code>        OP*     scalarvoid(OP* o)</code></pre>

</dd>
<dt id="set_boolean">set_boolean </dt>
<dd>

<p>Force the op to be in boolean context, similar to <a href="#scalar">&quot;scalar&quot;</a> and <a href="#scalarboolean">&quot;scalarboolean&quot;</a> This just abstracts away the various private TRUEBOOL flag values.</p>

<pre><code>        OP*     set_boolean(OP *o)</code></pre>

</dd>
</dl>

<h1 id="Pad-Data-Structures">Pad Data Structures</h1>

<dl>

<dt id="CX_CURPAD_SAVE">CX_CURPAD_SAVE </dt>
<dd>

<p>Save the current pad in the given context block_loop structure. With threads only.</p>

<pre><code>        void    CX_CURPAD_SAVE(struct context)</code></pre>

</dd>
<dt id="CX_CURPAD_SV">CX_CURPAD_SV </dt>
<dd>

<p>Access the SV at offset <code>po</code> in the saved current pad in the given context block_loop structure (can be used as an lvalue). With threads only.</p>

<pre><code>        SV *    CX_CURPAD_SV(struct context, PADOFFSET po)</code></pre>

</dd>
<dt id="PAD_BASE_SV">PAD_BASE_SV </dt>
<dd>

<p>Get the value from slot <code>po</code> in the base (DEPTH=1) pad of a padlist</p>

<pre><code>        SV *    PAD_BASE_SV(PADLIST padlist, PADOFFSET po)</code></pre>

</dd>
<dt id="PAD_CLONE_VARS">PAD_CLONE_VARS </dt>
<dd>

<p>Clone the state variables associated with running and compiling pads.</p>

<pre><code>        void    PAD_CLONE_VARS(PerlInterpreter *proto_perl,
                               CLONE_PARAMS* param)</code></pre>

</dd>
<dt id="PAD_COMPNAME_FLAGS">PAD_COMPNAME_FLAGS </dt>
<dd>

<p>Return the flags for the current compiling pad name at offset <code>po</code>. Assumes a valid slot entry.</p>

<pre><code>        U32     PAD_COMPNAME_FLAGS(PADOFFSET po)</code></pre>

</dd>
<dt id="PAD_COMPNAME_GEN">PAD_COMPNAME_GEN </dt>
<dd>

<p>The generation number of the name at offset <code>po</code> in the current compiling pad (lvalue).</p>

<pre><code>        STRLEN  PAD_COMPNAME_GEN(PADOFFSET po)</code></pre>

</dd>
<dt id="PAD_COMPNAME_GEN_set">PAD_COMPNAME_GEN_set </dt>
<dd>

<p>Sets the generation number of the name at offset <code>po</code> in the current ling pad (lvalue) to <code>gen</code>. STRLEN PAD_COMPNAME_GEN_set(PADOFFSET po, int gen)</p>

</dd>
<dt id="PAD_COMPNAME_OURSTASH">PAD_COMPNAME_OURSTASH </dt>
<dd>

<p>Return the stash associated with an <code>our</code> variable. Assumes the slot entry is a valid <code>our</code> lexical.</p>

<pre><code>        HV *    PAD_COMPNAME_OURSTASH(PADOFFSET po)</code></pre>

</dd>
<dt id="PAD_COMPNAME_PV">PAD_COMPNAME_PV </dt>
<dd>

<p>Return the name of the current compiling pad name at offset <code>po</code>. Assumes a valid slot entry.</p>

<pre><code>        char *  PAD_COMPNAME_PV(PADOFFSET po)</code></pre>

</dd>
<dt id="PAD_COMPNAME_TYPE">PAD_COMPNAME_TYPE </dt>
<dd>

<p>Return the type (stash) of the current compiling pad name at offset <code>po</code>. Must be a valid name. Returns null if not typed.</p>

<pre><code>        HV *    PAD_COMPNAME_TYPE(PADOFFSET po)</code></pre>

</dd>
<dt id="PadnameIsOUR">PadnameIsOUR </dt>
<dd>

<p>Whether this is an &quot;our&quot; variable.</p>

<pre><code>        bool    PadnameIsOUR(PADNAME pn)</code></pre>

</dd>
<dt id="PadnameIsSTATE">PadnameIsSTATE </dt>
<dd>

<p>Whether this is a &quot;state&quot; variable.</p>

<pre><code>        bool    PadnameIsSTATE(PADNAME pn)</code></pre>

</dd>
<dt id="PadnameOURSTASH">PadnameOURSTASH </dt>
<dd>

<p>The stash in which this &quot;our&quot; variable was declared.</p>

<pre><code>        HV *    PadnameOURSTASH()</code></pre>

</dd>
<dt id="PadnameOUTER">PadnameOUTER </dt>
<dd>

<p>Whether this entry belongs to an outer pad. Entries for which this is true are often referred to as &#39;fake&#39;.</p>

<pre><code>        bool    PadnameOUTER(PADNAME pn)</code></pre>

</dd>
<dt id="PadnameTYPE">PadnameTYPE </dt>
<dd>

<p>The stash associated with a typed lexical. This returns the <code>%Foo::</code> hash for <code>my Foo $bar</code>.</p>

<pre><code>        HV *    PadnameTYPE(PADNAME pn)</code></pre>

</dd>
<dt id="PAD_RESTORE_LOCAL">PAD_RESTORE_LOCAL </dt>
<dd>

<p>Restore the old pad saved into the local variable <code>opad</code> by <code>PAD_SAVE_LOCAL()</code></p>

<pre><code>        void    PAD_RESTORE_LOCAL(PAD *opad)</code></pre>

</dd>
<dt id="PAD_SAVE_LOCAL">PAD_SAVE_LOCAL </dt>
<dd>

<p>Save the current pad to the local variable <code>opad</code>, then make the current pad equal to <code>npad</code></p>

<pre><code>        void    PAD_SAVE_LOCAL(PAD *opad, PAD *npad)</code></pre>

</dd>
<dt id="PAD_SAVE_SETNULLPAD">PAD_SAVE_SETNULLPAD </dt>
<dd>

<p>Save the current pad then set it to null.</p>

<pre><code>        void    PAD_SAVE_SETNULLPAD()</code></pre>

</dd>
<dt id="PAD_SETSV">PAD_SETSV </dt>
<dd>

<p>Set the slot at offset <code>po</code> in the current pad to <code>sv</code></p>

<pre><code>        SV *    PAD_SETSV(PADOFFSET po, SV* sv)</code></pre>

</dd>
<dt id="PAD_SET_CUR">PAD_SET_CUR </dt>
<dd>

<p>Set the current pad to be pad <code>n</code> in the padlist, saving the previous current pad. NB currently this macro expands to a string too long for some compilers, so it&#39;s best to replace it with</p>

<pre><code>    SAVECOMPPAD();
    PAD_SET_CUR_NOSAVE(padlist,n);


        void    PAD_SET_CUR(PADLIST padlist, I32 n)</code></pre>

</dd>
<dt id="PAD_SET_CUR_NOSAVE">PAD_SET_CUR_NOSAVE </dt>
<dd>

<p>like PAD_SET_CUR, but without the save</p>

<pre><code>        void    PAD_SET_CUR_NOSAVE(PADLIST padlist, I32 n)</code></pre>

</dd>
<dt id="PAD_SV">PAD_SV </dt>
<dd>

<p>Get the value at offset <code>po</code> in the current pad</p>

<pre><code>        SV *    PAD_SV(PADOFFSET po)</code></pre>

</dd>
<dt id="PAD_SVl">PAD_SVl </dt>
<dd>

<p>Lightweight and lvalue version of <code>PAD_SV</code>. Get or set the value at offset <code>po</code> in the current pad. Unlike <code>PAD_SV</code>, does not print diagnostics with -DX. For internal use only.</p>

<pre><code>        SV *    PAD_SVl(PADOFFSET po)</code></pre>

</dd>
<dt id="SAVECLEARSV">SAVECLEARSV </dt>
<dd>

<p>Clear the pointed to pad value on scope exit. (i.e. the runtime action of <code>my</code>)</p>

<pre><code>        void    SAVECLEARSV(SV **svp)</code></pre>

</dd>
<dt id="SAVECOMPPAD">SAVECOMPPAD </dt>
<dd>

<p>save <code>PL_comppad</code> and <code>PL_curpad</code></p>

<pre><code>        void    SAVECOMPPAD()</code></pre>

</dd>
<dt id="SAVEPADSV">SAVEPADSV </dt>
<dd>

<p>Save a pad slot (used to restore after an iteration)</p>

<p>XXX DAPM it would make more sense to make the arg a PADOFFSET void SAVEPADSV(PADOFFSET po)</p>

</dd>
</dl>

<h1 id="Per-Interpreter-Variables">Per-Interpreter Variables</h1>

<dl>

<dt id="PL_DBsingle">PL_DBsingle </dt>
<dd>

<p>When Perl is run in debugging mode, with the <b>-d</b> switch, this SV is a boolean which indicates whether subs are being single-stepped. Single-stepping is automatically turned on after every step. This is the C variable which corresponds to Perl&#39;s $DB::single variable. See <code><a href="#PL_DBsub">&quot;PL_DBsub&quot;</a></code>.</p>

<pre><code>        SV *    PL_DBsingle</code></pre>

</dd>
<dt id="PL_DBsub">PL_DBsub </dt>
<dd>

<p>When Perl is run in debugging mode, with the <b>-d</b> switch, this GV contains the SV which holds the name of the sub being debugged. This is the C variable which corresponds to Perl&#39;s $DB::sub variable. See <code><a href="#PL_DBsingle">&quot;PL_DBsingle&quot;</a></code>.</p>

<pre><code>        GV *    PL_DBsub</code></pre>

</dd>
<dt id="PL_DBtrace">PL_DBtrace </dt>
<dd>

<p>Trace variable used when Perl is run in debugging mode, with the <b>-d</b> switch. This is the C variable which corresponds to Perl&#39;s $DB::trace variable. See <code><a href="#PL_DBsingle">&quot;PL_DBsingle&quot;</a></code>.</p>

<pre><code>        SV *    PL_DBtrace</code></pre>

</dd>
<dt id="PL_dowarn">PL_dowarn </dt>
<dd>

<p>The C variable that roughly corresponds to Perl&#39;s <code>$^W</code> warning variable. However, <code>$^W</code> is treated as a boolean, whereas <code>PL_dowarn</code> is a collection of flag bits.</p>

<pre><code>        U8      PL_dowarn</code></pre>

</dd>
<dt id="PL_last_in_gv">PL_last_in_gv </dt>
<dd>

<p>The GV which was last used for a filehandle input operation. (<code>&lt;FH&gt;</code>)</p>

<pre><code>        GV*     PL_last_in_gv</code></pre>

</dd>
<dt id="PL_ofsgv">PL_ofsgv </dt>
<dd>

<p>The glob containing the output field separator - <code>*,</code> in Perl space.</p>

<pre><code>        GV*     PL_ofsgv</code></pre>

</dd>
<dt id="PL_rs">PL_rs </dt>
<dd>

<p>The input record separator - <code>$/</code> in Perl space.</p>

<pre><code>        SV*     PL_rs</code></pre>

</dd>
</dl>

<h1 id="Stack-Manipulation-Macros">Stack Manipulation Macros</h1>

<dl>

<dt id="djSP">djSP </dt>
<dd>

<p>Declare Just <code>SP</code>. This is actually identical to <code>dSP</code>, and declares a local copy of perl&#39;s stack pointer, available via the <code>SP</code> macro. See <code><a href="/cperl/perlapi.html#SP">&quot;SP&quot; in perlapi</a></code>. (Available for backward source code compatibility with the old (Perl 5.005) thread model.)</p>

<pre><code>                djSP;</code></pre>

</dd>
<dt id="LVRET">LVRET </dt>
<dd>

<p>True if this op will be the return value of an lvalue subroutine</p>

</dd>
</dl>

<h1 id="SV-Body-Allocation">SV-Body Allocation</h1>

<dl>

<dt id="anonymise_cv_maybe">anonymise_cv_maybe </dt>
<dd>

<p>We&#39;re about to free a GV which has a CV that refers back to us. If that CV will outlive us, make it anonymous (i.e. fix up its CvGV field)</p>

<pre><code>        void    anonymise_cv_maybe(GV *gv, CV *cv)</code></pre>

</dd>
<dt id="sv_2num">sv_2num </dt>
<dd>

<p>NOTE: this function is experimental and may change or be removed without notice.</p>

<p>Return an SV with the numeric value of the source SV, doing any necessary reference or overload conversion. The caller is expected to have handled get-magic already.</p>

<pre><code>        SV*     sv_2num(SV *const sv)</code></pre>

</dd>
<dt id="sv_add_backref">sv_add_backref </dt>
<dd>

<p>Give tsv backref magic if it hasn&#39;t already got it, then push a back-reference to sv onto the array associated with the backref magic.</p>

<p>As an optimisation, if there&#39;s only one backref and it&#39;s not an AV, store it directly in the HvAUX or mg_obj slot, avoiding the need to allocate an AV. (Whether the slot holds an AV tells us whether this is active.)</p>

<p>A discussion about the backreferences array and its refcount:</p>

<p>The AV holding the backreferences is pointed to either as the <code>mg_obj</code> of <code>PERL_MAGIC_backref</code>, or in the specific case of a HV, from the <code>xhv_backreferences</code> field. The array is created with a refcount of 2. This means that if during global destruction the array gets picked on before its parent to have its refcount decremented by the random zapper, it won&#39;t actually be freed, meaning it&#39;s still there for when its parent gets freed.</p>

<p>When the parent SV is freed, the extra ref is killed by <a href="/cperl/perlintern.html#sv_kill_backrefs">&quot;sv_kill_backrefs&quot; in perlintern</a>. The other ref is killed, in the case of magic, by <a href="/pod/perlapi.html#mg_free">&quot;mg_free&quot; in perlapi</a> / <code>MGf_REFCOUNTED</code>, or for a hash, by <a href="/pod/perlintern.html#hv_kill_backrefs">&quot;hv_kill_backrefs&quot; in perlintern</a>.</p>

<p>When a single backref SV is stored directly, it is not reference counted.</p>

<pre><code>        void    sv_add_backref(SV *const tsv, SV *const sv)</code></pre>

</dd>
<dt id="sv_del_backref">sv_del_backref </dt>
<dd>

<p>Delete a back-reference to ourselves from the backref magic associated with the SV we point to.</p>

<pre><code>        void    sv_del_backref(SV *const tsv, SV *const sv)</code></pre>

</dd>
<dt id="sv_free2">sv_free2 </dt>
<dd>

<p>NOTE: this function is experimental and may change or be removed without notice.</p>

<p>Private helper function for SvREFCNT_dec(). Called with rc set to original SvREFCNT(sv), where rc == 0 or 1</p>

<pre><code>        void    sv_free2(SV *const sv, const U32 refcnt)</code></pre>

</dd>
<dt id="sv_kill_backrefs">sv_kill_backrefs </dt>
<dd>

<p>NOTE: this function is experimental and may change or be removed without notice.</p>

<p>Delete all back-references to ourselves from the backreferences array.</p>

<pre><code>        void    sv_kill_backrefs(SV *const sv, AV *const av)</code></pre>

</dd>
<dt id="sv_len_utf8_nomg">sv_len_utf8_nomg </dt>
<dd>

<p>Returns the number of characters in the string in an SV, counting wide UTF-8 bytes as a single character. Ignores get magic.</p>

<pre><code>        STRLEN  sv_len_utf8_nomg(SV *const sv)</code></pre>

</dd>
</dl>

<h1 id="SV-Manipulation-Functions">SV Manipulation Functions</h1>

<p>An SV (or AV, HV, etc.) is allocated in two parts: the head (struct sv, av, hv...) contains type and reference count information, and for many types, a pointer to the body (struct xrv, xpv, xpviv...), which contains fields specific to each type. Some types store all they need in the head, so don&#39;t have a body.</p>

<p>In all but the most memory-paranoid configurations (ex: PURIFY), heads and bodies are allocated out of arenas, which by default are approximately 4K chunks of memory parcelled up into N heads or bodies. Sv-bodies are allocated by their sv-type, guaranteeing size consistency needed to allocate safely from arrays.</p>

<p>For SV-heads, the first slot in each arena is reserved, and holds a link to the next arena, some flags, and a note of the number of slots. Snaked through each arena chain is a linked list of free items; when this becomes empty, an extra arena is allocated and divided up into N items which are threaded into the free list.</p>

<p>SV-bodies are similar, but they use arena-sets by default, which separate the link and info from the arena itself, and reclaim the 1st slot in the arena. SV-bodies are further described later.</p>

<p>The following global variables are associated with arenas:</p>

<pre><code> PL_sv_arenaroot     pointer to list of SV arenas
 PL_sv_root          pointer to list of free SV structures

 PL_body_arenas      head of linked-list of body arenas
 PL_body_roots[]     array of pointers to list of free bodies of svtype
                     arrays are indexed by the svtype needed</code></pre>

<p>A few special SV heads are not allocated from an arena, but are instead directly created in the interpreter structure, eg PL_sv_undef. The size of arenas can be changed from the default by setting PERL_ARENA_SIZE appropriately at compile time.</p>

<p>The SV arena serves the secondary purpose of allowing still-live SVs to be located and destroyed during final cleanup.</p>

<p>At the lowest level, the macros new_SV() and del_SV() grab and free an SV head. (If debugging with -DD, del_SV() calls the function S_del_sv() to return the SV to the free list with error checking.) new_SV() calls more_sv() / sv_add_arena() to add an extra arena if the free list is empty. SVs in the free list have their SvTYPE field set to all ones.</p>

<p>At the time of very final cleanup, sv_free_arenas() is called from perl_destruct() to physically free all the arenas allocated since the start of the interpreter.</p>

<p>The function visit() scans the SV arenas list, and calls a specified function for each SV it finds which is still live - ie which has an SvTYPE other than all 1&#39;s, and a non-zero SvREFCNT. visit() is used by the following functions (specified as [function that calls visit()] / [function called by visit() for each SV]):</p>

<pre><code>    sv_report_used() / do_report_used()
                        dump all remaining SVs (debugging aid)

    sv_clean_objs() / do_clean_objs(),do_clean_named_objs(),
                      do_clean_named_io_objs(),do_curse()
                        Attempt to free all objects pointed to by RVs,
                        try to do the same for all objects indir-
                        ectly referenced by typeglobs too, and
                        then do a final sweep, cursing any
                        objects that remain.  Called once from
                        perl_destruct(), prior to calling sv_clean_all()
                        below.

    sv_clean_all() / do_clean_all()
                        SvREFCNT_dec(sv) each remaining SV, possibly
                        triggering an sv_free(). It also sets the
                        SVf_BREAK flag on the SV to indicate that the
                        refcnt has been artificially lowered, and thus
                        stopping sv_free() from giving spurious warnings
                        about SVs which unexpectedly have a refcnt
                        of zero.  called repeatedly from perl_destruct()
                        until there are no SVs left.</code></pre>

<dl>

<dt id="sv_add_arena">sv_add_arena </dt>
<dd>

<p>Given a chunk of memory, link it to the head of the list of arenas, and split it into a list of free SVs.</p>

<pre><code>        void    sv_add_arena(char *const ptr, const U32 size,
                             const U32 flags)</code></pre>

</dd>
<dt id="sv_clean_all">sv_clean_all </dt>
<dd>

<p>Decrement the refcnt of each remaining SV, possibly triggering a cleanup. This function may have to be called multiple times to free SVs which are in complex self-referential hierarchies.</p>

<pre><code>        Size_t  sv_clean_all()</code></pre>

</dd>
<dt id="sv_free_arenas">sv_free_arenas </dt>
<dd>

<p>Deallocate the memory used by all arenas. Note that all the individual SV heads and bodies within the arenas must already have been freed.</p>

<pre><code>        void    sv_free_arenas()</code></pre>

</dd>
<dt id="SvTHINKFIRST">SvTHINKFIRST </dt>
<dd>

<p>A quick flag check to see whether an <code>sv</code> should be passed to <code>sv_force_normal</code> to be &quot;downgraded&quot; before <code>SvIVX</code> or <code>SvPVX</code> can be modified directly.</p>

<p>For example, if your scalar is a reference and you want to modify the <code>SvIVX</code> slot, you can&#39;t just do <code>SvROK_off</code>, as that will leak the referent.</p>

<p>This is used internally by various sv-modifying functions, such as <code>sv_setsv</code>, <code>sv_setiv</code> and <code>sv_pvn_force</code>.</p>

<p>One case that this does not handle is a gv without SvFAKE set. After</p>

<pre><code>    if (SvTHINKFIRST(gv)) sv_force_normal(gv);</code></pre>

<p>it will still be a gv.</p>

<p><code>SvTHINKFIRST</code> sometimes produces false positives. In those cases <code>sv_force_normal</code> does nothing.</p>

<pre><code>        U32     SvTHINKFIRST(SV *sv)</code></pre>

</dd>
</dl>

<h1 id="Unicode-Support">Unicode Support</h1>

<dl>

<dt id="find_uninit_var">find_uninit_var </dt>
<dd>

<p>NOTE: this function is experimental and may change or be removed without notice.</p>

<p>Find the name of the undefined variable (if any) that caused the operator to issue a &quot;Use of uninitialized value&quot; warning. If match is true, only return a name if its value matches <code>uninit_sv</code>. So roughly speaking, if a unary operator (such as <code>OP_COS</code>) generates a warning, then following the direct child of the op may yield an <code>OP_PADSV</code> or <code>OP_GV</code> that gives the name of the undefined variable. On the other hand, with <code>OP_ADD</code> there are two branches to follow, so we only print the variable name if we get an exact match. <code>desc_p</code> points to a string pointer holding the description of the op. This may be updated if needed.</p>

<p>The name is returned as a mortal SV.</p>

<p>Assumes that <code>PL_op</code> is the OP that originally triggered the error, and that <code>PL_comppad</code>/<code>PL_curpad</code> points to the currently executing pad.</p>

<pre><code>        SV*     find_uninit_var(const OP *const obase,
                                const SV *const uninit_sv,
                                bool match, const char **desc_p)</code></pre>

</dd>
<dt id="report_uninit">report_uninit </dt>
<dd>

<p>Print appropriate &quot;Use of uninitialized variable&quot; warning.</p>

<pre><code>        void    report_uninit(const SV *uninit_sv)</code></pre>

</dd>
<dt id="utf8_check_script">utf8_check_script </dt>
<dd>

<p>NOTE: this function is experimental and may change or be removed without notice.</p>

<p>Check if the script property of the unicode character was declared via <code>use utf8 &#39;Script&#39;</code>. If this character is the first of a not excluded valid script, add the script to the list of allowed scripts, otherwise error.</p>

<p>Note that the argument is guaranteed to be not of the Common or Latin script property.</p>

<pre><code>        void    utf8_check_script(const U8 *s)</code></pre>

</dd>
<dt id="utf8_error_script">utf8_error_script </dt>
<dd>

<p>If this character is the first non-Latin or non-Common character, and no other scripts were declared, and the script is not member of %utf8::EXCLUDED_SCRIPTS, then add the script to the list of allowed scripts, otherwise error.</p>

<p>%utf8::EXCLUDED_SCRIPTS map the Moderately Restrictive Level for identifiers. i.e. Allow Recommended or Aspirational scripts except Cyrillic and Greek.</p>

<p>Also allow Latin + :Japanese, Latin + :Hanb and Latin + :Korean, but always only the first encounter of such a combination.</p>

<p>Note that the argument is guaranteed to be not of the Common or Latin script property.</p>

<pre><code>        void    utf8_error_script(const U8 *s,
                                  const char* script, UV uv)</code></pre>

</dd>
<dt id="uvuni_get_script">uvuni_get_script </dt>
<dd>

<p>Returns the script property as string of the unicode character.</p>

<pre><code>        char*   uvuni_get_script(const UV uv)</code></pre>

</dd>
</dl>

<h1 id="Warning-and-Dieing">Warning and Dieing</h1>

<dl>

<dt id="find_script">find_script </dt>
<dd>

<p>Searches for the executable script.</p>

<p>If <code>dosearch</code>, i.e. &lt;-S&gt; is true and if scriptname does not contain path delimiters, search the PATH for scriptname.</p>

<p>If SEARCH_EXTS is also defined, will look for each scriptname{SEARCH_EXTS} whenever scriptname is not found while searching the PATH.</p>

<p>Assuming SEARCH_EXTS is <code>&quot;.foo&quot;,&quot;.bar&quot;,NULL</code>, PATH search proceeds as follows:</p>

<pre><code>  If DOSISH or VMSISH:
    + look for ./scriptname{,.foo,.bar}
    + search the PATH for scriptname{,.foo,.bar}

  If !DOSISH:
    + look *only* in the PATH for scriptname{,.foo,.bar} (note
      this will not look in &#39;.&#39; if it&#39;s not in the PATH)</code></pre>

<p>This is called by <a href="#open_script">&quot;open_script&quot;</a> when <code>-e</code> was not specified.</p>

<pre><code>        char*   find_script(
                    const char *scriptname, bool dosearch,
                    const char *const *const search_ext,
                    I32 flags
                )</code></pre>

</dd>
<dt id="vwarner_security">vwarner_security </dt>
<dd>

<p>The vwarner variant which adds security specific prefix and suffices, and ignores any $SIG{__WARN__} hooks.</p>

<pre><code>        void    vwarner_security(U32 err, const char* pat,
                                 va_list* args)</code></pre>

</dd>
</dl>

<h1 id="Undocumented-functions">Undocumented functions</h1>

<p>The following functions are currently undocumented. If you use one of them, you may wish to consider creating and submitting documentation for it.</p>

<dl>

<dt id="PerlIO_restore_errno">PerlIO_restore_errno </dt>
<dd>

</dd>
<dt id="PerlIO_save_errno">PerlIO_save_errno </dt>
<dd>

</dd>
<dt id="Slab_to_ro">Slab_to_ro </dt>
<dd>

</dd>
<dt id="Slab_to_rw">Slab_to_rw </dt>
<dd>

</dd>
<dt id="add_range_to_invlist">_add_range_to_invlist </dt>
<dd>

</dd>
<dt id="core_swash_init">_core_swash_init </dt>
<dd>

</dd>
<dt id="get_encoding">_get_encoding </dt>
<dd>

</dd>
<dt id="get_regclass_nonbitmap_data">_get_regclass_nonbitmap_data </dt>
<dd>

</dd>
<dt id="get_swash_invlist">_get_swash_invlist </dt>
<dd>

</dd>
<dt id="invlistEQ">_invlistEQ </dt>
<dd>

</dd>
<dt id="invlist_array_init">_invlist_array_init </dt>
<dd>

</dd>
<dt id="invlist_contains_cp">_invlist_contains_cp </dt>
<dd>

</dd>
<dt id="invlist_dump">_invlist_dump </dt>
<dd>

</dd>
<dt id="invlist_intersection">_invlist_intersection </dt>
<dd>

</dd>
<dt id="invlist_intersection_maybe_complement_2nd">_invlist_intersection_maybe_complement_2nd </dt>
<dd>

</dd>
<dt id="invlist_invert">_invlist_invert </dt>
<dd>

</dd>
<dt id="invlist_len">_invlist_len </dt>
<dd>

</dd>
<dt id="invlist_populate_swatch">_invlist_populate_swatch </dt>
<dd>

</dd>
<dt id="invlist_search">_invlist_search </dt>
<dd>

</dd>
<dt id="invlist_subtract">_invlist_subtract </dt>
<dd>

</dd>
<dt id="invlist_union">_invlist_union </dt>
<dd>

</dd>
<dt id="invlist_union_maybe_complement_2nd">_invlist_union_maybe_complement_2nd </dt>
<dd>

</dd>
<dt id="is_grapheme">_is_grapheme </dt>
<dd>

</dd>
<dt id="load_PL_utf8_foldclosures">_load_PL_utf8_foldclosures </dt>
<dd>

</dd>
<dt id="mem_collxfrm">_mem_collxfrm </dt>
<dd>

</dd>
<dt id="new_invlist">_new_invlist </dt>
<dd>

</dd>
<dt id="new_invlist_C_array">_new_invlist_C_array </dt>
<dd>

</dd>
<dt id="setup_canned_invlist">_setup_canned_invlist </dt>
<dd>

</dd>
<dt id="swash_inversion_hash">_swash_inversion_hash </dt>
<dd>

</dd>
<dt id="swash_to_invlist">_swash_to_invlist </dt>
<dd>

</dd>
<dt id="to_fold_latin1">_to_fold_latin1 </dt>
<dd>

</dd>
<dt id="to_upper_title_latin1">_to_upper_title_latin1 </dt>
<dd>

</dd>
<dt id="warn_problematic_locale">_warn_problematic_locale </dt>
<dd>

</dd>
<dt id="add_cp_to_invlist">add_cp_to_invlist </dt>
<dd>

</dd>
<dt id="alloc_maybe_populate_EXACT">alloc_maybe_populate_EXACT </dt>
<dd>

</dd>
<dt id="allocmy">allocmy </dt>
<dd>

</dd>
<dt id="amagic_is_enabled">amagic_is_enabled </dt>
<dd>

</dd>
<dt id="append_utf8_from_native_byte">append_utf8_from_native_byte </dt>
<dd>

</dd>
<dt id="apply">apply </dt>
<dd>

</dd>
<dt id="av_extend_guts">av_extend_guts </dt>
<dd>

</dd>
<dt id="boot_core_PerlIO">boot_core_PerlIO </dt>
<dd>

</dd>
<dt id="boot_core_UNIVERSAL">boot_core_UNIVERSAL </dt>
<dd>

</dd>
<dt id="boot_core_mro">boot_core_mro </dt>
<dd>

</dd>
<dt id="boot_core_xsutils">boot_core_xsutils </dt>
<dd>

</dd>
<dt id="cando">cando </dt>
<dd>

</dd>
<dt id="check_utf8_print">check_utf8_print </dt>
<dd>

</dd>
<dt id="ck_entersub_args_core">ck_entersub_args_core </dt>
<dd>

</dd>
<dt id="ck_join">ck_join </dt>
<dd>

</dd>
<dt id="ck_null">ck_null </dt>
<dd>

</dd>
<dt id="ck_open">ck_open </dt>
<dd>

</dd>
<dt id="ck_prototype">ck_prototype </dt>
<dd>

</dd>
<dt id="ck_refassign">ck_refassign </dt>
<dd>

</dd>
<dt id="ck_repeat">ck_repeat </dt>
<dd>

</dd>
<dt id="ck_require">ck_require </dt>
<dd>

</dd>
<dt id="ck_return">ck_return </dt>
<dd>

</dd>
<dt id="ck_select">ck_select </dt>
<dd>

</dd>
<dt id="ck_shift">ck_shift </dt>
<dd>

</dd>
<dt id="ck_sort">ck_sort </dt>
<dd>

</dd>
<dt id="ck_split">ck_split </dt>
<dd>

</dd>
<dt id="ck_stringify">ck_stringify </dt>
<dd>

</dd>
<dt id="compute_EXACTish">compute_EXACTish </dt>
<dd>

</dd>
<dt id="core_type_name">core_type_name </dt>
<dd>

</dd>
<dt id="croak_no_mem">croak_no_mem </dt>
<dd>

</dd>
<dt id="croak_popstack">croak_popstack </dt>
<dd>

</dd>
<dt id="croak_shaped_array">croak_shaped_array </dt>
<dd>

</dd>
<dt id="ctz">ctz </dt>
<dd>

</dd>
<dt id="current_re_engine">current_re_engine </dt>
<dd>

</dd>
<dt id="custom_op_get_field">custom_op_get_field </dt>
<dd>

</dd>
<dt id="cv_ckproto_len_flags">cv_ckproto_len_flags </dt>
<dd>

</dd>
<dt id="cv_clone_into">cv_clone_into </dt>
<dd>

</dd>
<dt id="cv_const_sv_or_av">cv_const_sv_or_av </dt>
<dd>

</dd>
<dt id="cv_undef_flags">cv_undef_flags </dt>
<dd>

</dd>
<dt id="cvgv_from_hek">cvgv_from_hek </dt>
<dd>

</dd>
<dt id="cvgv_set">cvgv_set </dt>
<dd>

</dd>
<dt id="cvstash_set">cvstash_set </dt>
<dd>

</dd>
<dt id="deb_stack_all">deb_stack_all </dt>
<dd>

</dd>
<dt id="defelem_target">defelem_target </dt>
<dd>

</dd>
<dt id="delimcpy_no_escape">delimcpy_no_escape </dt>
<dd>

</dd>
<dt id="die_unwind">die_unwind </dt>
<dd>

</dd>
<dt id="do_aexec">do_aexec </dt>
<dd>

</dd>
<dt id="do_aexec5">do_aexec5 </dt>
<dd>

</dd>
<dt id="do_eof">do_eof </dt>
<dd>

</dd>
<dt id="do_exec">do_exec </dt>
<dd>

</dd>
<dt id="do_exec3">do_exec3 </dt>
<dd>

</dd>
<dt id="do_execfree">do_execfree </dt>
<dd>

</dd>
<dt id="do_ipcctl">do_ipcctl </dt>
<dd>

</dd>
<dt id="do_ipcget">do_ipcget </dt>
<dd>

</dd>
<dt id="do_msgrcv">do_msgrcv </dt>
<dd>

</dd>
<dt id="do_msgsnd">do_msgsnd </dt>
<dd>

</dd>
<dt id="do_ncmp">do_ncmp </dt>
<dd>

</dd>
<dt id="do_open6">do_open6 </dt>
<dd>

</dd>
<dt id="do_open_raw">do_open_raw </dt>
<dd>

</dd>
<dt id="do_print">do_print </dt>
<dd>

</dd>
<dt id="do_readline">do_readline </dt>
<dd>

</dd>
<dt id="do_seek">do_seek </dt>
<dd>

</dd>
<dt id="do_semop">do_semop </dt>
<dd>

</dd>
<dt id="do_shmio">do_shmio </dt>
<dd>

</dd>
<dt id="do_sysseek">do_sysseek </dt>
<dd>

</dd>
<dt id="do_tell">do_tell </dt>
<dd>

</dd>
<dt id="do_trans">do_trans </dt>
<dd>

</dd>
<dt id="do_vecget">do_vecget </dt>
<dd>

</dd>
<dt id="do_vecset">do_vecset </dt>
<dd>

</dd>
<dt id="do_vop">do_vop </dt>
<dd>

</dd>
<dt id="does_utf8_overflow">does_utf8_overflow </dt>
<dd>

</dd>
<dt id="dofile">dofile </dt>
<dd>

</dd>
<dt id="drand48_init_r">drand48_init_r </dt>
<dd>

</dd>
<dt id="drand48_r">drand48_r </dt>
<dd>

</dd>
<dt id="dtrace_probe_call">dtrace_probe_call </dt>
<dd>

</dd>
<dt id="dtrace_probe_load">dtrace_probe_load </dt>
<dd>

</dd>
<dt id="dtrace_probe_op">dtrace_probe_op </dt>
<dd>

</dd>
<dt id="dtrace_probe_phase">dtrace_probe_phase </dt>
<dd>

</dd>
<dt id="dump_sv_child">dump_sv_child </dt>
<dd>

</dd>
<dt id="emulate_cop_io">emulate_cop_io </dt>
<dd>

</dd>
<dt id="feature_is_enabled">feature_is_enabled </dt>
<dd>

</dd>
<dt id="find_lexical_cv">find_lexical_cv </dt>
<dd>

</dd>
<dt id="find_runcv_where">find_runcv_where </dt>
<dd>

</dd>
<dt id="find_rundefsv2">find_rundefsv2 </dt>
<dd>

</dd>
<dt id="form_short_octal_warning">form_short_octal_warning </dt>
<dd>

</dd>
<dt id="free_tied_hv_pool">free_tied_hv_pool </dt>
<dd>

</dd>
<dt id="get_debug_opts">get_debug_opts </dt>
<dd>

</dd>
<dt id="get_hash_seed">get_hash_seed </dt>
<dd>

</dd>
<dt id="get_invlist_iter_addr">get_invlist_iter_addr </dt>
<dd>

</dd>
<dt id="get_invlist_offset_addr">get_invlist_offset_addr </dt>
<dd>

</dd>
<dt id="get_invlist_previous_index_addr">get_invlist_previous_index_addr </dt>
<dd>

</dd>
<dt id="get_no_modify">get_no_modify </dt>
<dd>

</dd>
<dt id="get_opargs">get_opargs </dt>
<dd>

</dd>
<dt id="get_re_arg">get_re_arg </dt>
<dd>

</dd>
<dt id="getenv_len">getenv_len </dt>
<dd>

</dd>
<dt id="grok_atoUV">grok_atoUV </dt>
<dd>

</dd>
<dt id="grok_bslash_c">grok_bslash_c </dt>
<dd>

</dd>
<dt id="grok_bslash_o">grok_bslash_o </dt>
<dd>

</dd>
<dt id="grok_bslash_x">grok_bslash_x </dt>
<dd>

</dd>
<dt id="gv_fetchmeth_internal">gv_fetchmeth_internal </dt>
<dd>

</dd>
<dt id="gv_override">gv_override </dt>
<dd>

</dd>
<dt id="gv_setref">gv_setref </dt>
<dd>

</dd>
<dt id="gv_stashpvn_internal">gv_stashpvn_internal </dt>
<dd>

</dd>
<dt id="gv_stashsvpvn_cached">gv_stashsvpvn_cached </dt>
<dd>

</dd>
<dt id="handle_named_backref">handle_named_backref </dt>
<dd>

</dd>
<dt id="hfree_next_entry">hfree_next_entry </dt>
<dd>

</dd>
<dt id="hv_undef_flags">hv_undef_flags </dt>
<dd>

</dd>
<dt id="init_argv_symbols">init_argv_symbols </dt>
<dd>

</dd>
<dt id="init_constants">init_constants </dt>
<dd>

</dd>
<dt id="init_dbargs">init_dbargs </dt>
<dd>

</dd>
<dt id="init_debugger">init_debugger </dt>
<dd>

</dd>
<dt id="invlist_array">invlist_array </dt>
<dd>

</dd>
<dt id="invlist_clear">invlist_clear </dt>
<dd>

</dd>
<dt id="invlist_clone">invlist_clone </dt>
<dd>

</dd>
<dt id="invlist_highest">invlist_highest </dt>
<dd>

</dd>
<dt id="invlist_is_iterating">invlist_is_iterating </dt>
<dd>

</dd>
<dt id="invlist_iterfinish">invlist_iterfinish </dt>
<dd>

</dd>
<dt id="invlist_iterinit">invlist_iterinit </dt>
<dd>

</dd>
<dt id="invlist_max">invlist_max </dt>
<dd>

</dd>
<dt id="invlist_previous_index">invlist_previous_index </dt>
<dd>

</dd>
<dt id="invlist_set_len">invlist_set_len </dt>
<dd>

</dd>
<dt id="invlist_set_previous_index">invlist_set_previous_index </dt>
<dd>

</dd>
<dt id="invlist_trim">invlist_trim </dt>
<dd>

</dd>
<dt id="io_close">io_close </dt>
<dd>

</dd>
<dt id="isFF_OVERLONG">isFF_OVERLONG </dt>
<dd>

</dd>
<dt id="isFOO_lc">isFOO_lc </dt>
<dd>

</dd>
<dt id="is_utf8_common">is_utf8_common </dt>
<dd>

</dd>
<dt id="is_utf8_common_with_len">is_utf8_common_with_len </dt>
<dd>

</dd>
<dt id="is_utf8_cp_above_31_bits">is_utf8_cp_above_31_bits </dt>
<dd>

</dd>
<dt id="is_utf8_overlong_given_start_byte_ok">is_utf8_overlong_given_start_byte_ok </dt>
<dd>

</dd>
<dt id="isinfnansv">isinfnansv </dt>
<dd>

</dd>
<dt id="keyword">keyword </dt>
<dd>

</dd>
<dt id="keyword_plugin_standard">keyword_plugin_standard </dt>
<dd>

</dd>
<dt id="magic_clear_all_env">magic_clear_all_env </dt>
<dd>

</dd>
<dt id="magic_cleararylen_p">magic_cleararylen_p </dt>
<dd>

</dd>
<dt id="magic_clearenv">magic_clearenv </dt>
<dd>

</dd>
<dt id="magic_clearisa">magic_clearisa </dt>
<dd>

</dd>
<dt id="magic_clearpack">magic_clearpack </dt>
<dd>

</dd>
<dt id="magic_clearsig">magic_clearsig </dt>
<dd>

</dd>
<dt id="magic_copycallchecker">magic_copycallchecker </dt>
<dd>

</dd>
<dt id="magic_existspack">magic_existspack </dt>
<dd>

</dd>
<dt id="magic_freearylen_p">magic_freearylen_p </dt>
<dd>

</dd>
<dt id="magic_freeovrld">magic_freeovrld </dt>
<dd>

</dd>
<dt id="magic_get">magic_get </dt>
<dd>

</dd>
<dt id="magic_getarylen">magic_getarylen </dt>
<dd>

</dd>
<dt id="magic_getdebugvar">magic_getdebugvar </dt>
<dd>

</dd>
<dt id="magic_getdefelem">magic_getdefelem </dt>
<dd>

</dd>
<dt id="magic_getnkeys">magic_getnkeys </dt>
<dd>

</dd>
<dt id="magic_getpack">magic_getpack </dt>
<dd>

</dd>
<dt id="magic_getpos">magic_getpos </dt>
<dd>

</dd>
<dt id="magic_getsig">magic_getsig </dt>
<dd>

</dd>
<dt id="magic_getsubstr">magic_getsubstr </dt>
<dd>

</dd>
<dt id="magic_gettaint">magic_gettaint </dt>
<dd>

</dd>
<dt id="magic_getuvar">magic_getuvar </dt>
<dd>

</dd>
<dt id="magic_getvec">magic_getvec </dt>
<dd>

</dd>
<dt id="magic_killbackrefs">magic_killbackrefs </dt>
<dd>

</dd>
<dt id="magic_nextpack">magic_nextpack </dt>
<dd>

</dd>
<dt id="magic_regdata_cnt">magic_regdata_cnt </dt>
<dd>

</dd>
<dt id="magic_regdatum_get">magic_regdatum_get </dt>
<dd>

</dd>
<dt id="magic_regdatum_set">magic_regdatum_set </dt>
<dd>

</dd>
<dt id="magic_scalarpack">magic_scalarpack </dt>
<dd>

</dd>
<dt id="magic_set">magic_set </dt>
<dd>

</dd>
<dt id="magic_set_all_env">magic_set_all_env </dt>
<dd>

</dd>
<dt id="magic_setarylen">magic_setarylen </dt>
<dd>

</dd>
<dt id="magic_setcollxfrm">magic_setcollxfrm </dt>
<dd>

</dd>
<dt id="magic_setdbline">magic_setdbline </dt>
<dd>

</dd>
<dt id="magic_setdebugvar">magic_setdebugvar </dt>
<dd>

</dd>
<dt id="magic_setdefelem">magic_setdefelem </dt>
<dd>

</dd>
<dt id="magic_setenv">magic_setenv </dt>
<dd>

</dd>
<dt id="magic_setisa">magic_setisa </dt>
<dd>

</dd>
<dt id="magic_setlvref">magic_setlvref </dt>
<dd>

</dd>
<dt id="magic_setmglob">magic_setmglob </dt>
<dd>

</dd>
<dt id="magic_setnkeys">magic_setnkeys </dt>
<dd>

</dd>
<dt id="magic_setpack">magic_setpack </dt>
<dd>

</dd>
<dt id="magic_setpos">magic_setpos </dt>
<dd>

</dd>
<dt id="magic_setregexp">magic_setregexp </dt>
<dd>

</dd>
<dt id="magic_setsig">magic_setsig </dt>
<dd>

</dd>
<dt id="magic_setsubstr">magic_setsubstr </dt>
<dd>

</dd>
<dt id="magic_settaint">magic_settaint </dt>
<dd>

</dd>
<dt id="magic_setutf8">magic_setutf8 </dt>
<dd>

</dd>
<dt id="magic_setuvar">magic_setuvar </dt>
<dd>

</dd>
<dt id="magic_setvec">magic_setvec </dt>
<dd>

</dd>
<dt id="magic_sizepack">magic_sizepack </dt>
<dd>

</dd>
<dt id="magic_wipepack">magic_wipepack </dt>
<dd>

</dd>
<dt id="malloc_good_size">malloc_good_size </dt>
<dd>

</dd>
<dt id="malloced_size">malloced_size </dt>
<dd>

</dd>
<dt id="mem_collxfrm1">mem_collxfrm </dt>
<dd>

</dd>
<dt id="mem_log_alloc">mem_log_alloc </dt>
<dd>

</dd>
<dt id="mem_log_free">mem_log_free </dt>
<dd>

</dd>
<dt id="mem_log_realloc">mem_log_realloc </dt>
<dd>

</dd>
<dt id="mg_find_mglob">mg_find_mglob </dt>
<dd>

</dd>
<dt id="mode_from_discipline">mode_from_discipline </dt>
<dd>

</dd>
<dt id="more_bodies">more_bodies </dt>
<dd>

</dd>
<dt id="mro_meta_dup">mro_meta_dup </dt>
<dd>

</dd>
<dt id="mro_meta_init">mro_meta_init </dt>
<dd>

</dd>
<dt id="munge_qwlist_to_paren_list">munge_qwlist_to_paren_list </dt>
<dd>

</dd>
<dt id="my_clearenv">my_clearenv </dt>
<dd>

</dd>
<dt id="my_lstat_flags">my_lstat_flags </dt>
<dd>

</dd>
<dt id="my_stat_flags">my_stat_flags </dt>
<dd>

</dd>
<dt id="my_unexec">my_unexec </dt>
<dd>

</dd>
<dt id="newATTRSUB_x">newATTRSUB_x </dt>
<dd>

</dd>
<dt id="newGP">newGP </dt>
<dd>

</dd>
<dt id="newMETHOP_internal">newMETHOP_internal </dt>
<dd>

</dd>
<dt id="newSTUB">newSTUB </dt>
<dd>

</dd>
<dt id="newSVavdefelem">newSVavdefelem </dt>
<dd>

</dd>
<dt id="newXS_deffile">newXS_deffile </dt>
<dd>

</dd>
<dt id="newXS_len_flags">newXS_len_flags </dt>
<dd>

</dd>
<dt id="new_warnings_bitfield">new_warnings_bitfield </dt>
<dd>

</dd>
<dt id="nextargv">nextargv </dt>
<dd>

</dd>
<dt id="noperl_die">noperl_die </dt>
<dd>

</dd>
<dt id="oopsAV">oopsAV </dt>
<dd>

</dd>
<dt id="oopsHV">oopsHV </dt>
<dd>

</dd>
<dt id="op_destroy">op_destroy </dt>
<dd>

</dd>
<dt id="op_refcnt_dec">op_refcnt_dec </dt>
<dd>

</dd>
<dt id="op_refcnt_inc">op_refcnt_inc </dt>
<dd>

</dd>
<dt id="opmethod_stash">opmethod_stash </dt>
<dd>

</dd>
<dt id="package">package </dt>
<dd>

</dd>
<dt id="package_version">package_version </dt>
<dd>

</dd>
<dt id="pad_add_weakref">pad_add_weakref </dt>
<dd>

</dd>
<dt id="padlist_store">padlist_store </dt>
<dd>

</dd>
<dt id="padname_free">padname_free </dt>
<dd>

</dd>
<dt id="padnamelist_free">padnamelist_free </dt>
<dd>

</dd>
<dt id="parse_unicode_opts">parse_unicode_opts </dt>
<dd>

</dd>
<dt id="parser_free">parser_free </dt>
<dd>

</dd>
<dt id="parser_free_nexttoke_ops">parser_free_nexttoke_ops </dt>
<dd>

</dd>
<dt id="pmruntime">pmruntime </dt>
<dd>

</dd>
<dt id="populate_isa">populate_isa </dt>
<dd>

</dd>
<dt id="ptr_hash">ptr_hash </dt>
<dd>

</dd>
<dt id="qerror">qerror </dt>
<dd>

</dd>
<dt id="re_exec_indentf">re_exec_indentf </dt>
<dd>

</dd>
<dt id="re_indentf">re_indentf </dt>
<dd>

</dd>
<dt id="re_op_compile">re_op_compile </dt>
<dd>

</dd>
<dt id="re_printf">re_printf </dt>
<dd>

</dd>
<dt id="reg_named_buff">reg_named_buff </dt>
<dd>

</dd>
<dt id="reg_named_buff_iter">reg_named_buff_iter </dt>
<dd>

</dd>
<dt id="reg_numbered_buff_fetch">reg_numbered_buff_fetch </dt>
<dd>

</dd>
<dt id="reg_numbered_buff_length">reg_numbered_buff_length </dt>
<dd>

</dd>
<dt id="reg_numbered_buff_store">reg_numbered_buff_store </dt>
<dd>

</dd>
<dt id="reg_qr_package">reg_qr_package </dt>
<dd>

</dd>
<dt id="reg_skipcomment">reg_skipcomment </dt>
<dd>

</dd>
<dt id="reg_temp_copy">reg_temp_copy </dt>
<dd>

</dd>
<dt id="regcurly">regcurly </dt>
<dd>

</dd>
<dt id="regprop">regprop </dt>
<dd>

</dd>
<dt id="report_evil_fh">report_evil_fh </dt>
<dd>

</dd>
<dt id="report_wrongway_fh">report_wrongway_fh </dt>
<dd>

</dd>
<dt id="rsignal_restore">rsignal_restore </dt>
<dd>

</dd>
<dt id="rsignal_save">rsignal_save </dt>
<dd>

</dd>
<dt id="rxres_save">rxres_save </dt>
<dd>

</dd>
<dt id="same_dirent">same_dirent </dt>
<dd>

</dd>
<dt id="save_strlen">save_strlen </dt>
<dd>

</dd>
<dt id="scalar">scalar </dt>
<dd>

</dd>
<dt id="set_caret_X">set_caret_X </dt>
<dd>

</dd>
<dt id="set_padlist">set_padlist </dt>
<dd>

</dd>
<dt id="should_warn_nl">should_warn_nl </dt>
<dd>

</dd>
<dt id="sighandler">sighandler </dt>
<dd>

</dd>
<dt id="softref2xv">softref2xv </dt>
<dd>

</dd>
<dt id="ssc_add_range">ssc_add_range </dt>
<dd>

</dd>
<dt id="ssc_clear_locale">ssc_clear_locale </dt>
<dd>

</dd>
<dt id="ssc_cp_and">ssc_cp_and </dt>
<dd>

</dd>
<dt id="ssc_intersection">ssc_intersection </dt>
<dd>

</dd>
<dt id="ssc_union">ssc_union </dt>
<dd>

</dd>
<dt id="stash_to_coretype">stash_to_coretype </dt>
<dd>

</dd>
<dt id="sub_crush_depth">sub_crush_depth </dt>
<dd>

</dd>
<dt id="sv_buf_to_ro">sv_buf_to_ro </dt>
<dd>

</dd>
<dt id="sv_magicext_mglob">sv_magicext_mglob </dt>
<dd>

</dd>
<dt id="sv_mortalcopy_flags">sv_mortalcopy_flags </dt>
<dd>

</dd>
<dt id="sv_only_taint_gmagic">sv_only_taint_gmagic </dt>
<dd>

</dd>
<dt id="sv_or_pv_pos_u2b">sv_or_pv_pos_u2b </dt>
<dd>

</dd>
<dt id="sv_resetpvn">sv_resetpvn </dt>
<dd>

</dd>
<dt id="sv_sethek">sv_sethek </dt>
<dd>

</dd>
<dt id="sv_setsv_cow">sv_setsv_cow </dt>
<dd>

</dd>
<dt id="sv_unglob">sv_unglob </dt>
<dd>

</dd>
<dt id="swash_fetch">swash_fetch </dt>
<dd>

</dd>
<dt id="swash_init">swash_init </dt>
<dd>

</dd>
<dt id="tied_method">tied_method </dt>
<dd>

</dd>
<dt id="tmps_grow_p">tmps_grow_p </dt>
<dd>

</dd>
<dt id="translate_substr_offsets">translate_substr_offsets </dt>
<dd>

</dd>
<dt id="try_amagic_bin">try_amagic_bin </dt>
<dd>

</dd>
<dt id="try_amagic_un">try_amagic_un </dt>
<dd>

</dd>
<dt id="utf8_add_script">utf8_add_script </dt>
<dd>

</dd>
<dt id="utilize">utilize </dt>
<dd>

</dd>
<dt id="varname">varname </dt>
<dd>

</dd>
<dt id="vivify_defelem">vivify_defelem </dt>
<dd>

</dd>
<dt id="vivify_ref">vivify_ref </dt>
<dd>

</dd>
<dt id="wait4pid">wait4pid </dt>
<dd>

</dd>
<dt id="was_lvalue_sub">was_lvalue_sub </dt>
<dd>

</dd>
<dt id="watch">watch </dt>
<dd>

</dd>
<dt id="win32_croak_not_implemented">win32_croak_not_implemented </dt>
<dd>

</dd>
<dt id="write_to_stderr">write_to_stderr </dt>
<dd>

</dd>
<dt id="xs_boot_epilog">xs_boot_epilog </dt>
<dd>

</dd>
<dt id="yyerror">yyerror </dt>
<dd>

</dd>
<dt id="yyerror_pv">yyerror_pv </dt>
<dd>

</dd>
<dt id="yyerror_pvn">yyerror_pvn </dt>
<dd>

</dd>
<dt id="yylex">yylex </dt>
<dd>

</dd>
<dt id="yyparse">yyparse </dt>
<dd>

</dd>
<dt id="yyunlex">yyunlex </dt>
<dd>

</dd>
</dl>

<h1 id="AUTHORS">AUTHORS</h1>

<p>The autodocumentation system was originally added to the Perl core by Benjamin Stuhl. Documentation is by whoever was kind enough to document their functions.</p>

<h1 id="SEE-ALSO">SEE ALSO</h1>

<p><a href="/cperl/perlguts.html">perlguts</a>, <a href="/pod/perlapi.html">perlapi</a></p>

<h1 id="POD-ERRORS">POD ERRORS</h1>

<p>Hey! <b>The above document had some coding errors, which are explained below:</b></p>

<dl>

<dt id="Around-line-2134">Around line 2134:</dt>
<dd>

<p>Non-ASCII character seen before =encoding in &#39;don&rsquo;t&#39;. Assuming UTF-8</p>

</dd>
</dl>


</body>

</html>


