<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title></title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:rurban@cpan.org" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION  </a></li>
  <li><a href="#Array-Manipulation-Functions">Array Manipulation Functions</a></li>
  <li><a href="#Check-routines">Check routines</a></li>
  <li><a href="#Compile-time-scope-hooks">Compile-time scope hooks</a></li>
  <li><a href="#Custom-Operators">Custom Operators</a></li>
  <li><a href="#CV-Manipulation-Functions">CV Manipulation Functions</a></li>
  <li><a href="#CV-reference-counts-and-CvOUTSIDE">CV reference counts and CvOUTSIDE</a></li>
  <li><a href="#Debugging-Utilities">Debugging Utilities</a></li>
  <li><a href="#Embedding-Functions">Embedding Functions</a></li>
  <li><a href="#Functions-in-file-inline.h">Functions in file inline.h</a></li>
  <li><a href="#Functions-in-file-op.c">Functions in file op.c</a></li>
  <li><a href="#Functions-in-file-pp.c">Functions in file pp.c</a></li>
  <li><a href="#Functions-in-file-regcomp.c">Functions in file regcomp.c</a></li>
  <li><a href="#GV-Functions">GV Functions</a></li>
  <li><a href="#Hash-Entries">Hash Entries</a></li>
  <li><a href="#Hash-Manipulation-Functions">Hash Manipulation Functions</a></li>
  <li><a href="#Hook-manipulation">Hook manipulation</a></li>
  <li><a href="#IO-Functions">IO Functions</a></li>
  <li><a href="#Lexer-interface">Lexer interface</a></li>
  <li><a href="#Magical-Functions">Magical Functions</a></li>
  <li><a href="#Miscellaneous-Functions">Miscellaneous Functions</a></li>
  <li><a href="#MRO-Functions">MRO Functions</a></li>
  <li><a href="#Numeric-functions">Numeric functions</a></li>
  <li><a href="#Optree-construction">Optree construction</a></li>
  <li><a href="#Optree-Manipulation-Functions">Optree Manipulation Functions</a></li>
  <li><a href="#Pad-Data-Structures">Pad Data Structures</a></li>
  <li><a href="#Per-Interpreter-Variables">Per-Interpreter Variables</a></li>
  <li><a href="#Stack-Manipulation-Macros">Stack Manipulation Macros</a></li>
  <li><a href="#SV-Manipulation-Functions">SV Manipulation Functions</a></li>
  <li><a href="#Unicode-Support">Unicode Support</a></li>
  <li><a href="#Warning-and-Dieing">Warning and Dieing</a></li>
  <li><a href="#Undocumented-functions">Undocumented functions</a></li>
  <li><a href="#AUTHORS">AUTHORS</a></li>
  <li><a href="#SEE-ALSO">SEE ALSO</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>perlintern - autogenerated documentation of purely <b>internal</b> Perl functions</p>

<h1 id="DESCRIPTION">DESCRIPTION  </h1>

<p>This file is the autogenerated documentation of functions in the Perl interpreter that are documented using Perl&#39;s internal documentation format but are not marked as part of the Perl API. In other words, <b>they are not for use in extensions</b>!</p>

<p>Exceptions are the public <b>ck_</b> check functions and <b>pp_</b> push/pop opcodes, which are part of the public API available to extensions, but still documented only here, until they can be moved to the <a href="/cperl/perlapi.html">perlapi</a> pod.</p>

<h1 id="Array-Manipulation-Functions">Array Manipulation Functions</h1>

<dl>

<dt id="av_reify">av_reify </dt>
<dd>

<p>The elements of the @_ argarray, marked as !AvREAL &amp;&amp; AvREIFY, become real refcounted SVs.</p>

<p>Bumps the refcount for every non-empty value, and clears all the invalid values.</p>

<p>Sets AvREIFY_off and AvREAL_on.</p>

<p>AvREAL arrays handle refcounts of the elements, !AvREAL arrays ignore them.</p>

<pre><code>        void    av_reify(AV *av)</code></pre>

</dd>
</dl>

<h1 id="Check-routines">Check routines</h1>

<p>A check routine is called at the end of the &quot;newOP&quot; creation routines. So at the point that a <code>ck_</code> routine fires, we have no idea what the context is, either upward in the syntax tree, or either forward or backward in the execution order.</p>

<p>Lexical slots (<code>op_targ</code>) are also not yet known, this is done at the end of a check function in <code>op_std_init(o)</code>. For more see the comments at the top of <i>op.c</i> for details.</p>

<p>See <i>regen/opcodes</i> which opcode calls which check function. Not all ops have a specific check function.</p>

<p><a href="#ck_fun">&quot;ck_fun&quot;</a> is a generic arity type checker, <a href="#ck_type">&quot;ck_type&quot;</a> a generic type checker for un- and binops.</p>

<p><code>fold_constants(op_integerize(op_std_init(o)))</code> is the default treatment, i.e. fold constants, apply use integer optimizations and initialize the <code>op_targ</code> for uninitialized pads.</p>

<p>Prototypes are generated by <i>regen/embed_lib.pl</i> by scanning <i>regen/opcodes</i>, check functions are not in <i>embed.fnc</i>.</p>

<dl>

<dt id="aassign_padcheck">aassign_padcheck </dt>
<dd>

<p>helper function for S_aassign_scan().</p>

<p>Check a PAD-related op for commonality and/or set its generation number. Returns a boolean indicating whether its shared. bool aassign_padcheck(OP* o, bool rhs)</p>

</dd>
<dt id="aassign_scan">aassign_scan </dt>
<dd>

<p>Helper function for OPpASSIGN_COMMON* detection in rpeep(). It scans the left or right hand subtree of the aassign op, and returns a set of flags indicating what sorts of things it found there. &#39;rhs&#39; indicates whether we&#39;re scanning the LHS or RHS. If the former, we set PL_generation on lexical vars; if the latter, we see if PL_generation matches.</p>

<p>&#39;top&#39; indicates whether we&#39;re recursing or at the top level. &#39;scalars_p&#39; is a pointer to a counter of the number of scalar SVs seen. This fn will increment it by the number seen. It&#39;s not intended to be an accurate count (especially as many ops can push a variable number of SVs onto the stack); rather it&#39;s used as to test whether there can be at most 1 SV pushed; so it&#39;s only meanings are &quot;0, 1, many&quot;. int aassign_scan(OP* o, bool rhs, bool top, int *scalars_p)</p>

</dd>
<dt id="arg_check_type">arg_check_type </dt>
<dd>

<p>Check if the declared static type of the argument from pn can be fullfilled by the dynamic type of the arg in OP* o (padsv, const, any return type). If possible add a typecast to <code>o</code> to fullfill it. contravariant.</p>

<p>Signatures are new, hence much stricter, than return-types and assignments. arg_check_type;</p>

</dd>
<dt id="arg_check_type_sv">arg_check_type_sv </dt>
<dd>

<p>Check if the declared static type of the argument from pn can be fullfilled by the dynamic type of the arg in SV* sv. The run-time variant of arg_check_type, contravariant.</p>

<p>Signatures are new, hence much stricter, than return-types and assignments. NOTE: the perl_ form of this function is deprecated.</p>

<pre><code>        void    arg_check_type_sv(const PADNAME* pn, SV* sv,
                                  GV *cvname)</code></pre>

</dd>
<dt id="arg_type_sv">arg_type_sv </dt>
<dd>

<p>Return the type for the sv. Optionally sets usertype and u8 (if usertype is utf8), when usertype is not NULL, and the SV is blessed.</p>

<pre><code>                arg_type_sv;</code></pre>

</dd>
<dt id="can_class_typecheck">can_class_typecheck </dt>
<dd>

<p>Returns 1 if this class has a compile-time @ISA or we are already at the run-time phase. This is not called for coretypes, coretypes would always return 1.</p>

<p>Check for class or package types. Does the class has an compile-time ISA to allow compile-time checks? #249 HvCLASS: Is it a cperl class? Does it use base or fields? If not cannot do this check before run-time.</p>

<p>(Essentially cperl classes are just syntactic and performance optimized sugar over base/fields with roles and multi-dispatch support. We don&#39;t invent anything new, we just fix what p5p broke.)</p>

<pre><code>                can_class_typecheck;</code></pre>

</dd>
<dt id="check_for_bool_cxt">check_for_bool_cxt </dt>
<dd>

<p>See if the ops following o are such that o will always be executed in boolean context: that is, the SV which o pushes onto the stack will only ever be consumed by later ops via SvTRUE(sv) or similar. If so, set a suitable private flag on o. Normally this will be bool_flag; but see below why maybe_flag is needed too.</p>

<p>Typically the two flags you pass will be the generic OPpTRUEBOOL and OPpMAYBE_TRUEBOOL, buts it&#39;s possible that for some ops those bits may already be taken, so you&#39;ll have to give that op two different flags.</p>

<p>More explanation of &#39;maybe_flag&#39; and &#39;safe_and&#39; parameters. The binary logical ops &amp;&amp;, ||, // (plus &#39;if&#39; and &#39;unless&#39; which use those underlying ops) short-circuit, which means that rather than necessarily returning a truth value, they may return the LH argument, which may not be boolean. For example in $x = (keys %h || -1), keys should return a key count rather than a boolean, even though its sort-of being used in boolean context.</p>

<p>So we only consider such logical ops to provide boolean context to their LH argument if they themselves are in void or boolean context. However, sometimes the context isn&#39;t known until run-time. In this case the op is marked with the maybe_flag flag it.</p>

<p>Consider the following.</p>

<pre><code>    sub f { ....;  if (%h) { .... } }</code></pre>

<p>This is actually compiled as</p>

<pre><code>    sub f { ....;  %h &amp;&amp; do { .... } }</code></pre>

<p>Here we won&#39;t know until runtime whether the final statement (and hence the &amp;&amp;) is in void context and so is safe to return a boolean value. So mark o with maybe_flag rather than the bool_flag. Note that there is cost associated with determining context at runtime (e.g. a call to block_gimme()), so it may not be worth setting (at compile time) and testing (at runtime) maybe_flag if the scalar verses boolean costs savings are marginal.</p>

<p>However, we can do slightly better with &amp;&amp; (compared to || and //): this op only returns its LH argument when that argument is false. In this case, as long as the op promises to return a false value which is valid in both boolean and scalar contexts, we can mark an op consumed by &amp;&amp; with bool_flag rather than maybe_flag. For example as long as pp_padhv and pp_rv2hv return SV_ZERO rather than SV_NO for a false result in boolean context, then it&#39;s safe. An op which promises to handle this case is indicated by setting safe_and to true.</p>

<pre><code>        void    check_for_bool_cxt(OP* o, bool safe_and,
                                   U8 bool_flag, U8 maybe_flag)</code></pre>

</dd>
<dt id="ck_aassign">ck_aassign </dt>
<dd>

<p>CHECK callback for aassign (t2 L L &quot;(:List,:List):List&quot;)</p>

<p>Checks types and adds <code>OPpMAP_PAIR</code> to <code>%hash = map</code>.</p>

<p>TODO: constant folding with OpSPECIAL TODO: fill lhs AvFILLp with gh210-computedsizearydecl OP * ck_aassign(OP *o)</p>

</dd>
<dt id="ck_aelem">ck_aelem </dt>
<dd>

<p>Check for typed and shaped arrays, and promote ops.</p>

<p>With constant indices throws compile-time &quot;Array index out of bounds&quot; and &quot;Too many elements&quot; errors.</p>

<p>No natively typed arrays yet. OP * ck_aelem(OP *o)</p>

</dd>
<dt id="ck_anoncode">ck_anoncode </dt>
<dd>

<p>CHECK callback for anoncode (s$ S)</p>

<p>Creates an anon pad.</p>

<p>NOTE: the perl_ form of this function is deprecated.</p>

<pre><code>        OP *    ck_anoncode(OP *o)</code></pre>

</dd>
<dt id="ck_backtick">ck_backtick </dt>
<dd>

<p>CHECK callback for `` and qx (tu% S?)</p>

<p>Handle readpipe overrides, the missing default argument and apply $^H{open_IN} or $^H{open_OUT} io hints.</p>

<p>TODO: Handle cperl macro `` unquote syntax here later. OP * ck_backtick(OP *o)</p>

</dd>
<dt id="ck_bitop">ck_bitop </dt>
<dd>

<p>CHECK callback for all bitops, if generic, integer or string variants.</p>

<p>Integerize the results (as if under use integer), and handle some warnings.</p>

<pre><code>        OP *    ck_bitop(OP *o)</code></pre>

</dd>
<dt id="ck_cmp">ck_cmp </dt>
<dd>

<p>CHECK callback for numeric comparisons (all but *cmp) Optimize index() == -1 or &lt; 0 into OPpINDEX_BOOLNEG, ditto != -1 or &gt;= 0 into OPpTRUEBOOL.</p>

<p>Warn on $[ (did you mean $] ?)</p>

<pre><code>        OP *    ck_cmp(OP *o)</code></pre>

</dd>
<dt id="ck_concat">ck_concat </dt>
<dd>

<p>CHECK callback for concat</p>

<p>Handles STACKED. Leaves out op_integerize, as concat is for strings only. OP * ck_concat(OP *o)</p>

</dd>
<dt id="ck_defined">ck_defined </dt>
<dd>

<p>CHECK callback for defined (isu% S? &quot;(:Scalar):Bool&quot;)</p>

<p>Errors now on @array and %hash arguments.</p>

<p>Also calls <a href="#ck_rfun">&quot;ck_rfun&quot;</a>, turning the argument into a reference, which is still useful for defined &amp;sub, not calling sub, just checking if &amp;sub has a body. OP * ck_defined(OP *o)</p>

</dd>
<dt id="ck_delete">ck_delete </dt>
<dd>

<p>CHECK callback for delete (% S &quot;(:Str):Void&quot;)</p>

<p>Handle array and hash elements and slices.</p>

<pre><code>        OP *    ck_delete(OP *o)</code></pre>

</dd>
<dt id="ck_each">ck_each </dt>
<dd>

<p>CHECK callback for each, valus and keys and its array variants.</p>

<p>Optimizes into the array specific variants, checks for type errors, and die on the old 5.14 experimental feature which allowed <code>each</code>, <code>keys</code>, <code>push</code>, <code>pop</code>, <code>shift</code>, <code>splice</code>, <code>unshift</code>, and <code>values</code> to be called with a scalar argument. See <a href="/cperl/perl5140delta.html#Syntactical-Enhancements">&quot;Syntactical Enhancements&quot; in perl5140delta</a> This experiment is considered unsuccessful, and has been removed.</p>

<pre><code>        OP *    ck_each(OP *o)</code></pre>

</dd>
<dt id="ck_eof">ck_eof </dt>
<dd>

<p>CHECK callback for getc and eof (is% F?)</p>

<p>Esp. set the missing default argument to *ARGV OP * ck_eof(OP *o)</p>

</dd>
<dt id="ck_eval">ck_eval </dt>
<dd>

<p>CHECK callback for entereval (du% S?) and entertry (d|)</p>

<p>... OP * ck_eval(OP *o)</p>

</dd>
<dt id="ck_exec">ck_exec </dt>
<dd>

<p>CHECK callback for system and exec (imsT@ S? L)</p>

<p>If as list or string.</p>

<pre><code>        OP *    ck_exec(OP *o)</code></pre>

</dd>
<dt id="ck_exists">ck_exists </dt>
<dd>

<p>CHECK callback for exists (is% S &quot;(:Str):Bool&quot;)</p>

<p>Handle hash or array elements, and ref subs.</p>

<pre><code>        OP *    ck_exists(OP *o)</code></pre>

</dd>
<dt id="ck_ftst">ck_ftst </dt>
<dd>

<p>CHECK callback for stat, lstat (u- F?) and the -X file tests (isu- F-+)</p>

<p>Handle _ and a missing optional arg.</p>

<pre><code>        OP *    ck_ftst(OP *o)</code></pre>

</dd>
<dt id="ck_fun">ck_fun </dt>
<dd>

<p>CHECK callback for the rest</p>

<p>check and fix arguments of internal op calls, but not entersub user-level signatured or prototyped calls. throw arity errors, unify arg list, e.g. add scalar cast, add $_ ... OP * ck_fun(OP *o)</p>

</dd>
<dt id="ck_glob">ck_glob </dt>
<dd>

<p>CHECK callback for glob (t@ S?)</p>

<p>glob defaults its first arg to $_</p>

<p>Also handles initializing an optional external File::Glob hook on certain platforms. OP * ck_glob(OP *o)</p>

</dd>
<dt id="ck_grep">ck_grep </dt>
<dd>

<p>CHECK callback for grepstart and mapstart (m@ C L)</p>

<p>Handles BLOCK and ordinary comma style, throwing an error if the comma-less version is not on a BLOCK.</p>

<p>Applies lexical $_ optimization or handles the default $_.</p>

<pre><code>        OP *    ck_grep(OP *o)</code></pre>

</dd>
<dt id="ck_index">ck_index </dt>
<dd>

<p>CHECK callback for index, rindex (sT@ S S S?)</p>

<p>Does compile-time fbm (Boyer-Moore) compilation on a constant string. OP * ck_index(OP *o)</p>

</dd>
<dt id="ck_length">ck_length </dt>
<dd>

<p>CHECK callback for length, only needed to throw compile-time warnings when length is mixed up with scalar.</p>

<pre><code>        OP *    ck_length(OP *o)</code></pre>

</dd>
<dt id="ck_lfun">ck_lfun </dt>
<dd>

<p>CHECK callback for {i_,}{pre,post}{inc,dec} (dIs1 S) and sprintf.</p>

<p>Turns on MOD on all kids, setting it to a lvalue function. See <a href="#modkids">&quot;modkids&quot;</a>. OP * ck_lfun(OP *o)</p>

</dd>
<dt id="ck_listiob">ck_listiob </dt>
<dd>

<p>CHECK callback for prtf,print,say (ims@ F? L)</p>

<p>Checks for the 1st bareword filehandle argument, if without comma. And if list argument was provided, or add $_. OP * ck_listiob(OP *o)</p>

</dd>
<dt id="ck_match">ck_match </dt>
<dd>

<p>CHECK callback for match,qr,subst,trans,transr</p>

<p>Sets TARGET_MY and the targ offset on my $_ (not with qr), which avoids runtime lookup of the global $_.</p>

<p>Note: This optimization was removed in perl5 with 5.24. In perl5 you have to fight with other dynamic default topics in blocks, overwriting each other. OP * ck_match(OP *o)</p>

</dd>
<dt id="ck_method">ck_method </dt>
<dd>

<p>CHECK callback for method (d.)</p>

<p>Creates one of the 4 METHOP ops. Checks for static SUPER:: calls. See also <a href="#ck_subr">&quot;ck_subr&quot;</a> OP * ck_method(OP *o)</p>

</dd>
<dt id="ck_negate">ck_negate </dt>
<dd>

<p>Check the ! op, negate and turn off OPpCONST_STRICT of the argument. OP * ck_negate(OP *o)</p>

</dd>
<dt id="ck_nomg">ck_nomg </dt>
<dd>

<p>For tie and bless</p>

<p>Check if the first argument is not a typed coretype. We guarantee coretyped variables to have no magic.</p>

<p>For bless we also require a ref. Check for the most common mistakes as first argument, which cannot be a ref.</p>

<p>For bless we can predict the result type if the 2nd arg is a constant. This allows to type the result of the new method.</p>

<pre><code>    sub D3::new {bless[],&quot;D3&quot;};
    my B2 $obj1 = D3-&gt;new;</code></pre>

<p>We disallow the blessing to coretypes. This needs to be done via normal compile-time declarations, not dynamic blessing. OP * ck_nomg(OP *o)</p>

</dd>
<dt id="ck_pad">ck_pad </dt>
<dd>

<p>Check for const and types. Called from newOP/newPADOP this is too early, the target is attached later. But we also call it from constant folding. Having an explicit CONST op allows constant optimizations on it. OP * ck_pad(OP *o)</p>

</dd>
<dt id="ck_readline">ck_readline </dt>
<dd>

<p>CHECK callback for readline, the &lt;&gt; op. (t% F? &quot;(:Scalar?):Any&quot;)</p>

<p>Adds <code>*ARGV</code> if missing. OP * ck_readline(OP *o)</p>

</dd>
<dt id="ck_rfun">ck_rfun </dt>
<dd>

<p>CHECK callback for lock (s% R)</p>

<p>Calls <a href="#refkids">&quot;refkids&quot;</a> to turn the argument into a reference.</p>

<p>Remember that lock can be called on everything, scalar, ref, array, hash or sub, but internally we better work with a scalar reference. OP * ck_rfun(OP *o)</p>

</dd>
<dt id="ck_rvconst">ck_rvconst </dt>
<dd>

<p>CHECK callback for rv2[gsc]const (ds1 R &quot;(:Ref):Scalar&quot;)</p>

<p>Error on bareword constants, initialize the symbol.</p>

<pre><code>        OP *    ck_rvconst(OP *o)</code></pre>

</dd>
<dt id="ck_sassign">ck_sassign </dt>
<dd>

<p>CHECK callback for sassign (s2 S S &quot;(:Scalar,:Scalar):Scalar&quot;)</p>

<p>Esp. handles state var initialization and tries to optimize away the assignment for a lexical <code>$_</code> via <a href="#maybe_targlex">&quot;maybe_targlex&quot;</a>.</p>

<p>Checks types.</p>

<p>TODO: constant folding with OpSPECIAL OP * ck_sassign(OP *o)</p>

</dd>
<dt id="ck_smartmatch">ck_smartmatch </dt>
<dd>

<p>CHECK callback for smartmatch (s2)</p>

<p>Rearranges the kids to refs if not SPECIAL, and optimizes the runtime MATCH to a compile-time QR. OP * ck_smartmatch(OP *o)</p>

</dd>
<dt id="ck_spair">ck_spair </dt>
<dd>

<p>CHECK callback for chop, chomp and refgen with optional lists</p>

<p>Transforms single-element lists into the single argument variant op srefgen, schop, schomp.</p>

<pre><code>        OP *    ck_spair(OP *o)</code></pre>

</dd>
<dt id="ck_subr">ck_subr </dt>
<dd>

<p>CHECK callback for entersub, enterxssub, enterffi. All (dm1 L). See also <a href="#ck_method">&quot;ck_method&quot;</a> OP * ck_subr(OP *o)</p>

</dd>
<dt id="ck_substr">ck_substr </dt>
<dd>

<p>CHECK callback for substr (st@ S S S? S?) turning for the 4 arg variant into an lvalue sub. OP * ck_substr(OP *o)</p>

</dd>
<dt id="ck_svconst">ck_svconst </dt>
<dd>

<p>CHECK callback for const (ps$ &quot;():Scalar&quot;) and hintseval (s$)</p>

<p>Turns on COW and READONLY for the scalar. OP * ck_svconst(OP *o)</p>

</dd>
<dt id="ck_tell">ck_tell </dt>
<dd>

<p>CHECK callback for tell and seek OP * ck_tell(OP *o)</p>

</dd>
<dt id="ck_trunc">ck_trunc </dt>
<dd>

<p>CHECK callback for truncate (is@ S S) truncate really behaves as if it had both &quot;S S&quot; and &quot;F S&quot; i.e. with a bare handle argument turns on SPECIAL and off CONST_STRICT. OP * ck_trunc(OP *o)</p>

</dd>
<dt id="ck_type">ck_type </dt>
<dd>

<p>Check unop and binops for typed args, find specialized match and promote. Forget about native types (escape analysis) here, use the boxed variants. We can only unbox them later in rpeep sequences, by adding unbox...box ops. Set the OpRETTYPE of unops and binops. OP * ck_type(OP *o)</p>

</dd>
<dt id="cv_type_set">cv_type_set </dt>
<dd>

<p>NOTE: this function is experimental and may change or be removed without notice.</p>

<p>Set the return type of a sub.</p>

<p>When the padnames are still the default compile-time comppad_name, then we have to clone it to be able to set private [0] types for each subroutine, to avoid to overwrite them each other. If it&#39;s a private CvPADLIST already don&#39;t clone it.</p>

<pre><code>        void    cv_type_set(CV *cv, HV *stash)</code></pre>

</dd>
<dt id="inplace_aassign">inplace_aassign </dt>
<dd>

<p>Check for in place reverse and sort assignments like &quot;@a = reverse @a&quot; and modify the optree to make them work inplace.</p>

<pre><code>                inplace_aassign;</code></pre>

</dd>
<dt id="io_hints">io_hints </dt>
<dd>

<p>Apply $^H{open_IN} or $^H{open_OUT} io hints, by setting op_private bits for raw or crlf.</p>

<pre><code>        void    io_hints(OP* o)</code></pre>

</dd>
<dt id="is_types_strict">is_types_strict </dt>
<dd>

<p>Check if the current lexical block has <code>use types &#39;strict&#39;</code> enabled.</p>

<pre><code>                is_types_strict;</code></pre>

</dd>
<dt id="match_type">match_type </dt>
<dd>

<p>Match a coretype from arg or op (atyp) to the declared stash of a variable (dtyp). Searches stash in @aname::ISA (contravariant, for arguments).</p>

<p>Added a 4th parameter if to allow inserting a type cast: numify. Scalar =&gt; Bool/Numeric Currently castable is only: Scalar/Ref/Sub/Regexp =&gt; Bool/Numeric Maybe allow casting from Scalar/Numeric to Int =&gt; int() and Scalar to Str =&gt; stringify()</p>

<p>On atyp == type_Object check the name and its ISA instead. int match_type(const HV* stash, core_types_t atyp, const char* aname, bool au8, int *castable)</p>

</dd>
<dt id="match_type1">match_type1 </dt>
<dd>

<p>match an UNOP type with the given arg.</p>

<pre><code>        int     match_type1(const U32 sig, core_types_t arg1)</code></pre>

</dd>
<dt id="match_type2">match_type2 </dt>
<dd>

<p>match an BINOP type with the given args.</p>

<pre><code>        int     match_type2(const U32 sig, core_types_t arg1,
                            core_types_t arg2)</code></pre>

</dd>
<dt id="match_user_type">match_user_type </dt>
<dd>

<pre><code>                                        |NN const char* aname|bool au8</code></pre>

<p>Match a usertype from argument (aname+au8) to the declared usertype name of a variable (dstash). Searches dstash in @aname::ISA (contravariant, for arguments).</p>

<p>On return-type checks the arguments get in reversed (covariant).</p>

<p>Note that old-style package ISA&#39;s are created dynamically. Only classes with compile-time known ISA&#39;s can be checked at compile-time. Which are currently: use base/fields using Internals::HvCLASS, and later the perl6 syntax class Name is Parent {} match_user_type;</p>

</dd>
<dt id="maybe_multideref">maybe_multideref </dt>
<dd>

<p>Given an op_next chain of ops beginning at &#39;start&#39; that potentially represent a series of one or more aggregate derefs (such as $a-&gt;[1]{$key}), examine the chain, and if appropriate, convert the whole chain to a single OP_MULTIDEREF op (maybe with a few additional ops left in too).</p>

<p>The caller will have already verified that the first few ops in the chain following &#39;start&#39; indicate a multideref candidate, and will have set &#39;orig_o&#39; to the point further on in the chain where the first index expression (if any) begins. &#39;orig_action&#39; specifies what type of beginning has already been determined by the ops between start..orig_o (e.g. $lex_ary[], $pkg_ary-&gt;{}, expr-&gt;[], etc).</p>

<p>&#39;hints&#39; contains any hints flags that need adding (currently just OPpHINT_STRICT_REFS) as found in any rv2av/hv skipped by the caller. void maybe_multideref(OP *start, OP *orig_o, UV orig_action, U8 hints)</p>

</dd>
<dt id="maybe_targlex">maybe_targlex </dt>
<dd>

<p>Sets the possible lexical $_ TARGET_MY optimization, skipping a scalar assignment. OP* maybe_targlex(OP* o)</p>

</dd>
<dt id="mderef_uoob_gvsv">mderef_uoob_gvsv </dt>
<dd>

<p>check the key index sv of the first INDEX_gvsv of a MDEREF_AV, compare it with the given key, and set INDEX_uoob.</p>

<p>Only available without threads. Threaded perls use <a href="#mderef_uoob_targ">&quot;mderef_uoob_targ&quot;</a> instead. bool mderef_uoob_gvsv(OP* o, SV* idx)</p>

</dd>
<dt id="mderef_uoob_targ">mderef_uoob_targ </dt>
<dd>

<p>check the targ of the first INDEX_padsv of a MDEREF_AV, compare it with the given targ, and set INDEX_uoob. bool mderef_uoob_targ(OP* o, PADOFFSET targ)</p>

</dd>
<dt id="op_typed_user">op_typed_user </dt>
<dd>

<p>Return the type as core_types_t enum of the op. User-defined types are only returned as type_Object, get the name of those with S_typename().</p>

<p>TODO: add defined return types of all ops, and user-defined CV types for entersub.</p>

<p>u8 returns 0 or 1 (HEKf_UTF8), not SVf_UTF8</p>

<pre><code>        core_types_t op_typed_user(OP* o, char** usertype,
                                   int* u8)</code></pre>

</dd>
<dt id="op_check_type">_op_check_type </dt>
<dd>

<p>Check if the declared static type of the op (i.e. assignment) from the lhs pn can be fullfilled by the dynamic type of the rhs in OP* o (padsv, const, any return type). If possible add a typecast to o to fullfill it.</p>

<p>Different to arg_check_type a type violation is not fatal, it only throws a compile-time warning when no applicable type-conversion can be applied. Return-types and assignments are passed through the type inferencer and applied to old constructs, not signatures, hence not so strict.</p>

<p>Contravariant: Enables you to use a more generic (less derived) type than originally specified.</p>

<p>But note this special implicit perl case: scalar = list; # (array|hash) &lt;=&gt; scalar = shift list; _op_check_type;</p>

</dd>
<dt id="peep-void-peep-OP-o">peep  void peep(OP* o)</dt>
<dd>

</dd>
<dt id="peep_leaveloop">peep_leaveloop </dt>
<dd>

<p>check loop bounds and possibly turn aelem/mderef/aelemfast_lex into an unchecked faster aelem_u.</p>

<p>1) if index bound to size/arylen, optimize to unchecked aelem_u variants, even without parametrized typed. need to check the right array, and if the loop index is used as is, or within an expression.</p>

<p>2) with static bounds check unrolling.</p>

<p>3) with static ranges and shaped arrays, can possibly optimize to aelem_u</p>

<p>Returns TRUE when some op was changed.</p>

<pre><code>        bool    peep_leaveloop(BINOP* leave, OP* from, OP* to)</code></pre>

</dd>
<dt id="ret_check_type">ret_check_type </dt>
<dd>

<p>Check if the declared static type of the return type from the lhs pn can be fullfilled by the dynamic type of the rhs in OP* o (padsv, const, any return type). If possible add a typecast to o to fullfill it.</p>

<p>Different to arg_check_type a type violation is not fatal, it only throws a compile-time warning when no applicable type-conversion can be applied. Return-types and assignments are passed through the type inferencer and applied to old constructs, not signatures, hence not so strict.</p>

<p>Covariant: Enables you to use a more derived type than originally specified. ret_check_type;</p>

</dd>
<dt id="rpeep">rpeep </dt>
<dd>

<p>The peephole optimizer. We visit the ops in the order they&#39;re to execute. See the comments at the top of this file for more details about when peep() is called.</p>

<p>Warning: rpeep is not a real peephole optimizer as other compilers implement it due to historic ballast. It started more as a glorified op nullifier. It sets op_opt when done, and does not run it again when it sees this flag at the op. When it&#39;s set it turns the op into NULL.</p>

<p>More important, it sets op_opt to 1 by default, even if it has no intention to nullify (&quot;optimize away&quot;) the current op. Any optimization which wants to keep the op needs to unset op_opt.</p>

<pre><code>        void    rpeep(OP* o)</code></pre>

</dd>
<dt id="stash_to_coretype">stash_to_coretype </dt>
<dd>

<p>stash_to_coretype(HV* stash) converts the name of the padname type to the core_types_t enum.</p>

<p>For native types we still return the non-native counterpart. PERL_NATIVE_TYPES is implemented in the native type branch, with escape analysis, upgrading long-enough sequences to native ops in rpeep. core_types_t stash_to_coretype(const HV* stash)</p>

</dd>
</dl>

<h1 id="Compile-time-scope-hooks">Compile-time scope hooks</h1>

<dl>

<dt id="BhkENTRY">BhkENTRY </dt>
<dd>

<p>NOTE: this function is experimental and may change or be removed without notice.</p>

<p>Return an entry from the BHK structure. <code>which</code> is a preprocessor token indicating which entry to return. If the appropriate flag is not set this will return <code>NULL</code>. The type of the return value depends on which entry you ask for.</p>

<pre><code>        void *  BhkENTRY(BHK *hk, which)</code></pre>

</dd>
<dt id="BhkFLAGS">BhkFLAGS </dt>
<dd>

<p>NOTE: this function is experimental and may change or be removed without notice.</p>

<p>Return the BHK&#39;s flags.</p>

<pre><code>        U32     BhkFLAGS(BHK *hk)</code></pre>

</dd>
<dt id="CALL_BLOCK_HOOKS">CALL_BLOCK_HOOKS </dt>
<dd>

<p>NOTE: this function is experimental and may change or be removed without notice.</p>

<p>Call all the registered block hooks for type <code>which</code>. <code>which</code> is a preprocessing token; the type of <code>arg</code> depends on <code>which</code>.</p>

<pre><code>        void    CALL_BLOCK_HOOKS(which, arg)</code></pre>

</dd>
<dt id="fold_constants">fold_constants </dt>
<dd>

<p>Apply constant folding to a scalar at compile-time, via a fake eval. Returns a new op_folded op which replaces the old constant expression, or the old unfolded op.</p>

<pre><code>        OP*     fold_constants(OP * const o)</code></pre>

</dd>
<dt id="gen_constant_list">gen_constant_list </dt>
<dd>

<p>Compile-time expansion of a range list.</p>

<pre><code>  e.g. 0..4 =&gt; 0,1,2,3,4

        OP*     gen_constant_list(OP* o)</code></pre>

</dd>
<dt id="hasterm">hasterm </dt>
<dd>

<p>Adds the field name, padoffset and the field index to the current class.</p>

<pre><code>        OP*     hasterm(OP *o)</code></pre>

</dd>
<dt id="jmaybe">jmaybe </dt>
<dd>

<p>Join list by <code>$;</code>, \034. Adds <code>$;</code>, the $SUBSCRIPT_SEPARATOR before the op list, if there is a list.</p>

<p>If you refer to a hash element as <code>$foo{$x,$y,$z}</code> it really means <code>$foo{join($;, $x, $y, $z)}</code></p>

<pre><code>        OP*     jmaybe(OP *o)</code></pre>

</dd>
<dt id="localize">localize </dt>
<dd>

<p>lex: 0 local 1 my|our|state 2 has OP* localize(OP *o, I32 lex)</p>

</dd>
<dt id="op_integerize">op_integerize </dt>
<dd>

<p>Change the optype to the integer variant, when use integer is in scope.</p>

<pre><code>        OP*     op_integerize(OP *o)</code></pre>

</dd>
<dt id="op_std_init">op_std_init </dt>
<dd>

<p>Fixup all temp. pads: apply scalar context, and allocate missing targs.</p>

<pre><code>        OP*     op_std_init(OP *o)</code></pre>

</dd>
</dl>

<h1 id="Custom-Operators">Custom Operators</h1>

<dl>

<dt id="core_prototype">core_prototype </dt>
<dd>

<p>This function assigns the prototype of the named core function to <code>sv</code>, or to a new mortal SV if <code>sv</code> is <code>NULL</code>. It returns the modified <code>sv</code>, or <code>NULL</code> if the core function has no prototype. <code>code</code> is a code as returned by <code>keyword()</code>. It must not be equal to 0.</p>

<pre><code>        SV *    core_prototype(SV *sv, const char *name,
                               const int code,
                               int * const opnum)</code></pre>

</dd>
<dt id="coresub_op">coresub_op </dt>
<dd>

<p>Provide the coreargs arguments for &amp;CORE::* subroutines, usually with matching ops. coreargssv is either the opnum (as UV) or the name (as PV) of no such op exists. code is the result of <code>keyword()</code>, and maybe negative. See <i>gv.c</i>: <code>S_maybe_add_coresub()</code>.</p>

<pre><code>        OP *    coresub_op(SV *const coreargssv, const int code,
                           const int opnum)</code></pre>

</dd>
<dt id="report_redefined_cv">report_redefined_cv </dt>
<dd>

<p>If a CV is overwritten, warn by whom when use warnings &#39;redefine&#39; is in effect. void report_redefined_cv(const SV *name, const CV *old_cv, SV * const *new_const_svp)</p>

</dd>
</dl>

<h1 id="CV-Manipulation-Functions">CV Manipulation Functions</h1>

<dl>

<dt id="check_type_and_open">check_type_and_open </dt>
<dd>

<p>Return NULL if the file doesn&#39;t exist or isn&#39;t a file; else return PerlIO_openn().</p>

<pre><code>        PerlIO * check_type_and_open(SV *name)</code></pre>

</dd>
<dt id="create_eval_scope">create_eval_scope </dt>
<dd>

<p>NOTE: this function is experimental and may change or be removed without notice.</p>

<p>Common-ish code salvaged from Perl_call_sv and pp_entertry, because it was also needed by Perl_fold_constants. void create_eval_scope(OP *retop, U32 flags)</p>

</dd>
<dt id="delete_eval_scope">delete_eval_scope </dt>
<dd>

<p>NOTE: this function is experimental and may change or be removed without notice.</p>

<p>Common code for Perl_call_sv and Perl_fold_constants, put here to keep it close to the related Perl_create_eval_scope. void delete_eval_scope()</p>

</dd>
<dt id="docatch">docatch </dt>
<dd>

<p>Check for the cases 0 or 3 of cur_env.je_ret, only used inside an eval context.</p>

<p>0 is used as continue inside eval,</p>

<p>3 is used for a die caught by an inner eval - continue inner loop</p>

<p>See <i>cop.h</i>: je_mustcatch, when set at any runlevel to TRUE, means eval ops must establish a local jmpenv to handle exception traps.</p>

<pre><code>        OP*     docatch(Perl_ppaddr_t firstpp)</code></pre>

</dd>
<dt id="doeval_compile">doeval_compile </dt>
<dd>

<p>Compile a require/do or an eval &#39;&#39;.</p>

<p>outside is the lexically enclosing CV (if any) that invoked us. seq is the current COP scope value. hh is the saved hints hash, if any.</p>

<p>Returns a bool indicating whether the compile was successful; if so, PL_eval_start contains the first op of the compiled code; otherwise, pushes undef.</p>

<p>This function is called from two places: pp_require and pp_entereval. These can be distinguished by whether PL_op is entereval.</p>

<pre><code>        bool    doeval_compile(U8 gimme, CV* outside, U32 seq,
                               HV* hh)</code></pre>

</dd>
<dt id="doopen_pm">doopen_pm </dt>
<dd>

<p>doopen_pm(): return the equivalent of PerlIO_openn() on the given name, but first check for bad names (\0) and non-files. Also if the filename ends in .pm and unless PERL_DISABLE_PMC, try loading Foo.pmc first.</p>

<pre><code>        PerlIO * doopen_pm(SV *name, bool do_pmc)</code></pre>

</dd>
<dt id="path_is_searchable">path_is_searchable </dt>
<dd>

<p>require doesn&#39;t search in @INC for absolute names, or when the name is explicitly relative the current directory: i.e. ./, ../ bool path_is_searchable(const char *name)</p>

</dd>
<dt id="require_file">require_file </dt>
<dd>

<p>Handle <code>require Foo::Bar</code>, <code>require &quot;Foo/Bar.pm&quot;</code> and <code>do &quot;Foo.pm&quot;</code>.</p>

<p>The first form will have already been converted at compile time to the second form. OP * require_file(SV *sv)</p>

</dd>
<dt id="require_version">require_version </dt>
<dd>

<p>Implements &#39;require 5.010001&#39;, the version check part of require. OP * require_version(SV *sv)</p>

</dd>
<dt id="try_yyparse">try_yyparse </dt>
<dd>

<p>Run yyparse() in a setjmp wrapper. Returns: 0: yyparse() successful 1: yyparse() failed 3: yyparse() died</p>

<pre><code>        int     try_yyparse(int gramtype)</code></pre>

</dd>
</dl>

<h1 id="CV-reference-counts-and-CvOUTSIDE">CV reference counts and CvOUTSIDE</h1>

<dl>

<dt id="CvWEAKOUTSIDE">CvWEAKOUTSIDE </dt>
<dd>

<p>Each CV has a pointer, <code>CvOUTSIDE()</code>, to its lexically enclosing CV (if any). Because pointers to anonymous sub prototypes are stored in <code>&amp;</code> pad slots, it is a possible to get a circular reference, with the parent pointing to the child and vice-versa. To avoid the ensuing memory leak, we do not increment the reference count of the CV pointed to by <code>CvOUTSIDE</code> in the <i>one specific instance</i> that the parent has a <code>&amp;</code> pad slot pointing back to us. In this case, we set the <code>CvWEAKOUTSIDE</code> flag in the child. This allows us to determine under what circumstances we should decrement the refcount of the parent when freeing the child.</p>

<p>There is a further complication with non-closure anonymous subs (i.e. those that do not refer to any lexicals outside that sub). In this case, the anonymous prototype is shared rather than being cloned. This has the consequence that the parent may be freed while there are still active children, <i>e.g.</i>,</p>

<pre><code>    BEGIN { $a = sub { eval &#39;$x&#39; } }</code></pre>

<p>In this case, the BEGIN is freed immediately after execution since there are no active references to it: the anon sub prototype has <code>CvWEAKOUTSIDE</code> set since it&#39;s not a closure, and $a points to the same CV, so it doesn&#39;t contribute to BEGIN&#39;s refcount either. When $a is executed, the <code>eval &#39;$x&#39;</code> causes the chain of <code>CvOUTSIDE</code>s to be followed, and the freed BEGIN is accessed.</p>

<p>To avoid this, whenever a CV and its associated pad is freed, any <code>&amp;</code> entries in the pad are explicitly removed from the pad, and if the refcount of the pointed-to anon sub is still positive, then that child&#39;s <code>CvOUTSIDE</code> is set to point to its grandparent. This will only occur in the single specific case of a non-closure anon prototype having one or more active references (such as <code>$a</code> above).</p>

<p>One other thing to consider is that a CV may be merely undefined rather than freed, eg <code>undef &amp;foo</code>. In this case, its refcount may not have reached zero, but we still delete its pad and its <code>CvROOT</code> etc. Since various children may still have their <code>CvOUTSIDE</code> pointing at this undefined CV, we keep its own <code>CvOUTSIDE</code> for the time being, so that the chain of lexical scopes is unbroken. For example, the following should print 123:</p>

<pre><code>    my $x = 123;
    sub tmp { sub { eval &#39;$x&#39; } }
    my $a = tmp();
    undef &amp;tmp;
    print  $a-&gt;();

        bool    CvWEAKOUTSIDE(CV *cv)</code></pre>

</dd>
</dl>

<h1 id="Debugging-Utilities">Debugging Utilities</h1>

<dl>

<dt id="append_gv_name">append_gv_name </dt>
<dd>

<p>Append to the out SV the name of the gv.</p>

<pre><code>        void    append_gv_name(GV *gv, SV *out)</code></pre>

</dd>
<dt id="append_padvar">append_padvar </dt>
<dd>

<p>Append to the out SV, the names of the n lexicals starting at offset off in the CV * cv.</p>

<pre><code>        void    append_padvar(PADOFFSET off, CV *cv, SV *out,
                              int n, bool paren,
                              char force_sigil)</code></pre>

</dd>
<dt id="av_dump">av_dump </dt>
<dd>

<p>Dump all the av values. sv_dump dumps only a limited amount of keys.</p>

<p>Only available with <code>-DDEBUGGING</code>.</p>

<pre><code>        void    av_dump(SV* av)</code></pre>

</dd>
<dt id="cop_dump">cop_dump </dt>
<dd>

<p>Dumps a COP, even when it is deleted. Esp. useful for lexical hints in PL_curcop.</p>

<p>With DEBUGGING only. void cop_dump(const OP *o)</p>

</dd>
<dt id="deb_hechain">deb_hechain </dt>
<dd>

<p>NOTE: this function is experimental and may change or be removed without notice.</p>

<p>Print the HE chain.</p>

<p>Only avalaible with <code>-DDEBUGGING</code>.</p>

<pre><code>        void    deb_hechain(HE* entry)</code></pre>

</dd>
<dt id="deb_hek">deb_hek </dt>
<dd>

<p>NOTE: this function is experimental and may change or be removed without notice.</p>

<p>Print the HEK key and value, along with the hash and flags.</p>

<p>Only avalaible with <code>-DDEBUGGING</code>.</p>

<pre><code>        void    deb_hek(HEK* hek, SV* val)</code></pre>

</dd>
<dt id="deb_padvar">deb_padvar </dt>
<dd>

<p>Print the names of the n lexical vars starting at pad offset off.</p>

<pre><code>        void    deb_padvar(PADOFFSET off, int n, bool paren)</code></pre>

</dd>
<dt id="hv_dump">hv_dump </dt>
<dd>

<p>Dump all the hv keys and optionally values. sv_dump dumps only a limited amount of keys.</p>

<p>Only available with <code>-DDEBUGGING</code>.</p>

<pre><code>        void    hv_dump(SV* sv, bool with_values)</code></pre>

</dd>
<dt id="multiconcat_stringify">multiconcat_stringify </dt>
<dd>

<p>Return a temporary SV containing a stringified representation of the op_aux field of a MULTICONCAT op. Note that if the aux contains both plain and utf8 versions of the const string and indices, only the first is displayed.</p>

<pre><code>        SV*     multiconcat_stringify(const OP* o)</code></pre>

</dd>
<dt id="multideref_stringify">multideref_stringify </dt>
<dd>

<p>Return a temporary SV containing a stringified representation of the op_aux field of a MULTIDEREF op, associated with CV cv</p>

<pre><code>        SV*     multideref_stringify(const OP* o, CV *cv)</code></pre>

</dd>
<dt id="sequence_num">sequence_num </dt>
<dd>

<p>Return a unique integer to represent the address of op o. If it already exists in PL_op_sequence, just return it; otherwise add it.</p>

<pre><code> *** Note that this isn&#39;t thread-safe.
        UV      sequence_num(const OP *o)</code></pre>

</dd>
<dt id="signature_stringify">signature_stringify </dt>
<dd>

<p>Return a temporary SV containing a stringified representation of the op_aux field of a SIGNATURE op, associated with CV cv.</p>

<pre><code>        SV*     signature_stringify(const OP* o, CV *cv)</code></pre>

</dd>
</dl>

<h1 id="Embedding-Functions">Embedding Functions</h1>

<dl>

<dt id="cv_clone_padname0">cv_clone_padname0 </dt>
<dd>

<p>NOTE: this function is experimental and may change or be removed without notice.</p>

<p>Clones the first PADNAME slot, just references the other. Called by <a href="#cv_type_set">&quot;cv_type_set&quot;</a> and <a href="#newATTRSUB_x">&quot;newATTRSUB_x&quot;</a> for an extern sub, to set its private return type.</p>

<pre><code>        PADNAMELIST * cv_clone_padname0(CV *cv,
                                        PADNAMELIST *pnl)</code></pre>

</dd>
<dt id="cv_dump">cv_dump </dt>
<dd>

<p>dump the contents of a CV</p>

<pre><code>        void    cv_dump(CV *cv, const char *title)</code></pre>

</dd>
<dt id="cv_forget_slab">cv_forget_slab </dt>
<dd>

<p>When a CV has a reference count on its slab (<code>CvSLABBED</code>), it is responsible for making sure it is freed. (Hence, no two CVs should ever have a reference count on the same slab.) The CV only needs to reference the slab during compilation. Once it is compiled and <code>CvROOT</code> attached, it has finished its job, so it can forget the slab.</p>

<pre><code>        void    cv_forget_slab(CV *cv)</code></pre>

</dd>
<dt id="do_dump_pad">do_dump_pad </dt>
<dd>

<p>Dump the contents of a padlist</p>

<pre><code>        void    do_dump_pad(I32 level, PerlIO *file,
                            PADLIST *padlist, int full)</code></pre>

</dd>
<dt id="open_script">open_script </dt>
<dd>

<pre><code>        PerlIO * open_script(const char *scriptname,
                             bool dosearch, bool *suidscript)</code></pre>

</dd>
<dt id="pad_alloc_name">pad_alloc_name </dt>
<dd>

<p>Allocates a place in the currently-compiling pad (via <a href="/cperl/perlapi.html#pad_alloc">&quot;pad_alloc&quot; in perlapi</a>) and then stores a name for that entry. <code>name</code> is adopted and becomes the name entry; it must already contain the name string. <code>typestash</code> and <code>ourstash</code> and the <code>padadd_STATE</code> flag get added to <code>name</code>. None of the other processing of <a href="/cperl/perlapi.html#pad_add_name_pvn">&quot;pad_add_name_pvn&quot; in perlapi</a> is done. Returns the offset of the allocated pad slot.</p>

<pre><code>        PADOFFSET pad_alloc_name(PADNAME *name, U32 flags,
                                 HV *typestash, HV *ourstash)</code></pre>

</dd>
<dt id="pad_block_start">pad_block_start </dt>
<dd>

<p>Update the pad compilation state variables on entry to a new block.</p>

<pre><code>        void    pad_block_start(int full)</code></pre>

</dd>
<dt id="pad_check_dup">pad_check_dup </dt>
<dd>

<p>Check for shadow warnings, duplicate declarations. Report any of:</p>

<pre><code>     * a &#39;my&#39; in the current scope with the same name;
     * an &#39;our&#39; (anywhere in the pad) with the same name and the
       same stash as &#39;ourstash&#39;</code></pre>

<p><code>is_our</code> indicates that the name to check is an <code>&quot;our&quot;</code> declaration.</p>

<pre><code>        void    pad_check_dup(PADNAME *name, U32 flags,
                              const HV *ourstash)</code></pre>

</dd>
<dt id="pad_findlex">pad_findlex </dt>
<dd>

<p>Find a named lexical anywhere in a chain of nested pads. Add fake entries in the inner pads if it&#39;s found in an outer one.</p>

<p>Returns the offset in the bottom pad of the lex or the fake lex. <code>cv</code> is the CV in which to start the search, and seq is the current <code>cop_seq</code> to match against. If <code>warn</code> is true, print appropriate warnings. The <code>out_</code>* vars return values, and so are pointers to where the returned values should be stored. <code>out_capture</code>, if non-null, requests that the innermost instance of the lexical is captured; <code>out_name</code> is set to the innermost matched pad name or fake pad name; <code>out_flags</code> returns the flags normally associated with the <code>PARENT_FAKELEX_FLAGS</code> field of a fake pad name.</p>

<p>Note that <code>pad_findlex()</code> is recursive; it recurses up the chain of CVs, then comes back down, adding fake entries as it goes. It has to be this way because fake names in anon protoypes have to store in <code>xpadn_low</code> the index into the parent pad.</p>

<p>With cperl all PADs are UTF8 so the flags argument must be either 0 or padadd_STALEOK.</p>

<pre><code>        PADOFFSET pad_findlex(const char *namepv,
                              STRLEN namelen, U32 flags,
                              const CV* cv, U32 seq, int warn,
                              SV** out_capture,
                              PADNAME** out_name,
                              int *out_flags)</code></pre>

</dd>
<dt id="pad_find_outeroffset">pad_find_outeroffset </dt>
<dd>

<p>Search the real pad offset in one of the outer CVs for the fake pad entry in the current CV, usually the <code>PL_compcv</code>. See <a href="/cperl/perlapi.html#pad_findmy_real">&quot;pad_findmy_real&quot; in perlapi</a>.</p>

<pre><code>        PADOFFSET pad_find_outeroffset(PADNAME *pn, CV* cv)</code></pre>

</dd>
<dt id="pad_fixup_inner_anons">pad_fixup_inner_anons </dt>
<dd>

<p>For any anon CVs in the pad, change <code>CvOUTSIDE</code> of that CV from <code>old_cv</code> to <code>new_cv</code> if necessary. Needed when a newly-compiled CV has to be moved to a pre-existing CV struct.</p>

<pre><code>        void    pad_fixup_inner_anons(PADLIST *padlist,
                                      CV *old_cv, CV *new_cv)</code></pre>

</dd>
<dt id="pad_free">pad_free </dt>
<dd>

<p>Free the SV at offset po in the current pad.</p>

<pre><code>        void    pad_free(PADOFFSET po)</code></pre>

</dd>
<dt id="pad_leavemy">pad_leavemy </dt>
<dd>

<p>Cleanup at end of scope during compilation: set the max seq number for lexicals in this scope and warn of any lexicals that never got introduced.</p>

<pre><code>        void    pad_leavemy()</code></pre>

</dd>
<dt id="padlist_dup">padlist_dup </dt>
<dd>

<p>Duplicates a pad.</p>

<pre><code>        PADLIST * padlist_dup(PADLIST *srcpad,
                              CLONE_PARAMS *param)</code></pre>

</dd>
<dt id="padname_dup">padname_dup </dt>
<dd>

<p>Duplicates a pad name.</p>

<pre><code>        PADNAME * padname_dup(PADNAME *src, CLONE_PARAMS *param)</code></pre>

</dd>
<dt id="padnamelist_dup">padnamelist_dup </dt>
<dd>

<p>Duplicates a pad name list.</p>

<pre><code>        PADNAMELIST * padnamelist_dup(PADNAMELIST *srcpad,
                                      CLONE_PARAMS *param)</code></pre>

</dd>
<dt id="pad_push">pad_push </dt>
<dd>

<p>Push a new pad frame onto the padlist, unless there&#39;s already a pad at this depth, in which case don&#39;t bother creating a new one. Then give the new pad an <code>@_</code> in slot zero.</p>

<pre><code>        void    pad_push(PADLIST *padlist, int depth)</code></pre>

</dd>
<dt id="pad_reset">pad_reset </dt>
<dd>

<p>Mark all the current temporaries for reuse</p>

<pre><code>        void    pad_reset()</code></pre>

</dd>
<dt id="pad_swipe">pad_swipe </dt>
<dd>

<p>Abandon the tmp in the current pad at offset <code>po</code> and replace with a new one.</p>

<pre><code>        void    pad_swipe(PADOFFSET po, bool refadjust)</code></pre>

</dd>
</dl>

<h1 id="Functions-in-file-inline.h">Functions in file inline.h</h1>

<dl>

<dt id="strip_spaces">strip_spaces </dt>
<dd>

<p>CvPROTO returns the prototype as stored, which is not necessarily what the interpreter should be using. Specifically, the interpreter assumes that spaces have been stripped, which has been the case if the prototype was added by toke.c, but is generally not the case if it was added elsewhere.</p>

<p>Since we can&#39;t enforce the spacelessness at assignment time, this routine provides a temporary copy of the string at parse time with spaces removed. <i>orig</i> is the start of the original string, <i>len</i> is the length of the string and will be updated when this returns.</p>

<pre><code>        char*   strip_spaces(const char * orig,
                             STRLEN * const len)</code></pre>

</dd>
</dl>

<h1 id="Functions-in-file-op.c">Functions in file op.c</h1>

<dl>

<dt id="new_slab">new_slab </dt>
<dd>

<p>Creates a new memory region, a slab, for ops, with room for sz pointers. sz starts with PERL_SLAB_SIZE (=64) and is then extended by factor two in Slab_Alloc().</p>

<pre><code>                new_slab;</code></pre>

</dd>
<dt id="no_fh_allowed">no_fh_allowed </dt>
<dd>

<p>Throws a parser error: Missing comma after first argument to %s function for an op which does not take an optional comma-less filehandle argument. i.e. not <code>print $fh arg</code>, rather <code>call $fh, $arg</code>.</p>

<pre><code>                no_fh_allowed;</code></pre>

</dd>
<dt id="op_next_nn">op_next_nn </dt>
<dd>

<p>Returns the next non-NULL op, skipping all NULL ops in the chain.</p>

<pre><code>        OP*     op_next_nn</code></pre>

</dd>
<dt id="op_prevstart_nn">op_prevstart_nn </dt>
<dd>

<p>Returns the previous op, pointing via OpNEXT to us. Walks down the CvSTART until it finds us.</p>

<pre><code>        OP*     op_prevstart_nn</code></pre>

</dd>
<dt id="op_prev_nn">op_prev_nn </dt>
<dd>

<p>Returns the previous sibling or parent op, pointing via OpSIBLNG or OpFIRST to us. Walks the the siblings until the parent, and then descent again to the kids until it finds us.</p>

<pre><code>        OP*     op_prev_nn</code></pre>

</dd>
<dt id="opslab_force_free">opslab_force_free </dt>
<dd>

<p>Forcefully frees the slab area, even if there are still live OPs in it. Frees all the containing OPs. Like opslab_free(), but first calls op_free() on any ops in the slab not marked as OP_FREED.</p>

<p>NOTE: the perl_ form of this function is deprecated.</p>

<pre><code>        void    opslab_force_free(OPSLAB *slab)</code></pre>

</dd>
<dt id="opslab_free">opslab_free </dt>
<dd>

<p>Free a chain of OP slabs. Should only be called after all ops contained in it have been freed. At this point, its reference count should be 1, because OpslabREFCNT_dec() skips doing rc-- when it detects that rc == 1, and just directly calls opslab_free(). (Note that the reference count which PL_compcv held on the slab should have been removed once compilation of the sub was complete).</p>

<p>NOTE: the perl_ form of this function is deprecated.</p>

<pre><code>        void    opslab_free(OPSLAB *slab)</code></pre>

</dd>
<dt id="opslab_free_nopad">opslab_free_nopad </dt>
<dd>

<p>Frees the slab area, embedded into temporary disabling PL_comppad.</p>

<p>NOTE: the perl_ form of this function is deprecated.</p>

<pre><code>        void    opslab_free_nopad(OPSLAB *slab)</code></pre>

</dd>
<dt id="prune_chain_head">prune_chain_head </dt>
<dd>

<p>remove any leading &quot;empty&quot; ops from the op_next chain whose first node&#39;s address is stored in op_p. Store the updated address of the first node in op_p.</p>

<pre><code>                prune_chain_head;</code></pre>

</dd>
<dt id="Slab_Alloc">Slab_Alloc </dt>
<dd>

<p>Creates a new memory region, a slab, for some ops, with room for sz pointers. sz starts with PERL_SLAB_SIZE (=64) and is then extended by factor two. If PL_compcv isn&#39;t compiling, malloc() instead.</p>

<p>NOTE: the perl_ form of this function is deprecated.</p>

<pre><code>        void*   Slab_Alloc(size_t sz)</code></pre>

</dd>
<dt id="Slab_Free">Slab_Free </dt>
<dd>

<p>Free memory for the slabbed op.</p>

<p>NOTE: the perl_ form of this function is deprecated.</p>

<pre><code>        void    Slab_Free(void *op)</code></pre>

</dd>
<dt id="typename">typename </dt>
<dd>

<p>Returns the sanitized typename of the stash of the padname type, without main:: prefix.</p>

<pre><code>                typename;</code></pre>

</dd>
</dl>

<h1 id="Functions-in-file-pp.c">Functions in file pp.c</h1>

<dl>

<dt id="softref2xv">softref2xv </dt>
<dd>

<p>Helper function for pp_rv2sv and pp_rv2av. Interns the string to a symbol.</p>

<p>Optionally also consumes the local stackptr pointing to the sv (*spp[0] == sv) to use a subsequent LVAL NULL kid in the calling rv2sv.</p>

<p>Note: sv might change. Get it with GvSV of the result afterwards.</p>

<pre><code>        GV*     softref2xv(SV *sv, const char *const what,
                           const svtype type, SV ***spp)</code></pre>

</dd>
</dl>

<h1 id="Functions-in-file-regcomp.c">Functions in file regcomp.c</h1>

<dl>

<dt id="regprop">regprop </dt>
<dd>

<p>printable representation of opcode, with run time support void regprop(const regexp *prog, SV* sv, const regnode* o, const regmatch_info *reginfo, const RExC_state_t *pRExC_state)</p>

</dd>
<dt id="reg_temp_copy">reg_temp_copy </dt>
<dd>

<p>Copy ssv to dsv, both of which should of type SVt_REGEXP or SVt_PVLV, except that dsv will be created if NULL.</p>

<p>This function is used in two main ways. First to implement</p>

<pre><code>    $r = qr/....; $s = $$r;</code></pre>

<p>Secondly, it is used as a hacky workaround to the structural issue of match results being stored in the regexp structure which is in turn stored in <code>PL_curpm</code>/<code>PL_reg_curpm</code>. The problem is that due to <code>qr//</code> the pattern could be <code>PL_curpm</code> in multiple contexts, and could require multiple result sets being associated with the pattern simultaneously, such as when doing a recursive match with <code>(??{$qr})</code></p>

<p>The solution is to make a lightweight copy of the regexp structure when a <code>qr//</code> is returned from the code executed by <code>(??{$qr})</code> this lightweight copy doesn&#39;t actually own any of its data except for the starp/end and the actual regexp structure itself.</p>

<p>NOTE: the perl_ form of this function is deprecated.</p>

<pre><code>        REGEXP* reg_temp_copy(REGEXP* dsv, REGEXP* ssv)</code></pre>

</dd>
</dl>

<h1 id="GV-Functions">GV Functions</h1>

<dl>

<dt id="gv_magicalize">gv_magicalize </dt>
<dd>

<pre><code>                     |STRLEN len|const svtype sv_type

 * gv_magicalize() is called by gv_fetchpvn_flags when creating
 * a new GV, gv is NN.
 * Note that it does not insert the GV into the stash prior to
 * magicalization, which some variables require need in order
 * to work (like %+, %-, %!), so callers must take care of
 * that.
 * 
 * It returns true if the gv did turn out to be magical one; i.e.,
 * if gv_magicalize actually did something.
 */
PERL_STATIC_INLINE bool
S_gv_magicalize(pTHX_ GV *gv, HV *stash, const char *name, STRLEN len,
                      const svtype sv_type)
{
    I32 paren;

    PERL_ARGS_ASSERT_GV_MAGICALIZE;
    
    if (stash != PL_defstash) { /* not the main stash */
        /* We only have to check for a few names here: a, b, EXPORT*, ISA
           and VERSION. All the others apply only to the main stash or to
           CORE (which is checked right after this). */
        if (len) {
            switch (*name) {
            case &#39;E&#39;:
                if (
                    len &gt;= 6 &amp;&amp; name[1] == &#39;X&#39; &amp;&amp;
                    (memEQs(name, len, &quot;EXPORT&quot;)
                    ||memEQs(name, len, &quot;EXPORT_OK&quot;)
                    ||memEQs(name, len, &quot;EXPORT_FAIL&quot;)
                    ||memEQs(name, len, &quot;EXPORT_TAGS&quot;))
                )
                    GvMULTI_on(gv);
                break;
            case &#39;I&#39;:
                if (memEQs(name, len, &quot;ISA&quot;))
                    gv_magicalize_isa(gv);
                break;
            case &#39;V&#39;:
                if (memEQs(name, len, &quot;VERSION&quot;))
                    GvMULTI_on(gv);
                break;
            case &#39;a&#39;:
                if (stash == PL_debstash &amp;&amp; len==4 &amp;&amp; memEQc(name,&quot;args&quot;)) {
                    GvMULTI_on(gv_AVadd(gv));
                    break;
                }
                /* FALLTHROUGH for a */
            case &#39;b&#39;:
                if (len == 1 &amp;&amp; sv_type == SVt_PV)
                    GvMULTI_on(gv);
                /* FALLTHROUGH */
            default:
                goto try_core;
            }
            goto ret;
        }
      try_core:
        if (len &gt; 1 /* shortest is uc */ &amp;&amp; HvNAMELEN_get(stash) == 4) {
            /* Avoid null warning: */
            const char * const stashname = HvNAME(stash); assert(stashname);
            if (memEQc(stashname, &quot;CORE&quot;))
                S_maybe_add_coresub(aTHX_ 0, gv, name, len);
        }
    }
    else if (len &gt; 1) {
#ifndef EBCDIC
        if (*name &gt; &#39;V&#39; ) {
            NOOP;
            /* Nothing else to do.
               The compiler will probably turn the switch statement into a
               branch table. Make sure we avoid even that small overhead for
               the common case of lower case variable names.  (On EBCDIC
               platforms, we can&#39;t just do:
                 if (NATIVE_TO_ASCII(*name) &gt; NATIVE_TO_ASCII(&#39;V&#39;) ) {
               because cases like &#39;\027&#39; in the switch statement below are
               C1 (non-ASCII) controls on those platforms, so the remapping
               would make them larger than &#39;V&#39;)
             */
        } else
#endif
        {
            switch (*name) {
            case &#39;A&#39;:
                if (strEQc(name, &quot;ARGV&quot;))
                    IoFLAGS(GvIOn_NN(gv)) |= IOf_ARGV|IOf_START;
                else if (strEQc(name, &quot;ARGVOUT&quot;))
                    GvMULTI_on(gv);
                break;
            case &#39;E&#39;:
                if (
                    len &gt;= 6 &amp;&amp; name[1] == &#39;X&#39; &amp;&amp;
                    (memEQs(name, len, &quot;EXPORT&quot;)
                    ||memEQs(name, len, &quot;EXPORT_OK&quot;)
                    ||memEQs(name, len, &quot;EXPORT_FAIL&quot;)
                    ||memEQs(name, len, &quot;EXPORT_TAGS&quot;))
                )
                    GvMULTI_on(gv);
                break;
            case &#39;I&#39;:
                if (strEQc(name, &quot;ISA&quot;)) {
                    gv_magicalize_isa(gv);
                }
                break;
            case &#39;S&#39;:
                if (strEQc(name, &quot;SIG&quot;)) {
                    HV *hv;
                    I32 i;
                    if (!PL_psig_name) {
                        Newxz(PL_psig_name, 2 * SIG_SIZE, SV*);
                        Newxz(PL_psig_pend, SIG_SIZE, int);
                        PL_psig_ptr = PL_psig_name + SIG_SIZE;
                    } else {
                        /* I think that the only way to get here is to re-use an
                           embedded perl interpreter, where the previous
                           use didn&#39;t clean up fully because
                           PL_perl_destruct_level was 0. I&#39;m not sure that we
                           &quot;support&quot; that, in that I suspect in that scenario
                           there are sufficient other garbage values left in the
                           interpreter structure that something else will crash
                           before we get here. I suspect that this is one of
                           those &quot;doctor, it hurts when I do this&quot; bugs.  */
                        Zero(PL_psig_name, 2 * SIG_SIZE, SV*);
                        Zero(PL_psig_pend, SIG_SIZE, int);
                    }
                    GvMULTI_on(gv);
                    hv = GvHVn(gv);
                    hv_magic(hv, NULL, PERL_MAGIC_sig);
                    for (i = 1; i &lt; SIG_SIZE; i++) {
                        SV * const * const init
                            = hv_fetch_ifexists(hv, PL_sig_name[i], strlen(PL_sig_name[i]), 1);
                        if (init)
                            sv_setsv(*init, UNDEF);
                    }
                }
                break;
            case &#39;V&#39;:
                if (strEQc(name, &quot;VERSION&quot;))
                    GvMULTI_on(gv);
                break;
            case &#39;\003&#39;:        /* $^CHILD_ERROR_NATIVE */
                if (strEQc(name, &quot;\003HILD_ERROR_NATIVE&quot;))
                    goto magicalize;
                                /* @{^CAPTURE} %{^CAPTURE} */
                if (memEQs(name, len, &quot;\003APTURE&quot;)) {
                    AV* const av = GvAVn(gv);
                    const Size_t n = *name;

                    sv_magic(MUTABLE_SV(av), (SV*)n, PERL_MAGIC_regdata, NULL, 0);
                    SvREADONLY_on(av);

                    if (sv_type == SVt_PVHV || sv_type == SVt_PVGV)
                        require_tie_mod_s(gv, &#39;-&#39;, &quot;Tie::Hash::NamedCapture&quot;,0);

                } else          /* %{^CAPTURE_ALL} */
                if (memEQs(name, len, &quot;\003APTURE_ALL&quot;)) {
                    if (sv_type == SVt_PVHV || sv_type == SVt_PVGV)
                        require_tie_mod_s(gv, &#39;+&#39;, &quot;Tie::Hash::NamedCapture&quot;,0);
                }
                break;
            case &#39;\005&#39;:        /* $^ENCODING */
                if (strEQc(name, &quot;\005NCODING&quot;))
                    goto magicalize;
                if (strEQc(name, &quot;\005_NCODING&quot;))
                    goto magicalize;
                break;
            case &#39;\007&#39;:        /* $^GLOBAL_PHASE */
                if (strEQc(name, &quot;\007LOBAL_PHASE&quot;))
                    goto ro_magicalize;
                break;
            case &#39;\014&#39;:        /* $^LAST_FH */
                if (strEQc(name, &quot;\014AST_FH&quot;))
                    goto ro_magicalize;
                break;
            case &#39;\015&#39;:        /* $^MATCH */
                if (strEQc(name, &quot;\015ATCH&quot;)) {
                    paren = RX_BUFF_IDX_CARET_FULLMATCH;
                    goto storeparen;
                }
                break;
            case &#39;\017&#39;:        /* $^OPEN */
                if (strEQc(name, &quot;\017PEN&quot;))
                    goto magicalize;
                break;
            case &#39;\020&#39;:        /* $^PREMATCH  $^POSTMATCH */
                if (strEQc(name, &quot;\020REMATCH&quot;)) {
                    paren = RX_BUFF_IDX_CARET_PREMATCH;
                    goto storeparen;
                }
                if (strEQc(name, &quot;\020OSTMATCH&quot;)) {
                    paren = RX_BUFF_IDX_CARET_POSTMATCH;
                    goto storeparen;
                }
                break;
            case &#39;\023&#39;:
                if (memEQs(name, len, &quot;\023AFE_LOCALES&quot;))
                    goto ro_magicalize;
                break;
            case &#39;\024&#39;:        /* ${^TAINT} */
                if (strEQc(name, &quot;\024AINT&quot;))
                    goto ro_magicalize;
                break;
            case &#39;\025&#39;:        /* ${^UNICODE}, ${^UTF8LOCALE} */
                if (strEQc(name, &quot;\025NICODE&quot;))
                    goto ro_magicalize;
                if (strEQc(name, &quot;\025TF8LOCALE&quot;))
                    goto ro_magicalize;
                if (strEQc(name, &quot;\025TF8CACHE&quot;))
                    goto magicalize;
                break;
            case &#39;\027&#39;:        /* $^WARNING_BITS */
                if (strEQc(name, &quot;\027ARNING_BITS&quot;))
                    goto magicalize;
#ifdef WIN32
                else if (strEQc(name, &quot;\025IN32_SLOPPY_STAT&quot;))
                    goto magicalize;
#endif
                break;
            case &#39;1&#39;:
            case &#39;2&#39;:
            case &#39;3&#39;:
            case &#39;4&#39;:
            case &#39;5&#39;:
            case &#39;6&#39;:
            case &#39;7&#39;:
            case &#39;8&#39;:
            case &#39;9&#39;:
                {
                    /* Ensures that we have an all-digit variable, ${&quot;1foo&quot;} fails
                       this test  */
                    UV uv;
                    if (!grok_atoUV(name, &amp;uv, NULL))
                        goto ret;
                    if (UNLIKELY(uv &gt; I32_MAX))
                        Perl_croak(aTHX_ &quot;panic: gv name too long (%&quot; UVuf &quot;)&quot;, uv);
                    paren = (I32)uv;
                    goto storeparen;
                }
            }
        }
    } else {
        /* Names of length 1.  (Or 0. But name is NUL terminated, so that will
           be case &#39;\0&#39; in this switch statement (ie a default case)  */
        switch (*name) {
        case &#39;&amp;&#39;:               /* $&amp; */
            paren = RX_BUFF_IDX_FULLMATCH;
            goto sawampersand;
        case &#39;`&#39;:               /* $` */
            paren = RX_BUFF_IDX_PREMATCH;
            goto sawampersand;
        case &#39;\&#39;&#39;:              /* $&#39; */
            paren = RX_BUFF_IDX_POSTMATCH;
        sawampersand:
#ifdef PERL_SAWAMPERSAND
            if (!(
                sv_type == SVt_PVAV ||
                sv_type == SVt_PVHV ||
                sv_type == SVt_PVCV ||
                sv_type == SVt_PVFM ||
                sv_type == SVt_PVIO
                )) { PL_sawampersand |=
                        (*name == &#39;`&#39;)
                            ? SAWAMPERSAND_LEFT
                            : (*name == &#39;&amp;&#39;)
                                ? SAWAMPERSAND_MIDDLE
                                : SAWAMPERSAND_RIGHT;
                }
#endif
            goto storeparen;
        case &#39;1&#39;:               /* $1 */
        case &#39;2&#39;:               /* $2 */
        case &#39;3&#39;:               /* $3 */
        case &#39;4&#39;:               /* $4 */
        case &#39;5&#39;:               /* $5 */
        case &#39;6&#39;:               /* $6 */
        case &#39;7&#39;:               /* $7 */
        case &#39;8&#39;:               /* $8 */
        case &#39;9&#39;:               /* $9 */
            paren = *name - &#39;0&#39;;

        storeparen:
            /* Flag the capture variables with a NULL mg_ptr
               Use mg_len for the array index to lookup.  */
            sv_magic(GvSVn(gv), MUTABLE_SV(gv), PERL_MAGIC_sv, NULL, paren);
            break;

        case &#39;:&#39;:               /* $: */
            sv_setpv(GvSVn(gv),PL_chopset);
            goto magicalize;

        case &#39;?&#39;:               /* $? */
#ifdef COMPLEX_STATUS
            SvUPGRADE(GvSVn(gv), SVt_PVLV);
#endif
            goto magicalize;

        case &#39;!&#39;:               /* $! */
            GvMULTI_on(gv);
            /* If %! has been used, automatically load Errno.pm. */

            sv_magic(GvSVn(gv), MUTABLE_SV(gv), PERL_MAGIC_sv, name, len);

            /* magicalization must be done before require_tie_mod_s is called */
            if (sv_type == SVt_PVHV || sv_type == SVt_PVGV)
                require_tie_mod_s(gv, &#39;!&#39;, &quot;Errno&quot;, 1);

            break;
        case &#39;-&#39;:               /* $-, %-, @- */
        case &#39;+&#39;:               /* $+, %+, @+ */
            GvMULTI_on(gv); /* no used once warnings here */
            {   /* $- $+ */
                sv_magic(GvSVn(gv), MUTABLE_SV(gv), PERL_MAGIC_sv, name, len);
                if (*name == &#39;+&#39;)
                    SvREADONLY_on(GvSVn(gv));
            }
            {   /* %- %+ */
                if (sv_type == SVt_PVHV || sv_type == SVt_PVGV)
                    require_tie_mod_s(gv, *name, &quot;Tie::Hash::NamedCapture&quot;,0);
            }
            {   /* @- @+ */
                AV* const av = GvAVn(gv);
                const Size_t n = *name;

                sv_magic(MUTABLE_SV(av), (SV*)n, PERL_MAGIC_regdata, NULL, 0);
                SvREADONLY_on(av);
            }
            break;
        case &#39;*&#39;:               /* $* */
        case &#39;#&#39;:               /* $# */
            if (sv_type == SVt_PV)
                /* diag_listed_as: $* is no longer supported as of Perl 5.30 */
                Perl_croak(aTHX_ &quot;$%c is no longer supported as of Perl 5.30&quot;, *name);
            break;
        case &#39;\010&#39;:    /* $^H */
            {
                HV *const hv = GvHVn(gv);
                hv_magic(hv, NULL, PERL_MAGIC_hints);
            }
            goto magicalize;
        case &#39;\023&#39;:    /* $^S */
        ro_magicalize:
            SvREADONLY_on(GvSVn(gv));
            /* FALLTHROUGH */
        case &#39;0&#39;:               /* $0 */
        case &#39;^&#39;:               /* $^ */
        case &#39;~&#39;:               /* $~ */
        case &#39;=&#39;:               /* $= */
        case &#39;%&#39;:               /* $% */
        case &#39;.&#39;:               /* $. */
        case &#39;(&#39;:               /* $( */
        case &#39;)&#39;:               /* $) */
        case &#39;&lt;&#39;:               /* $&lt; */
        case &#39;&gt;&#39;:               /* $&gt; */
        case &#39;\\&#39;:              /* $\ */
        case &#39;/&#39;:               /* $/ */
        case &#39;|&#39;:               /* $| */
        case &#39;$&#39;:               /* $$ */
        case &#39;[&#39;:               /* $[ */
        case &#39;\001&#39;:    /* $^A */
        case &#39;\003&#39;:    /* $^C */
        case &#39;\004&#39;:    /* $^D */
        case &#39;\005&#39;:    /* $^E */
        case &#39;\006&#39;:    /* $^F */
        case &#39;\011&#39;:    /* $^I, NOT \t in EBCDIC */
        case &#39;\016&#39;:    /* $^N */
        case &#39;\017&#39;:    /* $^O */
        case &#39;\020&#39;:    /* $^P */
        case &#39;\024&#39;:    /* $^T */
        case &#39;\027&#39;:    /* $^W */
        magicalize:
            sv_magic(GvSVn(gv), MUTABLE_SV(gv), PERL_MAGIC_sv, name, len);
            break;

        case &#39;\014&#39;:    /* $^L */
            sv_setpvs(GvSVn(gv),&quot;\f&quot;);
            break;
        case &#39;;&#39;:               /* $; */
            sv_setpvs(GvSVn(gv),&quot;\034&quot;);
            break;
        case &#39;]&#39;:               /* $] */
        {
            SV * const sv = GvSV(gv);
            if (!sv_derived_from(PL_patchlevel, &quot;version&quot;))
                upg_version(PL_patchlevel, TRUE);
            GvSV(gv) = vnumify(PL_patchlevel);
            SvREADONLY_on(GvSV(gv));
            SvREFCNT_dec(sv);
        }
        break;
        case &#39;\026&#39;:    /* $^V */
        {
            SV * const sv = GvSV(gv);
            GvSV(gv) = new_version(PL_patchlevel);
            SvREADONLY_on(GvSV(gv));
            SvREFCNT_dec(sv);
        }
        break;
        case &#39;a&#39;:
        case &#39;b&#39;:
            if (sv_type == SVt_PV)
                GvMULTI_on(gv);
        }
    }

   ret:
    /* Return true if we actually did something.  */
    {
        const GP* const gp = GvGP(gv);
        return gp-&gt;gp_av || gp-&gt;gp_hv || gp-&gt;gp_io || gp-&gt;gp_cv
            || ( gp-&gt;gp_sv &amp;&amp; (SvOK(gp-&gt;gp_sv) || SvMAGICAL(gp-&gt;gp_sv)));
    }
}</code></pre>

<p>/* If we do ever start using this later on in the file, we need to make sure we don&rsquo;t accidentally use the wrong definition. */ #undef SvREADONLY_on</p>

<p>/* This function is called when the stash already holds the GV of the magic * variable we&#39;re looking for, but we need to check that it has the correct * kind of magic. For example, if someone first uses $! and then %!, the * latter would end up here, and we add the Errno tie to the HASH slot of * the *! glob. */ PERL_STATIC_INLINE void S_maybe_multimagic_gv(pTHX_ GV *gv, const char *name, const svtype sv_type) { PERL_ARGS_ASSERT_MAYBE_MULTIMAGIC_GV;</p>

<pre><code>    if (sv_type == SVt_PVHV || sv_type == SVt_PVGV) {
        if (*name == &#39;!&#39;)
            require_tie_mod_s(gv, &#39;!&#39;, &quot;Errno&quot;, 1);
        else if (*name == &#39;-&#39; || *name == &#39;+&#39;)
            require_tie_mod_s(gv, *name, &quot;Tie::Hash::NamedCapture&quot;, 0);
    } else if (sv_type == SVt_PV) {
        if (*name == &#39;*&#39; || *name == &#39;#&#39;) {
            /* diag_listed_as: $* is no longer supported as of Perl 5.30 */
            Perl_croak(aTHX_ &quot;$%c is no longer supported as of Perl 5.30&quot;, *name);
        }
    }
    if (sv_type==SVt_PV || sv_type==SVt_PVGV) {
      switch (*name) {
#ifdef PERL_SAWAMPERSAND
      case &#39;`&#39;:
          PL_sawampersand |= SAWAMPERSAND_LEFT;
          (void)GvSVn(gv);
          break;
      case &#39;&amp;&#39;:
          PL_sawampersand |= SAWAMPERSAND_MIDDLE;
          (void)GvSVn(gv);
          break;
      case &#39;\&#39;&#39;:
          PL_sawampersand |= SAWAMPERSAND_RIGHT;
          (void)GvSVn(gv);
          break;
#endif
      }
    }
}</code></pre>

<p>GV * Perl_gv_fetchpvn_flags(pTHX_ const char *nambeg, STRLEN full_len, I32 flags, const svtype sv_type) { const char *name = nambeg; const char *const name_end = nambeg + full_len; GV *gv = NULL; GV**gvp; HV *stash = NULL; char *hvname; STRLEN len; const I32 no_init = flags &amp; (GV_NOADD_NOINIT | GV_NOINIT); const I32 no_expand = flags &amp; GV_NOEXPAND; const I32 add = flags &amp; ~GV_NOADD_MASK; const U32 is_utf8 = flags &amp; SVf_UTF8; U32 faking_it; bool addmg = cBOOL(flags &amp; GV_ADDMG);</p>

<pre><code>    PERL_ARGS_ASSERT_GV_FETCHPVN_FLAGS;
    PERL_DTRACE_PROBE_GLOB_ENTRY(PERL_DTRACE_GLOB_MODE_FETCH, name);

     /* If we have GV_NOTQUAL, the caller promised that
      * there is no stash, so we can skip the check.
      * Similarly if full_len is 0, since then we&#39;re
      * dealing with something like *{&quot;&quot;} or &quot;&quot;-&gt;foo()
      */
    if ((flags &amp; GV_NOTQUAL) || !full_len)
        len = full_len;
    else if (parse_gv_stash_name(&amp;stash, &amp;gv, &amp;name, &amp;len, nambeg, full_len, is_utf8, add)) {
        if (name == name_end) return gv;
    }
    else
        return NULL;

    if (!stash &amp;&amp; !find_default_stash(&amp;stash, name, len, is_utf8, add, sv_type))
        return NULL;
    if (SvTYPE(stash) != SVt_PVHV)
        return NULL;
    
    /* By this point we should have a stash and a name */
    /* On protected stashes and !add we might need to try exists first */
    /*
    if (SvREADONLY(stash) &amp;&amp; !add &amp;&amp; !hv_exists(stash, name, is_utf8 ? -(I32)len : (I32)len)) {
        if (addmg) gv = (GV *)newSV(0);
        else return NULL;
    }
    */
    gvp = (GV**)hv_fetch(stash, name, is_utf8 ? -(I32)len : (I32)len, add);
    if (!gvp || *gvp == (const GV *)UNDEF) {
        if (addmg) gv = (GV *)newSV(0);
        else return NULL;
    }
    else gv = *gvp, addmg = 0;
    /* From this point on, addmg means gv has not been inserted in the
       symtab yet. */

    /* Check if a sub shadows a package. Skip UNIVERSAL::isa.
       TODO: Only if a method is called in this package.
             Or if the package contains a method.
     */
    if (sv_type == SVt_PVCV
        &amp;&amp; add
        &amp;&amp; ckWARN(WARN_SHADOW)
        &amp;&amp; stash != PL_defstash         /* allow &amp;main */
        &amp;&amp; stash != PL_debstash         /* and &amp;DB */
        &amp;&amp; (hvname = HvNAME(stash))
        &amp;&amp; strNEc(hvname, &quot;UNIVERSAL&quot;)) /* and &amp;UNIVERSAL::* */
    {
        char *stashname;
        char tmpbuf[1024];
        int stashname_is_dyn = 0;
        if (UNLIKELY(len &gt;= sizeof(tmpbuf)-3)) {
            stashname_is_dyn = 1;
            Newx(stashname, len+3, char);
            assert(stashname);
        } else {
            stashname = tmpbuf;
        }
        Copy(name, stashname, len, char);
        stashname[len]   = &#39;:&#39;;
        stashname[len+1] = &#39;:&#39;;
        stashname[len+2] = 0;
        if (hv_fetch(stash, stashname, is_utf8 ? -(I32)(len+2) : (I32)len+2, 0)) {
            /* diag_listed_as: Subroutine &amp;%s::%s masks existing package %s */
            Perl_warner(aTHX_ packWARN(WARN_SHADOW),
                        &quot;Subroutine &amp;%s::%s masks existing package %s::%s&quot;,
                        hvname, name, hvname, name);
        }
        if (UNLIKELY(stashname_is_dyn))
            free (stashname);
    }

    if (SvTYPE(gv) == SVt_PVGV) {
        /* The GV already exists, so return it, but check if we need to do
         * anything else with it before that.
         */
        if (add) {
            /* This is the heuristic that handles if a variable triggers the
             * &#39;used only once&#39; warning.  If there&#39;s already a GV in the stash
             * with this name, then we assume that the variable has been used
             * before and turn its MULTI flag on.
             * It&#39;s a heuristic because it can easily be &quot;tricked&quot;, like with
             * BEGIN { $a = 1; $::{foo} = *a }; () = $foo
             * not warning about $main::foo being used just once
             */
            GvMULTI_on(gv);
            gv_init_svtype(gv, sv_type);
            /* You reach this path once the typeglob has already been created,
               either by the same or a different sigil.  If this path didn&#39;t
               exist, then (say) referencing $! first, and %! second would
               mean that %! was not handled correctly.  */
            if (len == 1 &amp;&amp; stash == PL_defstash) {
                maybe_multimagic_gv(gv, name, sv_type);
            }
            else if (sv_type == SVt_PVAV
                  &amp;&amp; memEQs(name, len, &quot;ISA&quot;)
                  &amp;&amp; (!GvAV(gv) || !SvSMAGICAL(GvAV(gv))))
                gv_magicalize_isa(gv);
        }
        return gv;
    } else if (no_init) {
        assert(!addmg);
        return gv;
    }
    /* If GV_NOEXPAND is true and what we got off the stash is a ref,
     * don&#39;t expand it to a glob. This is an optimization so that things
     * copying constants over, like Exporter, don&#39;t have to be rewritten
     * to take into account that you can store more than just globs in
     * stashes.
     */
    else if (no_expand &amp;&amp; SvROK(gv)) {
        assert(!addmg);
        return gv;
    }

    /* Adding a new symbol.
       Unless of course there was already something non-GV here, in which case
       we want to behave as if there was always a GV here, containing some sort
       of subroutine.
       Otherwise we run the risk of creating things like GvIO, which can cause
       subtle bugs. eg the one that tripped up SQL::Translator  */

    faking_it = SvOK(gv);

    if (add &amp; GV_ADDWARN)
        Perl_ck_warner_d(aTHX_ packWARN(WARN_INTERNAL),
                &quot;Had to create %&quot; UTF8f &quot; unexpectedly&quot;,
                 UTF8fARG(is_utf8, name_end-nambeg, nambeg));
    gv_init_pvn(gv, stash, name, len, (add &amp; GV_ADDMULTI)|is_utf8);

    if (   full_len != 0
        &amp;&amp; isIDFIRST_lazy_if_safe(name, name + full_len, is_utf8)
        &amp;&amp; !ckWARN(WARN_ONCE) )
    {
        GvMULTI_on(gv) ;
    }

    /* set up magic where warranted */
    if ( gv_magicalize(gv, stash, name, len, sv_type) ) {
        /* See 23496c6 */
        if (addmg) {
            /* gv_magicalize magicalised this gv, so we want it
             * stored in the symtab.
             * Effectively the caller is asking, &lsquo;Does this gv exist?&rsquo; 
             * And we respond, &lsquo;Er, *now* it does!&rsquo;
             */
            (void)hv_store(stash,name,len,(SV *)gv,0);
        }
    }
    else if (addmg) {
        /* The temporary GV created above */
        SvREFCNT_dec_NN(gv);
        gv = NULL;
    }
    
    if (gv) gv_init_svtype(gv, faking_it ? SVt_PVCV : sv_type);
    PERL_DTRACE_PROBE_GLOB_RETURN(PERL_DTRACE_GLOB_MODE_FETCH, name);
    return gv;
}</code></pre>

<p>void Perl_gv_fullname4(pTHX_ SV *sv, const GV *gv, const char *prefix, bool keepmain) { const char *name; const HV * const hv = GvSTASH(gv);</p>

<pre><code>    PERL_ARGS_ASSERT_GV_FULLNAME4;

    sv_setpv(sv, prefix ? prefix : &quot;&quot;);

    if (hv &amp;&amp; (name = HvNAME(hv))) {
        const STRLEN len = HvNAMELEN(hv);
        if (keepmain || ! memBEGINs(name, len, &quot;main&quot;)) {
            sv_catpvn_flags(sv,name,len,HvNAMEUTF8(hv)?SV_CATUTF8:SV_CATBYTES);
            sv_catpvs(sv,&quot;::&quot;);
        }
    }
    else sv_catpvs(sv,&quot;__ANON__::&quot;);
    sv_catsv(sv,sv_2mortal(newSVhek(GvNAME_HEK(gv))));
}</code></pre>

<p>void Perl_gv_efullname4(pTHX_ SV *sv, const GV *gv, const char *prefix, bool keepmain) { const GV * const egv = GvEGVx(gv);</p>

<pre><code>    PERL_ARGS_ASSERT_GV_EFULLNAME4;

    gv_fullname4(sv, egv ? egv : gv, prefix, keepmain);
}</code></pre>

<p>/* gv_magicalize;</p>

</dd>
<dt id="gv_try_downgrade">gv_try_downgrade </dt>
<dd>

<p>NOTE: this function is experimental and may change or be removed without notice.</p>

<p>If the typeglob <code>gv</code> can be expressed more succinctly, by having something other than a real GV in its place in the stash, replace it with the optimised form. Basic requirements for this are that <code>gv</code> is a real typeglob, is sufficiently ordinary, and is only referenced from its package. This function is meant to be used when a GV has been looked up in part to see what was there, causing upgrading, but based on what was found it turns out that the real GV isn&#39;t required after all.</p>

<p>If <code>gv</code> is a completely empty typeglob, it is deleted from the stash.</p>

<p>If <code>gv</code> is a typeglob containing only a sufficiently-ordinary constant sub, the typeglob is replaced with a scalar-reference placeholder that more compactly represents the same thing.</p>

<pre><code>        void    gv_try_downgrade(GV* gv)</code></pre>

</dd>
</dl>

<h1 id="Hash-Entries">Hash Entries</h1>

<dl>

<dt id="refcounted_he_fetch_pvs">refcounted_he_fetch_pvs </dt>
<dd>

<p>Like <a href="#refcounted_he_fetch_pvn">&quot;refcounted_he_fetch_pvn&quot;</a>, but takes a literal string instead of a string/length pair, and no precomputed hash.</p>

<pre><code>        SV *    refcounted_he_fetch_pvs(
                    const struct refcounted_he *chain,
                    &quot;literal string&quot; key, U32 flags
                )</code></pre>

</dd>
<dt id="refcounted_he_new_pvs">refcounted_he_new_pvs </dt>
<dd>

<p>Like <a href="#refcounted_he_new_pvn">&quot;refcounted_he_new_pvn&quot;</a>, but takes a literal string instead of a string/length pair, and no precomputed hash.</p>

<pre><code>        struct refcounted_he * refcounted_he_new_pvs(
                                   struct refcounted_he *parent,
                                   &quot;literal string&quot; key,
                                   SV *value, U32 flags
                               )</code></pre>

</dd>
</dl>

<h1 id="Hash-Manipulation-Functions">Hash Manipulation Functions</h1>

<dl>

<dt id="hv_backreferences_p">hv_backreferences_p </dt>
<dd>

<p>NOTE: this function is experimental and may change or be removed without notice.</p>

<p>Returns the modifiable pointer to the field holding the AV* of backreferences. See also <a href="/cperl/perlapi.html#sv_get_backrefs">&quot;sv_get_backrefs&quot; in perlapi</a>.</p>

<pre><code>        AV**    hv_backreferences_p(HV *hv)</code></pre>

</dd>
<dt id="hv_ename_add">hv_ename_add </dt>
<dd>

<p>Adds a name to a stash&#39;s internal list of effective names. See <code><a href="#hv_ename_delete">&quot;hv_ename_delete&quot;</a></code>.</p>

<p>This is called when a stash is assigned to a new location in the symbol table.</p>

<pre><code>        void    hv_ename_add(HV *hv, const char *name, U32 len,
                             U32 flags)</code></pre>

</dd>
<dt id="hv_ename_delete">hv_ename_delete </dt>
<dd>

<p>Removes a name from a stash&#39;s internal list of effective names. If this is the name returned by <code>HvENAME</code>, then another name in the list will take its place (<code>HvENAME</code> will use it).</p>

<p>This is called when a stash is deleted from the symbol table.</p>

<pre><code>        void    hv_ename_delete(HV *hv, const char *name,
                                U32 len, U32 flags)</code></pre>

</dd>
<dt id="hv_kill_backrefs">hv_kill_backrefs </dt>
<dd>

<p>NOTE: this function is experimental and may change or be removed without notice.</p>

<p>Calls <a href="#sv_kill_backrefs">&quot;sv_kill_backrefs&quot;</a> on the hash backreferences, and frees it.</p>

<pre><code>        void    hv_kill_backrefs(HV *hv)</code></pre>

</dd>
<dt id="hv_placeholders_p">hv_placeholders_p </dt>
<dd>

<p>Returns the pointer to modifiable field to the count of hash placeholders, the deleted elements. Used as <code>HvPLACEHOLDERS(hv)++</code></p>

<pre><code>        SSize_t* hv_placeholders_p(HV *hv)</code></pre>

</dd>
<dt id="refcounted_he_chain_2hv">refcounted_he_chain_2hv </dt>
<dd>

<p>Generates and returns a <code>HV *</code> representing the content of a <code>refcounted_he</code> chain. <code>flags</code> is currently unused and must be zero.</p>

<pre><code>        HV *    refcounted_he_chain_2hv(
                    const struct refcounted_he *c, U32 flags
                )</code></pre>

</dd>
<dt id="refcounted_he_fetch_pv">refcounted_he_fetch_pv </dt>
<dd>

<p>Like <a href="#refcounted_he_fetch_pvn">&quot;refcounted_he_fetch_pvn&quot;</a>, but takes a nul-terminated string instead of a string/length pair.</p>

<pre><code>        SV *    refcounted_he_fetch_pv(
                    const struct refcounted_he *chain,
                    const char *key, U32 hash, U32 flags
                )</code></pre>

</dd>
<dt id="refcounted_he_fetch_pvn">refcounted_he_fetch_pvn </dt>
<dd>

<p>Search along a <code>refcounted_he</code> chain for an entry with the key specified by <code>keypv</code> and <code>keylen</code>. If <code>flags</code> has the <code>REFCOUNTED_HE_KEY_UTF8</code> bit set, the key octets are interpreted as UTF-8, otherwise they are interpreted as Latin-1. <code>hash</code> is a precomputed hash of the key string, or zero if it has not been precomputed. Returns a mortal scalar representing the value associated with the key, or <code>PLACEHOLDER</code> if there is no value associated with the key.</p>

<pre><code>        SV *    refcounted_he_fetch_pvn(
                    const struct refcounted_he *chain,
                    const char *keypv, STRLEN keylen, U32 hash,
                    U32 flags
                )</code></pre>

</dd>
<dt id="refcounted_he_fetch_sv">refcounted_he_fetch_sv </dt>
<dd>

<p>Like <a href="#refcounted_he_fetch_pvn">&quot;refcounted_he_fetch_pvn&quot;</a>, but takes a Perl scalar instead of a string/length pair.</p>

<pre><code>        SV *    refcounted_he_fetch_sv(
                    const struct refcounted_he *chain, SV *key,
                    U32 hash, U32 flags
                )</code></pre>

</dd>
<dt id="refcounted_he_free">refcounted_he_free </dt>
<dd>

<p>Decrements the reference count of a <code>refcounted_he</code> by one. If the reference count reaches zero the structure&#39;s memory is freed, which (recursively) causes a reduction of its parent <code>refcounted_he</code>&#39;s reference count. It is safe to pass a null pointer to this function: no action occurs in this case.</p>

<pre><code>        void    refcounted_he_free(struct refcounted_he *he)</code></pre>

</dd>
<dt id="refcounted_he_inc">refcounted_he_inc </dt>
<dd>

<p>Increment the reference count of a <code>refcounted_he</code>. The pointer to the <code>refcounted_he</code> is also returned. It is safe to pass a null pointer to this function: no action occurs and a null pointer is returned.</p>

<pre><code>        struct refcounted_he * refcounted_he_inc(
                                   struct refcounted_he *he
                               )</code></pre>

</dd>
<dt id="refcounted_he_new_pv">refcounted_he_new_pv </dt>
<dd>

<p>Like <a href="#refcounted_he_new_pvn">&quot;refcounted_he_new_pvn&quot;</a>, but takes a nul-terminated string instead of a string/length pair.</p>

<pre><code>        struct refcounted_he * refcounted_he_new_pv(
                                   struct refcounted_he *parent,
                                   const char *key, U32 hash,
                                   SV *value, U32 flags
                               )</code></pre>

</dd>
<dt id="refcounted_he_new_pvn">refcounted_he_new_pvn </dt>
<dd>

<p>Creates a new <code>refcounted_he</code>. This consists of a single key/value pair and a reference to an existing <code>refcounted_he</code> chain (which may be empty), and thus forms a longer chain. When using the longer chain, the new key/value pair takes precedence over any entry for the same key further along the chain.</p>

<p>The new key is specified by <code>keypv</code> and <code>keylen</code>. If <code>flags</code> has the <code>REFCOUNTED_HE_KEY_UTF8</code> bit set, the key octets are interpreted as UTF-8, otherwise they are interpreted as Latin-1. <code>hash</code> is a precomputed hash of the key string, or zero if it has not been precomputed.</p>

<p><code>value</code> is the scalar value to store for this key. <code>value</code> is copied by this function, which thus does not take ownership of any reference to it, and later changes to the scalar will not be reflected in the value visible in the <code>refcounted_he</code>. Complex types of scalar will not be stored with referential integrity, but will be coerced to strings. <code>value</code> may be either null or <code>PLACEHOLDER</code> to indicate that no value is to be associated with the key; this, as with any non-null value, takes precedence over the existence of a value for the key further along the chain.</p>

<p><code>parent</code> points to the rest of the <code>refcounted_he</code> chain to be attached to the new <code>refcounted_he</code>. This function takes ownership of one reference to <code>parent</code>, and returns one reference to the new <code>refcounted_he</code>.</p>

<pre><code>        struct refcounted_he * refcounted_he_new_pvn(
                                   struct refcounted_he *parent,
                                   const char *keypv,
                                   STRLEN keylen, U32 hash,
                                   SV *value, U32 flags
                               )</code></pre>

</dd>
<dt id="refcounted_he_new_sv">refcounted_he_new_sv </dt>
<dd>

<p>Like <a href="#refcounted_he_new_pvn">&quot;refcounted_he_new_pvn&quot;</a>, but takes a Perl scalar instead of a string/length pair.</p>

<pre><code>        struct refcounted_he * refcounted_he_new_sv(
                                   struct refcounted_he *parent,
                                   SV *key, U32 hash, SV *value,
                                   U32 flags
                               )</code></pre>

</dd>
</dl>

<h1 id="Hook-manipulation">Hook manipulation</h1>

<dl>

<dt id="add_does_methods">add_does_methods </dt>
<dd>

<p>Copy all not-existing methods from the parent roles to the class/role. Fixup ISA for type checks. Fixup changed oelem{,fast} indices.</p>

<p>Duplicates are fatal: &quot;Method %s from %s already exists in %s during role composition&quot;</p>

<pre><code>        void    add_does_methods(HV* klass, AV* does)</code></pre>

</dd>
<dt id="add_isa_fields">add_isa_fields </dt>
<dd>

<p>Copy all not-existing fields from parent classes or roles to the class of <code>name</code>. Duplicates are fatal with roles, ignored with classes.</p>

<pre><code>        void    add_isa_fields(HV* klass, AV* isa)</code></pre>

</dd>
<dt id="class_isamagic">class_isamagic </dt>
<dd>

<p>Set closed ISA magic to the array in pkg, either @ISA or @DOES.</p>

<pre><code>        void    class_isamagic(OP* o, SV* pkg, const char* what,
                               int len)</code></pre>

</dd>
<dt id="const_av_xsub">const_av_xsub </dt>
<dd>

<p>Efficient sub that returns a constant array value.</p>

<pre><code>        void    const_av_xsub(CV* cv)</code></pre>

</dd>
<dt id="const_sv_xsub">const_sv_xsub </dt>
<dd>

<p>Efficient sub that returns a constant scalar value.</p>

<pre><code>        void    const_sv_xsub(CV* cv)</code></pre>

</dd>
<dt id="do_method_finalize">do_method_finalize </dt>
<dd>

<p>A field may start as lexical or access call in the class block and method pad, and can to be converted to oelemfast ops, which are basically aelemfast_lex_u (lexical typed self, const ix &lt; 256).</p>

<pre><code>  PADxV targ     -&gt; OELEMFAST(self)[targ]

  $field         -&gt; $self-&gt;field[i] (same as above)
  $self-&gt;{field} -&gt;     -&quot;- (do not use)
  $self-&gt;field   -&gt;     -&quot;-

  exists $self-&gt;field    -&gt; compile-time const if exists
  exists $self-&gt;{field}  -&gt; compile-time const (do not use)
  exists $self-&gt;{$field} -&gt; exists oelem</code></pre>

<p>If the field is computed, convert to a new &#39;oelem&#39; op, which does the field lookup at run-time.</p>

<pre><code>        void    do_method_finalize(const HV* klass,
                                   const CV* cv, OP* o,
                                   const PADOFFSET self)</code></pre>

</dd>
<dt id="method_finalize">method_finalize </dt>
<dd>

<p>Resolve internal lexicals or field helem&#39;s or field accessors to fields in the class method or sub.</p>

<p>Field helem&#39;s might get deleted, as they don&#39;t work outside of classes. Only subs and methods inside the class are processed, not outside! void method_finalize(const HV* klass, const CV* cv)</p>

</dd>
<dt id="Mu_av_xsub">Mu_av_xsub </dt>
<dd>

<p>XS template to set or return object array values from it&#39;s compile-time field offset.</p>

<pre><code>    class MY {
      has @a;
    }
    my $c = new MY;
    $c-&gt;a = (0..2); # (0,1,2)
    print scalar $c-&gt;a; # 3
    $c-&gt;a = 1;     # (1)
    $c-&gt;a = 0..2;  # (0,1,2)
    $c-&gt;a = 1,2;   # (1,2)

        void    Mu_av_xsub(CV* cv)</code></pre>

</dd>
<dt id="Mu_sv_xsub">Mu_sv_xsub </dt>
<dd>

<p>XS template to return an object scalar value from it&#39;s compile-time field offset.</p>

<pre><code>        void    Mu_sv_xsub(CV* cv)</code></pre>

</dd>
<dt id="padnamelist_type_fixup">padnamelist_type_fixup </dt>
<dd>

<p>Changes all types in the padnames from the old klass to a new class. Needed for cloned roles.</p>

<pre><code>        void    padnamelist_type_fixup(PADNAMELIST *pnl,
                                       HV* oldklass,
                                       HV* newklass)</code></pre>

</dd>
</dl>

<h1 id="IO-Functions">IO Functions</h1>

<dl>

<dt id="start_glob">start_glob </dt>
<dd>

<p>NOTE: this function is experimental and may change or be removed without notice.</p>

<p>Function called by <code>do_readline</code> to spawn a glob (or do the glob inside perl on VMS). This code used to be inline, but now perl uses <code>File::Glob</code> this glob starter is only used by miniperl during the build process, or when PERL_EXTERNAL_GLOB is defined. Moving it away shrinks <i>pp_hot.c</i>; shrinking <i>pp_hot.c</i> helps speed perl up.</p>

<pre><code>        PerlIO* start_glob(SV *tmpglob, IO *io)</code></pre>

</dd>
</dl>

<h1 id="Lexer-interface">Lexer interface</h1>

<dl>

<dt id="ao">ao </dt>
<dd>

<p>ao(toketype) looks for an &#39;=&#39; next to the operator, whithout whitespace, that has just been parsed and turns it into an ASSIGNOP if it finds one.</p>

<pre><code>        int     ao(int toketype)</code></pre>

</dd>
<dt id="check_uni">check_uni </dt>
<dd>

<p>Check the unary operators to ensure there&#39;s no ambiguity in how they&#39;re used, and if so warn about it. An ambiguous piece of code would be:</p>

<pre><code>    rand + 5</code></pre>

<p>This doesn&#39;t mean rand() + 5. Because rand() is a unary operator, the +5 is its argument.</p>

<pre><code>        void    check_uni()</code></pre>

</dd>
<dt id="find_in_coretypes">find_in_coretypes </dt>
<dd>

<p>NOTE: this function is experimental and may change or be removed without notice.</p>

<p>Check for and autocreate coretypes. Some of them inherited, setting the ISA. Returns NULL if the name is not a coretype. NOTE: the perl_ form of this function is deprecated.</p>

<pre><code>        HV *    find_in_coretypes(const char *pkgname,
                                  STRLEN len)</code></pre>

</dd>
<dt id="force_ident">force_ident </dt>
<dd>

<p>Called when the lexer wants $foo *foo &amp;foo etc, but the program text only contains the &quot;foo&quot; portion. The first argument is a pointer to the &quot;foo&quot;, and the second argument is the type symbol to prefix. Forces the next token to be a &quot;BAREWORD&quot;. Creates the symbol if it didn&#39;t already exist (via gv_fetchpv()).</p>

<pre><code>        void    force_ident(const char *s, int kind)</code></pre>

</dd>
<dt id="force_next">force_next </dt>
<dd>

<p>When the lexer realizes it knows the next token (for instance, it is reordering tokens for the parser) then it can call S_force_next to know what token to return the next time the lexer is called. Caller will need to set PL_nextval[] and possibly PL_expect to ensure the lexer handles the token correctly.</p>

<pre><code>        void    force_next(I32 type)</code></pre>

</dd>
<dt id="force_version">force_version </dt>
<dd>

<p>Forces the next token to be a version number. If the next token appears to be an invalid version number, (e.g. &quot;v2b&quot;), and if &quot;guessing&quot; is TRUE, then no new token is created (and the caller must use an alternative parsing method).</p>

<pre><code>        char*   force_version(char *s, int guessing)</code></pre>

</dd>
<dt id="force_word">force_word </dt>
<dd>

<p>When the lexer knows the next thing is a word (for instance, it has just seen -&gt; and it knows that the next char is a word char, then it calls S_force_word to stick the next word into the PL_nexttoke/val lookahead.</p>

<p>Arguments: char *start : buffer position (must be within PL_linestr) int token : PL_next* will be this type of bare word (e.g., METHOD,BAREWORD) int check_keyword : if true, Perl checks to make sure the word isn&#39;t a keyword (do this if the word is a label, e.g. goto FOO) int allow_pack : if true, : characters will also be allowed (require, use, etc. do this)</p>

<pre><code>        char*   force_word(char *start, int token,
                           int check_keyword, int allow_pack)</code></pre>

</dd>
<dt id="incline">incline </dt>
<dd>

<p>This subroutine name is short for &quot;increment line&quot;. It has nothing to do with tilting, whether at windmills or pinball tables. It increments the current line number in CopLINE(PL_curcop) and checks to see whether the line starts with a comment of the form <code># line 500 &quot;foo.pm&quot;</code> If so, it sets the current line number and file to the values in the comment.</p>

<pre><code>        void    incline(const char *s, const char *end)</code></pre>

</dd>
<dt id="lop">lop </dt>
<dd>

<p>Build a list operator (or something that might be one). The rules: - if we have a next token, then it&#39;s a list operator (no parens) for which the next token has already been parsed; e.g., sort foo @args sort foo (@args) - if the next thing is an opening paren, then it&#39;s a function - else it&#39;s a list operator</p>

<pre><code>        I32     lop(I32 f, expectation x, char *s)</code></pre>

</dd>
<dt id="missingterm">missingterm </dt>
<dd>

<p>Complain about missing quote/regexp/heredoc terminator. If it&#39;s called with NULL then it cauterizes the line buffer. If we&#39;re in a delimited string and the delimiter is a control character, it&#39;s reformatted into a two-char sequence like ^C. This is fatal. void missingterm(char *s, STRLEN len)</p>

</dd>
<dt id="new_constant">new_constant </dt>
<dd>

<p>do any overload::constant lookup.</p>

<p>Either returns sv, or mortalizes/frees sv and returns a new SV*. Best used as sv=new_constant(..., sv, ...).</p>

<pre><code>  If s, pv are NULL, calls subroutine with one argument,
  and &lt;type&gt; is used with error messages only.
  &lt;type&gt; is assumed to be well formed UTF-8

  If error_msg is not NULL, *error_msg will be set to any error encountered.
  otherwise yyerror() will be used to output it

        SV*     new_constant(const char *s, STRLEN len,
                             const char *key, STRLEN keylen,
                             SV *sv, SV *pv, const char *type,
                             STRLEN typelen,
                             const char ** error_msg)</code></pre>

</dd>
<dt id="no_op">no_op </dt>
<dd>

<p>When Perl expects an operator and finds something else, no_op prints the warning. It always prints &quot;&lt;something&gt; found where operator expected. It prints &quot;Missing semicolon on previous line?&quot; if the surprise occurs at the start of the line. &quot;do you need to predeclare ...&quot; is printed out for code like &quot;sub bar; foo bar $x&quot; where the compiler doesn&#39;t know if foo is a method call or a function. It prints &quot;Missing operator before end of line&quot; if there&#39;s nothing after the missing operator, or &quot;... before &lt;...&gt;&quot; if there is something after the missing operator.</p>

<p>PL_bufptr is expected to point to the start of the thing that was found, and s after the next token or partial token.</p>

<pre><code>        void    no_op(const char *const what, char *s)</code></pre>

</dd>
<dt id="notify_parser_that_changed_to_utf8">notify_parser_that_changed_to_utf8 </dt>
<dd>

<p>Called when $^H is changed to indicate that HINT_UTF8 has changed from off to on. At compile time, this has the effect of entering a &#39;use utf8&#39; section. This means that any input was not previously checked for UTF-8 (because it was off), but now we do need to check it, or our assumptions about the input being sane could be wrong, and we could segfault. This routine just sets a flag so that the next time we look at the input we do the well-formed UTF-8 check. If we aren&#39;t in the proper phase, there may not be a parser object, but if there is, setting the flag is harmless.</p>

<pre><code>        void    notify_parser_that_changed_to_utf8()</code></pre>

</dd>
<dt id="num_constlistexpr">num_constlistexpr </dt>
<dd>

<p>Number of const list elements. depth starts with 0</p>

<p>NOTE: the perl_ form of this function is deprecated.</p>

<pre><code>        SSize_t num_constlistexpr(OP* o, int depth)</code></pre>

</dd>
<dt id="parse_subsignature">parse_subsignature </dt>
<dd>

<p>Parse a sequence of zero or more Perl signature arguments, everything between the <code>()</code> parentheses, seperated by &#39;,&#39;, with optional &#39;=&#39; or &#39;?&#39; default values and ending slurpy params (&#39;@&#39; or &#39;%&#39;).</p>

<pre><code>    sub f ($a, $b = 1) {...}</code></pre>

<p>Return an OP_LINESEQ op, which has as its children, an OP_SIGNATURE, plus 0 or more (sassign, nextstate) pairs for each default arg expression that can&#39;t be optimised into the OP_SIGNATURE. Returns NULL on error.</p>

<p>It gives the OP_SIGNATURE op an op_aux array, which contains collections of actions and args; the args being things like what pad ranges to introduce, and simple default args such as an integer constant, an SV constant, or a simple lex or package var.</p>

<p>Note that we attach this data to CV via an OP_SIGNATURE rather than directly attaching it to the CV, so that it doesn&#39;t need copying each time a new thread is cloned.</p>

<p>Done: - perl6-like optional args: ($opt?) i.e. ($opt=undef) - types in leading position (int $i) - attributes (:const, types), ($i :int :const) - no double copies into @_ - scalar references compiled to direct access, not just copies (\$a) =&gt; my $a = $_[0]. - call-by-value and call-by-ref supported. call-by-ref could be improved through so we don&#39;t change constants to be called-by-ref, and rather copy it. Todo: - error in ck_subr when @_/$_[] in signatured bodies is used</p>

<p>NOTE: the perl_ form of this function is deprecated.</p>

<pre><code>        OP *    parse_subsignature()</code></pre>

</dd>
<dt id="pending_ident">pending_ident </dt>
<dd>

<p>Looks up an identifier in the pad or in a package.</p>

<p>Returns: PRIVATEREF if this is a lexical name. BAREWORD if this belongs to a package.</p>

<p>Structure: if we&#39;re in a my declaration croak if they tried to say my($foo::bar) build the ops for a my() declaration if it&#39;s an access to a my() variable build ops for access to a my() variable if in a dq string, and they&#39;ve said @foo and we can&#39;t find @foo warn build ops for a bareword</p>

<pre><code>        int     pending_ident()</code></pre>

</dd>
<dt id="scan_const">scan_const </dt>
<dd>

<p>Extracts the next constant part of a pattern, double-quoted string, or transliteration. This is terrifying code.</p>

<p>For example, in parsing the double-quoted string &quot;ab\x63$d&quot;, it would stop at the &#39;$&#39; and return an OP_CONST containing &#39;abc&#39;.</p>

<p>It looks at PL_lex_inwhat and PL_lex_inpat to find out whether it&#39;s processing a pattern (PL_lex_inpat is true), a transliteration (PL_lex_inwhat == OP_TRANS is true), or a double-quoted string.</p>

<p>Returns a pointer to the character scanned up to. If this is advanced from the start pointer supplied (i.e. if anything was successfully parsed), will leave an OP_CONST for the substring scanned in pl_yylval. Caller must intuit reason for not parsing further by looking at the next characters herself.</p>

<p>In patterns: expand: \N{FOO} =&gt; \N{U+hex_for_character_FOO} (if FOO expands to multiple characters, expands to \N{U+xx.XX.yy ...})</p>

<pre><code>  pass through:
      all other \-char, including \N and \N{ apart from \N{ABC}

  stops on:
      @ and $ where it appears to be a var, but not for $ as tail anchor
      \l \L \u \U \Q \E
      (?{  or  (??{</code></pre>

<p>In transliterations: characters are VERY literal, except for - not at the start or end of the string, which indicates a range. If the range is in bytes, scan_const expands the range to the full set of intermediate characters. If the range is in utf8, the hyphen is replaced with a certain range mark which will be handled by pmtrans() in op.c.</p>

<p>In double-quoted strings: backslashes: double-quoted style: \r and \n constants: \x31, etc. deprecated backrefs: \1 (in substitution replacements) case and quoting: \U \Q \E stops on @ and $</p>

<p>scan_const does *not* construct ops to handle interpolated strings. It stops processing as soon as it finds an embedded $ or @ variable and leaves it to the caller to work out what&#39;s going on.</p>

<p>embedded arrays (whether in pattern or not) could be: @foo, @::foo, @&#39;foo, @{foo}, @$foo, @+, @-.</p>

<p>$ in double-quoted strings must be the symbol of an embedded scalar.</p>

<p>$ in pattern could be $foo or could be tail anchor. Assumption: it&#39;s a tail anchor if $ is the last thing in the string, or if it&#39;s followed by one of &quot;()| \r\n\t&quot;</p>

<p>\1 (backreferences) are turned into $1 in substitutions</p>

<p>The structure of the code is while (there&#39;s a character to process) { handle transliteration ranges skip regexp comments /(?#comment)/ and codes /(?{code})/ skip #-initiated comments in //x patterns check for embedded arrays check for embedded scalars if (backslash) { deprecate \1 in substitution replacements handle string-changing backslashes \l \U \Q \E, etc. switch (what was escaped) { handle \- in a transliteration (becomes a literal -) if a pattern and not \N{, go treat as regular character handle \132 (octal characters) handle \x15 and \x{1234} (hex characters) handle \N{name} (named characters, also \N{3,5} in a pattern) handle \cV (control characters) handle printf-style backslashes (\f, \r, \n, etc) } (end switch) continue } (end if backslash) handle regular character } (end while character to read)</p>

<pre><code>        char*   scan_const(char *start)</code></pre>

</dd>
<dt id="scan_heredoc">scan_heredoc </dt>
<dd>

<p>Takes a pointer to the first &lt; in &lt;&lt;FOO. Returns a pointer to the byte following &lt;&lt;FOO.</p>

<p>This function scans a heredoc, which involves different methods depending on whether we are in a string eval, quoted construct, etc. This is because PL_linestr could containing a single line of input, or a whole string being eval&#39;ed, or the contents of the current quote- like operator.</p>

<p>The two basic methods are: - Steal lines from the input stream - Scan the heredoc in PL_linestr and remove it therefrom</p>

<p>In a file scope or filtered eval, the first method is used; in a string eval, the second.</p>

<p>In a quote-like operator, we have to choose between the two, depending on where we can find a newline. We peek into outer lex- ing scopes until we find one with a newline in it. If we reach the outermost lexing scope and it is a file, we use the stream method. Otherwise it is treated as an eval.</p>

<pre><code>        char*   scan_heredoc(char *s)</code></pre>

</dd>
<dt id="scan_inputsymbol">scan_inputsymbol </dt>
<dd>

<p>takes: position of first &#39;&lt;&#39; in input buffer</p>

<p>returns: position of first char following the last &#39;&gt;&#39; in input buffer.</p>

<p>side-effects: pl_yylval and lex_op are set.</p>

<p>This code handles:</p>

<pre><code>   &lt;&gt;           read from ARGV
   &lt;&lt;&gt;&gt;         read from ARGV without magic open
   &lt;FH&gt;         read from filehandle
   &lt;pkg::FH&gt;    read from package qualified filehandle
   &lt;pkg&#39;FH&gt;     read from package qualified filehandle
   &lt;$fh&gt;        read from filehandle in $fh
   &lt;*.h&gt;        filename glob

        char*   scan_inputsymbol(char *start)</code></pre>

</dd>
<dt id="scan_str">scan_str </dt>
<dd>

<p>NOTE: this function is experimental and may change or be removed without notice.</p>

<p>takes: start position in buffer keep_bracketed_quoted preserve \ quoting of embedded delimiters, but only if they are of the open/close form keep_delims preserve the delimiters around the string re_reparse compiling a run-time /(?{})/: collapse // to /, and skip encoding src delimp if non-null, this is set to the position of the closing delimiter, or just after it if the closing and opening delimiters differ (i.e., the opening delimiter of a substitu- tion replacement)</p>

<p>returns: position to continue reading from buffer</p>

<p>side-effects: multi_start, multi_close, lex_repl or lex_stuff, and updates the read buffer.</p>

<p>This subroutine pulls a string out of the input. It is called for:</p>

<pre><code>        q               single quotes           q(literal text)
        &#39;               single quotes           &#39;literal text&#39;
        qq              double quotes           qq(interpolate $here please)
        &quot;               double quotes           &quot;interpolate $here please&quot;
        qx              backticks               qx(/bin/ls -l)
        `               backticks               `/bin/ls -l`
        qw              quote words             @EXPORT_OK = qw( func() $spam )
        m//             regexp match            m/this/
        s///            regexp substitute       s/this/that/
        tr///           string transliterate    tr/this/that/
        y///            string transliterate    y/this/that/
        ($*@)           sub prototypes          sub foo ($)
        (stuff)         sub attr parameters     sub foo : attr(stuff)
        &lt;&gt;              readline or globs       &lt;FOO&gt;, &lt;&gt;, &lt;$fh&gt;, or &lt;*.c&gt;</code></pre>

<p>In most of these cases (all but &lt;&gt;, patterns and transliterate) yylex() calls scan_str(). m// makes yylex() call scan_pat() which calls scan_str(). s/// makes yylex() call scan_subst() which calls scan_str(). tr/// and y/// make yylex() call scan_trans() which calls scan_str().</p>

<p>It skips whitespace before the string starts, and treats the first character as the delimiter. If the delimiter is one of ([{&lt; then the corresponding &quot;close&quot; character )]}&gt; is used as the closing delimiter. It allows quoting of delimiters, and if the string has balanced delimiters ([{&lt;&gt;}]) it allows nesting.</p>

<p>On success, the SV with the resulting string is put into lex_stuff or, if that is already non-NULL, into lex_repl. The second case occurs only when parsing the RHS of the special constructs s/// and tr/// (y///). For convenience, the terminating delimiter character is stuffed into SvIVX of the SV.</p>

<pre><code>        char*   scan_str(char *start, int keep_quoted,
                         int keep_delims, int re_reparse,
                         char **delimp)</code></pre>

</dd>
<dt id="scan_word">scan_word </dt>
<dd>

<p>NOTE: this function is experimental and may change or be removed without notice.</p>

<p>Returns a NUL terminated string, with the length of the string written to *slp. Note that the perl5 API misses the normalize argument.</p>

<pre><code>        char*   scan_word(char *s, char *dest, STRLEN destlen,
                          int allow_package, STRLEN *slp,
                          int *normalize)</code></pre>

</dd>
<dt id="validate_proto">validate_proto </dt>
<dd>

<p>NOTE: this function is experimental and may change or be removed without notice.</p>

<p>This function performs syntax checking on a prototype, <code>proto</code>. If <code>warn</code> is true, any illegal characters or mismatched brackets will trigger illegalproto warnings, declaring that they were detected in the prototype for <code>name</code>.</p>

<p>The return value is <code>true</code> if this is a valid prototype, and <code>false</code> if it is not, regardless of whether <code>warn</code> was <code>true</code> or <code>false</code>.</p>

<p>Note that <code>NULL</code> is a valid <code>proto</code> and will always return <code>true</code>.</p>

<p>In cperl with maybe_sig TRUE this also detects if it&#39;s a signature, and returns FALSE then. Thus the illegalproto warnings are relaxed.</p>

<p>NOTE: the perl_ form of this function is deprecated.</p>

<pre><code>        bool    validate_proto(SV *name, SV *proto, bool dowarn,
                               bool curstash, bool maybe_sig)</code></pre>

</dd>
<dt id="yylex">yylex </dt>
<dd>

<p>Works out what to call the token just pulled out of the input stream. The yacc parser takes care of taking the ops we return and stitching them into a tree.</p>

<p>Returns: The type of the next token.</p>

<p>Structure: Check if we have already built the token; if so, use it. Switch based on the current state: - if we have a case modifier in a string, deal with that - handle other cases of interpolation inside a string - scan the next line if we are inside a format In the normal state, switch on the next character: - default: if alphabetic, go to key lookup unrecognized character - croak - 0/4/26: handle end-of-line or EOF - cases for whitespace - \n and #: handle comments and line numbers - various operators, brackets and sigils - numbers - quotes - &#39;v&#39;: vstrings (or go to key lookup) - &#39;x&#39; repetition operator (or go to key lookup) - other ASCII alphanumerics (key lookup begins here): word before =&gt; ? keyword plugin scan built-in keyword (but do nothing with it yet) check for statement label check for lexical subs goto just_a_word if there is one see whether built-in keyword is overridden switch on keyword number: - default: just_a_word: not a built-in keyword; handle bareword lookup disambiguate between method and sub call fall back to bareword - cases for built-in keywords</p>

<pre><code>        int     yylex()</code></pre>

</dd>
</dl>

<h1 id="Magical-Functions">Magical Functions</h1>

<dl>

<dt id="magic_clearhint">magic_clearhint </dt>
<dd>

<p>Triggered by a delete from <code>%^H</code>, records the key to <code>PL_compiling.cop_hints_hash</code>.</p>

<pre><code>        int     magic_clearhint(SV* sv, MAGIC* mg)</code></pre>

</dd>
<dt id="magic_clearhints">magic_clearhints </dt>
<dd>

<p>Triggered by clearing <code>%^H</code>, resets <code>PL_compiling.cop_hints_hash</code>.</p>

<pre><code>        int     magic_clearhints(SV* sv, MAGIC* mg)</code></pre>

</dd>
<dt id="magic_getffi_encoded-int-magic_getffi_encoded-SV-sv-MAGIC-mg">magic_getffi_encoded  int magic_getffi_encoded(SV* sv, MAGIC* mg)</dt>
<dd>

</dd>
<dt id="magic_methcall">magic_methcall </dt>
<dd>

<p>Invoke a magic method (like FETCH).</p>

<p><code>sv</code> and <code>mg</code> are the tied thingy and the tie magic.</p>

<p><code>meth</code> is the name of the method to call.</p>

<p><code>argc</code> is the number of args (in addition to $self) to pass to the method.</p>

<p>The <code>flags</code> can be:</p>

<pre><code>    G_DISCARD     invoke method with G_DISCARD flag and don&#39;t
                  return a value
    G_UNDEF_FILL  fill the stack with argc pointers to
                  PL_sv_undef</code></pre>

<p>The arguments themselves are any values following the <code>flags</code> argument.</p>

<p>Returns the SV (if any) returned by the method, or <code>NULL</code> on failure.</p>

<pre><code>        SV*     magic_methcall(SV *sv, const MAGIC *mg,
                               SV *meth, U32 flags, U32 argc,
                               ...)</code></pre>

</dd>
<dt id="magic_setffi_encoded">magic_setffi_encoded </dt>
<dd>

<p>Get and set the name of the FFI string argument :encoded() attribute.</p>

<pre><code>        int     magic_setffi_encoded(SV* sv, MAGIC* mg)</code></pre>

</dd>
<dt id="magic_sethint">magic_sethint </dt>
<dd>

<p>Triggered by a store to <code>%^H</code>, records the key/value pair to <code>PL_compiling.cop_hints_hash</code>. It is assumed that hints aren&#39;t storing anything that would need a deep copy. Maybe we should warn if we find a reference.</p>

<pre><code>        int     magic_sethint(SV* sv, MAGIC* mg)</code></pre>

</dd>
<dt id="mg_localize">mg_localize </dt>
<dd>

<p>Copy some of the magic from an existing SV to new localized version of that SV. Container magic (<i>e.g.</i>, <code>%ENV</code>, <code>$1</code>, <code>tie</code>) gets copied, value magic doesn&#39;t (<i>e.g.</i>, <code>taint</code>, <code>pos</code>).</p>

<p>If <code>setmagic</code> is false then no set magic will be called on the new (empty) SV. This typically means that assignment will soon follow (e.g. <span style="white-space: nowrap;"><code>&#39;local $x = $y&#39;</code></span>), and that will handle the magic.</p>

<pre><code>        void    mg_localize(SV* sv, SV* nsv, bool setmagic)</code></pre>

</dd>
</dl>

<h1 id="Miscellaneous-Functions">Miscellaneous Functions</h1>

<dl>

<dt id="closest_cop">closest_cop </dt>
<dd>

<p>Look for curop starting from o. cop is the last COP we&#39;ve seen. opnext means that curop is actually the -&gt;op_next of the op we are seeking.</p>

<p>NOTE: the perl_ form of this function is deprecated.</p>

<pre><code>        const COP* closest_cop(const COP *cop, const OP *o,
                               const OP *curop, bool opnext)</code></pre>

</dd>
<dt id="free_c_backtrace">free_c_backtrace </dt>
<dd>

<p>Deallocates a backtrace received from get_c_bracktrace.</p>

<pre><code>        void    free_c_backtrace(Perl_c_backtrace* bt)</code></pre>

</dd>
<dt id="get_c_backtrace">get_c_backtrace </dt>
<dd>

<p>Collects the backtrace (aka &quot;stacktrace&quot;) into a single linear malloced buffer, which the caller <b>must</b> <code>Perl_free_c_backtrace()</code>.</p>

<p>Scans the frames back by <span style="white-space: nowrap;"><code>depth + skip</code></span>, then drops the <code>skip</code> innermost, returning at most <code>depth</code> frames.</p>

<pre><code>        Perl_c_backtrace* get_c_backtrace(int max_depth,
                                          int skip)</code></pre>

</dd>
<dt id="get_db_sub">get_db_sub </dt>
<dd>

<p>Stores the called <code>cv</code> in $DB::sub, either as name or as CV ptr (with NONAME, an anon sub).</p>

<p><code>sv</code> contains the entersub argument from the stack, which is either a CVREF or a GV, or NULL if called via goto. It is not really needed.</p>

<p>In the debugger entersub does not call the function, but &amp;DB::sub which then calls the cv.</p>

<pre><code>        void    get_db_sub(SV *sv, CV *cv)</code></pre>

</dd>
<dt id="prep_cif">prep_cif </dt>
<dd>

<p>Prepare the compile-time argument and return types and arity for an extern sub for <code>ffi_prep_cif()</code>.</p>

<p>See <code>man ffi_prep_cif</code>. void prep_cif(CV* cv, const char *nativeconv, const char *encoded)</p>

</dd>
</dl>

<h1 id="MRO-Functions">MRO Functions</h1>

<dl>

<dt id="mro_get_linear_isa_dfs">mro_get_linear_isa_dfs </dt>
<dd>

<p>Returns the Depth-First Search linearization of <code>@ISA</code> the given stash. The return value is a read-only AV*. <code>level</code> should be 0 (it is used internally in this function&#39;s recursion).</p>

<p>You are responsible for <code>SvREFCNT_inc()</code> on the return value if you plan to store it anywhere semi-permanently (otherwise it might be deleted out from under you the next time the cache is invalidated).</p>

<pre><code>        AV*     mro_get_linear_isa_dfs(HV* stash, U32 level)</code></pre>

</dd>
<dt id="mro_package_moved">mro_package_moved </dt>
<dd>

<p>Call this function to signal to a stash that it has been assigned to another spot in the stash hierarchy. <code>stash</code> is the stash that has been assigned. <code>oldstash</code> is the stash it replaces, if any. <code>gv</code> is the glob that is actually being assigned to.</p>

<p>This can also be called with a null first argument to indicate that <code>oldstash</code> has been deleted.</p>

<p>This function invalidates isa caches on the old stash, on all subpackages nested inside it, and on the subclasses of all those, including non-existent packages that have corresponding entries in <code>stash</code>.</p>

<p>It also sets the effective names (<code>HvENAME</code>) on all the stashes as appropriate.</p>

<p>If the <code>gv</code> is present and is not in the symbol table, then this function simply returns. This checked will be skipped if <code>flags &amp; 1</code>.</p>

<pre><code>        void    mro_package_moved(HV * const stash,
                                  HV * const oldstash,
                                  const GV * const gv,
                                  U32 flags)</code></pre>

</dd>
</dl>

<h1 id="Numeric-functions">Numeric functions</h1>

<dl>

<dt id="grok_atoUV">grok_atoUV </dt>
<dd>

<p>parse a string, looking for a decimal unsigned integer.</p>

<p>On entry, <code>pv</code> points to the beginning of the string; <code>valptr</code> points to a UV that will receive the converted value, if found; <code>endptr</code> is either NULL or points to a variable that points to one byte beyond the point in <code>pv</code> that this routine should examine. If <code>endptr</code> is NULL, <code>pv</code> is assumed to be NUL-terminated.</p>

<p>Returns FALSE if <code>pv</code> doesn&#39;t represent a valid unsigned integer value (with no leading zeros). Otherwise it returns TRUE, and sets <code>*valptr</code> to that value.</p>

<p>If you constrain the portion of <code>pv</code> that is looked at by this function (by passing a non-NULL <code>endptr</code>), and if the intial bytes of that portion form a valid value, it will return TRUE, setting <code>*endptr</code> to the byte following the final digit of the value. But if there is no constraint at what&#39;s looked at, all of <code>pv</code> must be valid in order for TRUE to be returned.</p>

<p>The only characters this accepts are the decimal digits &#39;0&#39;..&#39;9&#39;.</p>

<p>As opposed to <a href="http://man.he.net/man3/atoi">atoi(3)</a> or <a href="http://man.he.net/man3/strtol">strtol(3)</a>, <code>grok_atoUV</code> does NOT allow optional leading whitespace, nor negative inputs. If such features are required, the calling code needs to explicitly implement those.</p>

<p>Note that this function returns FALSE for inputs that would overflow a UV, or have leading zeros. Thus a single <code>0</code> is accepted, but not <code>00</code> nor <code>01</code>, <code>002</code>, <i>etc</i>.</p>

<p>Background: <code>atoi</code> has severe problems with illegal inputs, it cannot be used for incremental parsing, and therefore should be avoided <code>atoi</code> and <code>strtol</code> are also affected by locale settings, which can also be seen as a bug (global state controlled by user environment).</p>

<pre><code>        bool    grok_atoUV(const char* pv, UV* valptr,
                           const char** endptr)</code></pre>

</dd>
</dl>

<h1 id="Optree-construction">Optree construction</h1>

<dl>

<dt id="force_list">force_list </dt>
<dd>

<p>promote o and any siblings to be a list if its not already; i.e.</p>

<pre><code> o - A - B</code></pre>

<p>becomes</p>

<pre><code> list
   |
 pushmark - o - A - B</code></pre>

<p>If nullit it true, the list op is nulled. OP* force_list(OP* arg, bool nullit)</p>

</dd>
<dt id="package">package </dt>
<dd>

<p>Implements the package keyword, used in <code>perly.y</code>. Saves the old current package, and sets the new current package and package name (for __PACKAGE__).</p>

<p>On cperl also checks for a shadow method overriding method access to this new package. Note that <a href="/cperl/perlapi.html#class_role">&quot;class_role&quot; in perlapi</a> inlines most of this function also.</p>

<p>NOTE: the perl_ form of this function is deprecated.</p>

<pre><code>        void    package(OP* o)</code></pre>

</dd>
</dl>

<h1 id="Optree-Manipulation-Functions">Optree Manipulation Functions</h1>

<dl>

<dt id="alloc_LOGOP">alloc_LOGOP </dt>
<dd>

<p>NOTE: this function is experimental and may change or be removed without notice.</p>

<p>lowest-level newLOGOP-style function - just allocates and populates the struct. Higher-level stuff should be done by S_new_logop() / newLOGOP(). This function exists mainly to avoid op_first assignment being spread throughout this file.</p>

<p>NOTE: the perl_ form of this function is deprecated.</p>

<pre><code>        LOGOP*  alloc_LOGOP(I32 type, OP *first, OP *other)</code></pre>

</dd>
<dt id="apply_attrs">apply_attrs </dt>
<dd>

<p>Calls the attribute importer with the target and a list of attributes. As manually done via <code>BEGIN{ require; attributes-</code>import($pkg, $rv, @attrs)}&gt;.</p>

<p>See <a href="#apply_attrs_my">&quot;apply_attrs_my&quot;</a> for the variant which defers the import call to run-time, enabling run-time attribute arguments, i.e. variables, not only constant barewords, and see <a href="#attrs_runtime">&quot;attrs_runtime&quot;</a> which extracts the run-time part of attrs.</p>

<pre><code>        void    apply_attrs(HV *stash, SV *target, OP *attrs)</code></pre>

</dd>
<dt id="apply_attrs_my">apply_attrs_my </dt>
<dd>

<p>Similar to <a href="#apply_attrs">&quot;apply_attrs&quot;</a> calls the attribute importer with the target, which must be a lexical and a list of attributes. As manually done via <code>use attributes $pkg, $rv, @attrs</code>. But contrary to <a href="#apply_attrs">&quot;apply_attrs&quot;</a> this defers <code>attributes-</code>import()&gt; to run-time.</p>

<p>Returns the list of attributes in the **imopsp argument.</p>

<p>Used in cperl with non-constant attrs arguments to defer the import to run-time. [cperl #291] perl5 cannot handle run-time args like :native($lib). threaded cperl cannot handle those variables yet.</p>

<pre><code>        void    apply_attrs_my(HV *stash, OP *target, OP *attrs,
                               OP **imopsp)</code></pre>

</dd>
<dt id="attrs_has_const">attrs_has_const </dt>
<dd>

<p>NOTE: this function is experimental and may change or be removed without notice.</p>

<p>Checks the attrs list if &quot;:const&quot; is in it. But not <code>(&quot;const&quot;, my $x)</code>.</p>

<p>Returns the number of found attribs with const, which is only relevant for 1 for const being the single attr, 0 if no const was found, and &gt;1 if there are also other attribs besides const.</p>

<p>If from_assign is TRUE, the attrs are already expanded to a full ENTERSUB import call. If not it&#39;s a list, not attrs. If from_assign is FALSE, it is from an unexpanded attrlist <code>our VAR :ATTR</code> declaration, without ENTERSUB.</p>

<pre><code>  TRUE:  my $s :const = 1;  LIST-PUSHMARK-ENTERSUB
  TRUE:  my @a :const = 1;  LIST-PUSHMARK-PADAV-ENTERSUB
  TRUE:  our $s :const = 1; LIST-PUSHMARK-RV2SV(gv)-ENTERSUB
  FALSE: our $s :const = 1; CONST
  TRUE:  (&quot;const&quot;,my $s) = 1; LIST-PUSHMARK-CONST

        int     attrs_has_const(OP* o, bool from_assign)</code></pre>

</dd>
<dt id="attrs_runtime">attrs_runtime </dt>
<dd>

<p>NOTE: this function is experimental and may change or be removed without notice.</p>

<p>Extract the run-time part of sub attributes with arguments, i.e. variables, not just constant barewords or strings. Might be extended to other lexical args, not just subs.</p>

<p>Returns NULL on none or only constant attribute arguments, otherwise returns the run-time attributes-&gt;import code.</p>

<pre><code>        OP *    attrs_runtime(CV *cv, OP *attrs)</code></pre>

</dd>
<dt id="bind_match-OP-bind_match-I32-type-OP-left-OP-right">bind_match  OP* bind_match(I32 type, OP *left, OP *right)</dt>
<dd>

</dd>
<dt id="cant_declare-void-cant_declare-OP-o">cant_declare  void cant_declare(OP* o)</dt>
<dd>

</dd>
<dt id="check_hash_fields_and_hekify">check_hash_fields_and_hekify </dt>
<dd>

<p>for a helem/hslice/kvslice, if its a fixed hash, croak on invalid const fields. Also, convert CONST keys to HEK-in-SVs.</p>

<p>rop is the op that retrieves the hash; key_op is the first key; real if false, only check (and possibly croak); don&#39;t update op</p>

<pre><code>                check_hash_fields_and_hekify;</code></pre>

</dd>
<dt id="cv_check_inline">cv_check_inline </dt>
<dd>

<p>NOTE: this function is experimental and may change or be removed without notice.</p>

<p>Examine an optree to determine whether it&#39;s in-lineable. In contrast to op_const_sv allow short op sequences which are not constant folded. Max 10 ops, no new pad (?), no intermediate return, no recursion, ... no call-by-ref: $_[i] aelemfast(*_) or aelem rv2av or multideref($_[$x]) TODO later: call-by-ref, new lexicals. walk by sib not next (skipping other).</p>

<p>cv_inline needs to translate the args, change return to jumps.</p>

<p>$lhs = call(...); =&gt; $lhs = do {...inlined...}; bool cv_check_inline(const OP *o, CV *compcv)</p>

</dd>
<dt id="cv_do_inline">cv_do_inline </dt>
<dd>

<p>NOTE: this function is experimental and may change or be removed without notice.</p>

<p>Needs to translate the args to local pads. o: entersub cvop: leavesub Splice inlined leavesub block, replacing pushmark .. entersub. METHOD should not arrive here, neither $obj-&gt;method.</p>

<p>handle args: shift, = @_ or just accept SIGNATURED subs with PERL_FAKE_SIGNATURE. with a OP_SIGNATURE it is easier. without need to populate @_. if arg is call-by-value make a copy. adjust or add targs, with local or eval{} or caller, entersub, ... need to add ENTER/LEAVE, skip ENTER/LEAVE if certain ops are absent.</p>

<p>$lhs = call(...); =&gt; $lhs = do {...inlined...};</p>

<p>Converted to a simplier ck step, without linked op_next ptrs. Not in rpeep anymore. Only activated with PERL_INLINE_SUBS OP* cv_do_inline(OP *parent, OP *o, OP *cvop, CV *cv)</p>

</dd>
<dt id="dup_attrlist">dup_attrlist </dt>
<dd>

<p>Return a copy of an attribute list, i.e. a CONST or LIST with a list of CONST or PADSV/RV2SV-GV values.</p>

<pre><code>        OP *    dup_attrlist(OP *o)</code></pre>

</dd>
<dt id="finalize_op">finalize_op </dt>
<dd>

<p>Calls several op-specific finalizers, warnings and fixups.</p>

<pre><code>        void    finalize_op(OP* o)</code></pre>

</dd>
<dt id="finalize_optree">finalize_optree </dt>
<dd>

<p>This function finalizes the optree. Should be called directly after the complete optree is built. It does some additional checking which can&#39;t be done in the normal <code>ck_</code>xxx functions and makes the tree thread-safe.</p>

<pre><code>        void    finalize_optree(OP* o)</code></pre>

</dd>
<dt id="invert">invert </dt>
<dd>

<p>Add a unary NOT op in front, inverting the op.</p>

<pre><code>        OP*     invert(OP* cmd)</code></pre>

</dd>
<dt id="list">list </dt>
<dd>

<p>Sets list context for the op.</p>

<pre><code>        OP*     list(OP* o)</code></pre>

</dd>
<dt id="listkids">listkids </dt>
<dd>

<p>Sets list context for all kids.</p>

<pre><code>        OP*     listkids(OP* o)</code></pre>

</dd>
<dt id="maybe_multiconcat">maybe_multiconcat </dt>
<dd>

<p>NOTE: this function is experimental and may change or be removed without notice.</p>

<p>Given an OP_STRINGIFY, OP_SASSIGN, OP_CONCAT or OP_SPRINTF op, possibly convert it (and its children) into an OP_MULTICONCAT. See the code comments just before pp_multiconcat() for the full details of what OP_MULTICONCAT supports.</p>

<p>Basically we&#39;re looking for an optree with a chain of OP_CONCATS down the LHS (or an OP_SPRINTF), with possibly an OP_SASSIGN, and/or OP_STRINGIFY, and/or OP_CONCAT acting as &#39;.=&#39; at its head, e.g.</p>

<pre><code>     $x = &quot;$a$b-$c&quot;

 looks like

     SASSIGN
        |
     STRINGIFY   -- PADSV[$x]
        |
        |
     ex-PUSHMARK -- CONCAT/S
                       |
                    CONCAT/S  -- PADSV[$d]
                       |
                    CONCAT    -- CONST[&quot;-&quot;]
                       |
                    PADSV[$a] -- PADSV[$b]</code></pre>

<p>Note that at this stage the OP_SASSIGN may have already been optimised away with OPpTARGET_MY set on the OP_STRINGIFY or OP_CONCAT.</p>

<pre><code>        void    maybe_multiconcat(OP *o)</code></pre>

</dd>
<dt id="maybe_op_signature">maybe_op_signature </dt>
<dd>

<p>Does fake_signatures. If the sub starts with &#39;my (...) = @_&#39;, replace those ops with an OP_SIGNATURE. Here we don&#39;t have to add the default $self invocant.</p>

<p>Cannot handle shift as this leaves leftover args.</p>

<pre><code>                maybe_op_signature;</code></pre>

</dd>
<dt id="modkids">modkids </dt>
<dd>

<p>Sets lvalue context for all kids.</p>

<pre><code>        OP*     modkids(OP *o, I32 type)</code></pre>

</dd>
<dt id="move_proto_attr">move_proto_attr </dt>
<dd>

<p>Move a run-time attribute to a compile-time prototype handling, as with :prototype(...)</p>

<p>Set CV prototype in name from :prototype() attribute.</p>

<pre><code>        void    move_proto_attr(OP **proto, OP **attrs,
                                const GV *name, bool curstash)</code></pre>

</dd>
<dt id="my_attrs">my_attrs </dt>
<dd>

<p>Prepend the lexical variable with the attribute-&gt;import call.</p>

<pre><code>        OP *    my_attrs(OP *o, OP *attrs)</code></pre>

</dd>
<dt id="my_kid-OP-my_kid-OP-o-OP-attrs-OP-imopsp">my_kid  OP * my_kid(OP *o, OP *attrs, OP **imopsp)</dt>
<dd>

</dd>
<dt id="newASSIGNOP_maybe_const">newASSIGNOP_maybe_const </dt>
<dd>

<p>Checks the attrs of the left if it has const. If so check dissect my_attrs() and check if there&#39;s another attr. If so defer attribute-&gt;import to run-time. If not just const the left side.</p>

<p>OpSPECIAL on the assign op denotes :const. Undo temp. READONLY-ness via a private OPpASSIGN_CONSTINIT bit during assignment at run-time.</p>

<p>Do various compile-time assignments on const rhs values, to enable constant folding. my @a[] = (...) comes also here, setting the computed lhs AvSHAPED size.</p>

<p>Return the newASSIGNOP, or the folded assigned value.</p>

<pre><code>        OP*     newASSIGNOP_maybe_const(OP* left, I32 optype,
                                        OP* right)</code></pre>

</dd>
<dt id="newATTRSUB_x">newATTRSUB_x </dt>
<dd>

<p>Construct a Perl subroutine, also performing some surrounding jobs.</p>

<p>This function is expected to be called in a Perl compilation context, and some aspects of the subroutine are taken from global variables associated with compilation. In particular, <code>PL_compcv</code> represents the subroutine that is currently being compiled. It must be non-null when this function is called, and some aspects of the subroutine being constructed are taken from it. The constructed subroutine may actually be a reuse of the <code>PL_compcv</code> object, but will not necessarily be so.</p>

<p>If <code>block</code> is null then the subroutine will have no body, and for the time being it will be an error to call it. This represents a forward subroutine declaration such as <span style="white-space: nowrap;"><code>sub foo ($$);</code></span>. If <code>block</code> is non-null then it provides the Perl code of the subroutine body, which will be executed when the subroutine is called. This body includes any argument unwrapping code resulting from a subroutine signature or similar. The pad use of the code must correspond to the pad attached to <code>PL_compcv</code>. The code is not expected to include a <code>leavesub</code> or <code>leavesublv</code> op; this function will add such an op. <code>block</code> is consumed by this function and will become part of the constructed subroutine.</p>

<p><code>proto</code> specifies the subroutine&#39;s prototype, unless one is supplied as an attribute (see below). If <code>proto</code> is null, then the subroutine will not have a prototype. If <code>proto</code> is non-null, it must point to a <code>const</code> op whose value is a string, and the subroutine will have that string as its prototype. If a prototype is supplied as an attribute, the attribute takes precedence over <code>proto</code>, but in that case <code>proto</code> should preferably be null. In any case, <code>proto</code> is consumed by this function.</p>

<p><code>attrs</code> supplies attributes to be applied the subroutine. A handful of attributes take effect by built-in means, being applied to <code>PL_compcv</code> immediately when seen. Other attributes are collected up and attached to the subroutine by this route. <code>attrs</code> may be null to supply no attributes, or point to a <code>const</code> op for a single attribute, or point to a <code>list</code> op whose children apart from the <code>pushmark</code> are <code>const</code> ops for one or more attributes. Each <code>const</code> op must be a string, giving the attribute name optionally followed by parenthesised arguments, in the manner in which attributes appear in Perl source. The attributes will be applied to the sub by this function. <code>attrs</code> is consumed by this function.</p>

<p>If <code>o_is_gv</code> is false and <code>o</code> is null, then the subroutine will be anonymous. If <code>o_is_gv</code> is false and <code>o</code> is non-null, then <code>o</code> must point to a <code>const</code> op, which will be consumed by this function, and its string value supplies a name for the subroutine. The name may be qualified or unqualified, and if it is unqualified then a default stash will be selected in some manner. If <code>o_is_gv</code> is true, then <code>o</code> doesn&#39;t point to an <code>OP</code> at all, but is instead a cast pointer to a <code>GV</code> by which the subroutine will be named.</p>

<p>If there is already a subroutine of the specified name, then the new sub will either replace the existing one in the glob or be merged with the existing one. A warning may be generated about redefinition. Likewise if a package with the same name exists already, a shadow warning is generated about the inaccessibility of the package.</p>

<p>If the subroutine has one of a few special names, such as <code>BEGIN</code> or <code>END</code>, then it will be claimed by the appropriate queue for automatic running of phase-related subroutines. In this case the relevant glob will be left not containing any subroutine, even if it did contain one before. In the case of <code>BEGIN</code>, the subroutine will be executed and the reference to it disposed of before this function returns.</p>

<p>The function returns a pointer to the constructed subroutine. If the sub is anonymous then ownership of one counted reference to the subroutine is transferred to the caller. If the sub is named then the caller does not get ownership of a reference. In most such cases, where the sub has a non-phase name, the sub will be alive at the point it is returned by virtue of being contained in the glob that names it. A phase-named subroutine will usually be alive by virtue of the reference owned by the phase&#39;s automatic run queue. But a <code>BEGIN</code> subroutine, having already been executed, will quite likely have been destroyed already by the time this function returns, making it erroneous for the caller to make any use of the returned pointer. It is the caller&#39;s responsibility to ensure that it knows which of these situations applies.</p>

<pre><code>        CV *    newATTRSUB_x(I32 floor, OP *o, OP *proto,
                             OP *attrs, OP *block, bool o_is_gv)</code></pre>

</dd>
<dt id="newXS_len_flags">newXS_len_flags </dt>
<dd>

<p>Construct an XS subroutine, also performing some surrounding jobs.</p>

<p>The subroutine will have the entry point <code>subaddr</code>. It will have the prototype specified by the nul-terminated string <code>proto</code>, or no prototype if <code>proto</code> is null. The prototype string is copied; the caller can mutate the supplied string afterwards. If <code>filename</code> is non-null, it must be a nul-terminated filename, and the subroutine will have its <code>CvFILE</code> set accordingly. By default <code>CvFILE</code> is set to point directly to the supplied string, which must be static. If <code>flags</code> has the <code>XS_DYNAMIC_FILENAME</code> bit set, then a copy of the string will be taken instead.</p>

<p>Other aspects of the subroutine will be left in their default state. If anything else needs to be done to the subroutine for it to function correctly, it is the caller&#39;s responsibility to do that after this function has constructed it. However, beware of the subroutine potentially being destroyed before this function returns, as described below.</p>

<p>If <code>name</code> is null then the subroutine will be anonymous, with its <code>CvGV</code> referring to an <code>__ANON__</code> glob. If <code>name</code> is non-null then the subroutine will be named accordingly, referenced by the appropriate glob. <code>name</code> is a string of length <code>len</code> bytes giving a sigilless symbol name, in UTF-8 if <code>flags</code> has the <code>SVf_UTF8</code> bit set and in Latin-1 otherwise. The name may be either qualified or unqualified, with the stash defaulting in the same manner as for <code>gv_fetchpvn_flags</code>. <code>flags</code> may contain flag bits understood by <code>gv_fetchpvn_flags</code> with the same meaning as they have there, such as <code>GV_ADDWARN</code>. The symbol is always added to the stash if necessary, with <code>GV_ADDMULTI</code> semantics. CvFLAGS are not valid <code>flags</code>, only <code>GV_</code> flags.</p>

<p>If there is already a subroutine of the specified name, then the new sub will replace the existing one in the glob. A warning may be generated about the redefinition. If the old subroutine was <code>CvCONST</code> then the decision about whether to warn is influenced by an expectation about whether the new subroutine will become a constant of similar value. That expectation is determined by <code>const_svp</code>. (Note that the call to this function doesn&#39;t make the new subroutine <code>CvCONST</code> in any case; that is left to the caller.) If <code>const_svp</code> is null then it indicates that the new subroutine will not become a constant. If <code>const_svp</code> is non-null then it indicates that the new subroutine will become a constant, and it points to an <code>SV*</code> that provides the constant value that the subroutine will have.</p>

<p>If the subroutine has one of a few special names, such as <code>BEGIN</code> or <code>END</code>, then it will be claimed by the appropriate queue for automatic running of phase-related subroutines. In this case the relevant glob will be left not containing any subroutine, even if it did contain one before. In the case of <code>BEGIN</code>, the subroutine will be executed and the reference to it disposed of before this function returns, and also before its prototype is set. If a <code>BEGIN</code> subroutine would not be sufficiently constructed by this function to be ready for execution then the caller must prevent this happening by giving the subroutine a different name.</p>

<p>The function returns a pointer to the constructed subroutine. If the sub is anonymous then ownership of one counted reference to the subroutine is transferred to the caller. If the sub is named then the caller does not get ownership of a reference. In most such cases, where the sub has a non-phase name, the sub will be alive at the point it is returned by virtue of being contained in the glob that names it. A phase-named subroutine will usually be alive by virtue of the reference owned by the phase&#39;s automatic run queue. But a <code>BEGIN</code> subroutine, having already been executed, will quite likely have been destroyed already by the time this function returns, making it erroneous for the caller to make any use of the returned pointer. It is the caller&#39;s responsibility to ensure that it knows which of these situations applies.</p>

<pre><code>        CV *    newXS_len_flags(const char *name, STRLEN len,
                                XSUBADDR_t subaddr,
                                const char *const filename,
                                NULLOK const char *const proto,
                                NULLOK SV **const_svp,
                                U32 flags)</code></pre>

</dd>
<dt id="op_clear">op_clear </dt>
<dd>

<p>free all the SVs (gv, pad, ...) attached to the op.</p>

<p>NOTE: the perl_ form of this function is deprecated.</p>

<pre><code>        void    op_clear(OP* o)</code></pre>

</dd>
<dt id="op_clear_gv">op_clear_gv </dt>
<dd>

<p>Free a GV attached to an OP</p>

<pre><code>        void    op_clear_gv(OP* o, PADOFFSET *ixp)</code></pre>

</dd>
<dt id="op_const_sv">op_const_sv </dt>
<dd>

<p>op_const_sv: examine an optree to determine whether it&#39;s in-lineable into a single CONST op. It walks the tree in exec order (next), not in tree order (sibling, first).</p>

<p>Can be called in 2 ways:</p>

<p>!allow_lex look for a single OP_CONST with attached value: return the value</p>

<p>allow_lex &amp;&amp; !CvCONST(cv);</p>

<pre><code>        examine the clone prototype, and if contains only a single
        OP_CONST, return the value; or if it contains a single PADSV ref-
        erencing an outer lexical, turn on CvCONST to indicate the CV is
        a candidate for &quot;constizing&quot; at clone time, and return NULL.
                op_const_sv;</code></pre>

</dd>
<dt id="op_gv_set">op_gv_set </dt>
<dd>

<p>Set the gv as the op_sv. With threads also relocate a gv to the pad for thread safety. cperl-only</p>

<pre><code>        void    op_gv_set(OP* o, GV* gv)</code></pre>

</dd>
<dt id="op_relocate_sv">op_relocate_sv </dt>
<dd>

<p>Relocate sv to the pad for thread safety. Despite being a &quot;constant&quot;, the SV is written to, for reference counts, sv_upgrade() etc.</p>

<pre><code>        void    op_relocate_sv(SV** svp, PADOFFSET* targp)</code></pre>

</dd>
<dt id="op_sibling_newUNOP">op_sibling_newUNOP </dt>
<dd>

<p>replace the sibling following start with a new UNOP, which becomes the parent of the original sibling; e.g.</p>

<pre><code>   op_sibling_newUNOP(P, A, unop-args...)
  
   P              P
   |      becomes |
   A-B-C          A-U-C
                    |
                    B</code></pre>

<p>where U is the new UNOP.</p>

<p>parent and start args are the same as for op_sibling_splice(); type and flags args are as newUNOP().</p>

<p>Returns the new UNOP.</p>

<pre><code>                op_sibling_newUNOP;</code></pre>

</dd>
<dt id="optimize_op">optimize_op </dt>
<dd>

<p>Helper for optimize_optree() which optimises a single op then recurses to optimise any children.</p>

<pre><code>        void    optimize_op(OP* o)</code></pre>

</dd>
<dt id="optimize_optree">optimize_optree </dt>
<dd>

<p>This function applies some optimisations to the optree in top-down order. It is called before the peephole optimizer, which processes ops in execution order. Note that finalize_optree() also does a top-down scan, but is called *after* the peephole optimizer.</p>

<pre><code>        void    optimize_optree(OP* o)</code></pre>

</dd>
<dt id="op_unscope">op_unscope </dt>
<dd>

<p>NOTE: this function is experimental and may change or be removed without notice.</p>

<p>Nullify all state ops in the kids of a lineseq.</p>

<pre><code>        OP*     op_unscope(OP* o)</code></pre>

</dd>
<dt id="process_optree">process_optree </dt>
<dd>

<p>NOTE: this function is experimental and may change or be removed without notice.</p>

<p>Do the post-compilation processing of an op_tree with specified root and start</p>

<pre><code>  * attach it to cv (if non-null)
  * set refcnt
  * run pre-peep optimizer, peep, finalize, prune an empty head, etc
  * tidy pad

                process_optree;</code></pre>

</dd>
<dt id="refkids">refkids </dt>
<dd>

<p>Sets ref context for all kids.</p>

<pre><code>        OP*     refkids(OP* o, I32 type)</code></pre>

</dd>
<dt id="sawparens-OP-sawparens-OP-o">sawparens  OP* sawparens(OP* o)</dt>
<dd>

</dd>
<dt id="scalarboolean">scalarboolean </dt>
<dd>

<p>Checks boolean context for the op, merely for syntax warnings.</p>

<p>Note: We cannot <a href="#set_boolean">&quot;set_boolean&quot;</a> context here, as some ops still require the non-boolified stackvalue. See <a href="#check_for_bool_cxt">&quot;check_for_bool_cxt&quot;</a>.</p>

<pre><code>                scalarboolean;</code></pre>

</dd>
<dt id="scalarkids">scalarkids </dt>
<dd>

<p>Sets scalar context for all kids.</p>

<pre><code>                scalarkids;</code></pre>

</dd>
<dt id="scalarseq">scalarseq </dt>
<dd>

<p>Sets scalar void context for scalar sequences: lineseq, scope, leave and leavetry.</p>

<pre><code>        OP*     scalarseq(OP* o)</code></pre>

</dd>
<dt id="scalarvoid">scalarvoid </dt>
<dd>

<p>Assigns scalar void context to the optree, i.e. it takes only a scalar argument, no list and returns nothing.</p>

<pre><code>        OP*     scalarvoid(OP* o)</code></pre>

</dd>
<dt id="set_boolean">set_boolean </dt>
<dd>

<p>Force the op to be in boolean context, similar to <a href="#scalar">&quot;scalar&quot;</a> and <a href="#scalarboolean">&quot;scalarboolean&quot;</a> This just abstracts away the various private TRUEBOOL flag values.</p>

<pre><code>        OP*     set_boolean(OP *o)</code></pre>

</dd>
<dt id="traverse_op_tree">traverse_op_tree </dt>
<dd>

<p>Return the next op in a depth-first traversal of the op tree, returning NULL when the traversal is complete.</p>

<p>The initial call must supply the root of the tree as both top and o.</p>

<p>For now it&#39;s static, but it may be exposed to the API in the future.</p>

<pre><code>                traverse_op_tree;</code></pre>

</dd>
</dl>

<h1 id="Pad-Data-Structures">Pad Data Structures</h1>

<dl>

<dt id="CX_CURPAD_SAVE">CX_CURPAD_SAVE </dt>
<dd>

<p>Save the current pad in the given context block_loop structure. With threads only.</p>

<pre><code>        void    CX_CURPAD_SAVE(struct context)</code></pre>

</dd>
<dt id="CX_CURPAD_SV">CX_CURPAD_SV </dt>
<dd>

<p>Access the SV at offset <code>po</code> in the saved current pad in the given context block_loop structure (can be used as an lvalue). With threads only.</p>

<pre><code>        SV *    CX_CURPAD_SV(struct context, PADOFFSET po)</code></pre>

</dd>
<dt id="PAD_BASE_SV">PAD_BASE_SV </dt>
<dd>

<p>Get the value from slot <code>po</code> in the base (DEPTH=1) pad of a padlist</p>

<pre><code>        SV *    PAD_BASE_SV(PADLIST padlist, PADOFFSET po)</code></pre>

</dd>
<dt id="PAD_CLONE_VARS">PAD_CLONE_VARS </dt>
<dd>

<p>Clone the state variables associated with running and compiling pads.</p>

<pre><code>        void    PAD_CLONE_VARS(PerlInterpreter *proto_perl,
                               CLONE_PARAMS* param)</code></pre>

</dd>
<dt id="PAD_COMPNAME_FLAGS">PAD_COMPNAME_FLAGS </dt>
<dd>

<p>Return the flags for the current compiling pad name at offset <code>po</code>. Assumes a valid slot entry.</p>

<pre><code>        U32     PAD_COMPNAME_FLAGS(PADOFFSET po)</code></pre>

</dd>
<dt id="PAD_COMPNAME_GEN">PAD_COMPNAME_GEN </dt>
<dd>

<p>The generation number of the name at offset <code>po</code> in the current compiling pad (lvalue).</p>

<pre><code>        STRLEN  PAD_COMPNAME_GEN(PADOFFSET po)</code></pre>

</dd>
<dt id="PAD_COMPNAME_GEN_set">PAD_COMPNAME_GEN_set </dt>
<dd>

<p>Sets the generation number of the name at offset <code>po</code> in the current compiling pad (lvalue) to <code>gen</code>. STRLEN PAD_COMPNAME_GEN_set(PADOFFSET po, int gen)</p>

</dd>
<dt id="PAD_COMPNAME_OURSTASH">PAD_COMPNAME_OURSTASH </dt>
<dd>

<p>Return the stash associated with an <code>our</code> variable. Assumes the slot entry is a valid <code>our</code> lexical.</p>

<pre><code>        HV *    PAD_COMPNAME_OURSTASH(PADOFFSET po)</code></pre>

</dd>
<dt id="PAD_COMPNAME_PV">PAD_COMPNAME_PV </dt>
<dd>

<p>Return the name of the current compiling pad name at offset <code>po</code>. Assumes a valid slot entry.</p>

<pre><code>        char *  PAD_COMPNAME_PV(PADOFFSET po)</code></pre>

</dd>
<dt id="PAD_COMPNAME_TYPE">PAD_COMPNAME_TYPE </dt>
<dd>

<p>Return the type (stash) of the current compiling pad name at offset <code>po</code>. Must be a valid name. Returns null if not typed.</p>

<pre><code>        HV *    PAD_COMPNAME_TYPE(PADOFFSET po)</code></pre>

</dd>
<dt id="PadnameIsOUR">PadnameIsOUR </dt>
<dd>

<p>Whether this is an &quot;our&quot; variable.</p>

<pre><code>        bool    PadnameIsOUR(PADNAME pn)</code></pre>

</dd>
<dt id="PadnameIsSTATE">PadnameIsSTATE </dt>
<dd>

<p>Whether this is a &quot;state&quot; variable.</p>

<pre><code>        bool    PadnameIsSTATE(PADNAME pn)</code></pre>

</dd>
<dt id="PadnameOURSTASH">PadnameOURSTASH </dt>
<dd>

<p>The stash in which this &quot;our&quot; variable was declared.</p>

<pre><code>        HV *    PadnameOURSTASH()</code></pre>

</dd>
<dt id="PadnameOUTER">PadnameOUTER </dt>
<dd>

<p>Whether this entry belongs to an outer pad. Entries for which this is true are often referred to as &#39;fake&#39;.</p>

<pre><code>        bool    PadnameOUTER(PADNAME pn)</code></pre>

</dd>
<dt id="PadnameTYPE">PadnameTYPE </dt>
<dd>

<p>The stash associated with a typed lexical. This returns the <code>%Foo::</code> hash for <code>my Foo $bar</code>.</p>

<pre><code>        HV *    PadnameTYPE(PADNAME pn)</code></pre>

</dd>
<dt id="PAD_RESTORE_LOCAL">PAD_RESTORE_LOCAL </dt>
<dd>

<p>Restore the old pad saved into the local variable <code>opad</code> by <code>PAD_SAVE_LOCAL()</code></p>

<pre><code>        void    PAD_RESTORE_LOCAL(PAD *opad)</code></pre>

</dd>
<dt id="PAD_SAVE_LOCAL">PAD_SAVE_LOCAL </dt>
<dd>

<p>Save the current pad to the local variable <code>opad</code>, then make the current pad equal to <code>npad</code></p>

<pre><code>        void    PAD_SAVE_LOCAL(PAD *opad, PAD *npad)</code></pre>

</dd>
<dt id="PAD_SAVE_SETNULLPAD">PAD_SAVE_SETNULLPAD </dt>
<dd>

<p>Save the current pad then set it to null.</p>

<pre><code>        void    PAD_SAVE_SETNULLPAD()</code></pre>

</dd>
<dt id="PAD_SETSV">PAD_SETSV </dt>
<dd>

<p>Set the slot at offset <code>po</code> in the current pad to <code>sv</code></p>

<pre><code>        SV *    PAD_SETSV(PADOFFSET po, SV* sv)</code></pre>

</dd>
<dt id="PAD_SET_CUR">PAD_SET_CUR </dt>
<dd>

<p>Set the current pad to be pad <code>n</code> in the padlist, saving the previous current pad. NB currently this macro expands to a string too long for some compilers, so it&#39;s best to replace it with</p>

<pre><code>    SAVECOMPPAD();
    PAD_SET_CUR_NOSAVE(padlist,n);


        void    PAD_SET_CUR(PADLIST padlist, I32 n)</code></pre>

</dd>
<dt id="PAD_SET_CUR_NOSAVE">PAD_SET_CUR_NOSAVE </dt>
<dd>

<p>like PAD_SET_CUR, but without the save</p>

<pre><code>        void    PAD_SET_CUR_NOSAVE(PADLIST padlist, I32 n)</code></pre>

</dd>
<dt id="PAD_SV">PAD_SV </dt>
<dd>

<p>Get the value at offset <code>po</code> in the current pad</p>

<pre><code>        SV *    PAD_SV(PADOFFSET po)</code></pre>

</dd>
<dt id="PAD_SVl">PAD_SVl </dt>
<dd>

<p>Lightweight and lvalue version of <code>PAD_SV</code>. Get or set the value at offset <code>po</code> in the current pad. Unlike <code>PAD_SV</code>, does not print diagnostics with -DX. For internal use only.</p>

<pre><code>        SV *    PAD_SVl(PADOFFSET po)</code></pre>

</dd>
<dt id="SAVECLEARSV">SAVECLEARSV </dt>
<dd>

<p>Clear the pointed to pad value on scope exit. (i.e. the runtime action of <code>my</code>)</p>

<pre><code>        void    SAVECLEARSV(SV **svp)</code></pre>

</dd>
<dt id="SAVECOMPPAD">SAVECOMPPAD </dt>
<dd>

<p>save <code>PL_comppad</code> and <code>PL_curpad</code></p>

<pre><code>        void    SAVECOMPPAD()</code></pre>

</dd>
<dt id="SAVEPADSV">SAVEPADSV </dt>
<dd>

<p>Save a pad slot (used to restore after an iteration)</p>

<p>XXX DAPM it would make more sense to make the arg a PADOFFSET void SAVEPADSV(PADOFFSET po)</p>

</dd>
</dl>

<h1 id="Per-Interpreter-Variables">Per-Interpreter Variables</h1>

<dl>

<dt id="PL_DBsingle">PL_DBsingle </dt>
<dd>

<p>When Perl is run in debugging mode, with the <b>-d</b> switch, this SV is a boolean which indicates whether subs are being single-stepped. Single-stepping is automatically turned on after every step. This is the C variable which corresponds to Perl&#39;s $DB::single variable. See <code><a href="#PL_DBsub">&quot;PL_DBsub&quot;</a></code>.</p>

<pre><code>        SV *    PL_DBsingle</code></pre>

</dd>
<dt id="PL_DBsub">PL_DBsub </dt>
<dd>

<p>When Perl is run in debugging mode, with the <b>-d</b> switch, this GV contains the SV which holds the name of the sub being debugged. This is the C variable which corresponds to Perl&#39;s $DB::sub variable. See <code><a href="#PL_DBsingle">&quot;PL_DBsingle&quot;</a></code>.</p>

<pre><code>        GV *    PL_DBsub</code></pre>

</dd>
<dt id="PL_DBtrace">PL_DBtrace </dt>
<dd>

<p>Trace variable used when Perl is run in debugging mode, with the <b>-d</b> switch. This is the C variable which corresponds to Perl&#39;s $DB::trace variable. See <code><a href="#PL_DBsingle">&quot;PL_DBsingle&quot;</a></code>.</p>

<pre><code>        SV *    PL_DBtrace</code></pre>

</dd>
<dt id="PL_dowarn">PL_dowarn </dt>
<dd>

<p>The C variable that roughly corresponds to Perl&#39;s <code>$^W</code> warning variable. However, <code>$^W</code> is treated as a boolean, whereas <code>PL_dowarn</code> is a collection of flag bits.</p>

<pre><code>        U8      PL_dowarn</code></pre>

</dd>
<dt id="PL_last_in_gv">PL_last_in_gv </dt>
<dd>

<p>The GV which was last used for a filehandle input operation. (<code>&lt;FH&gt;</code>)</p>

<pre><code>        GV*     PL_last_in_gv</code></pre>

</dd>
<dt id="PL_ofsgv">PL_ofsgv </dt>
<dd>

<p>The glob containing the output field separator - <code>*,</code> in Perl space.</p>

<pre><code>        GV*     PL_ofsgv</code></pre>

</dd>
<dt id="PL_rs">PL_rs </dt>
<dd>

<p>The input record separator - <code>$/</code> in Perl space.</p>

<pre><code>        SV*     PL_rs</code></pre>

</dd>
</dl>

<h1 id="Stack-Manipulation-Macros">Stack Manipulation Macros</h1>

<dl>

<dt id="djSP">djSP </dt>
<dd>

<p>Declare Just <code>SP</code>. This is actually identical to <code>dSP</code>, and declares a local copy of perl&#39;s stack pointer, available via the <code>SP</code> macro. See <code><a href="/cperl/perlapi.html#SP">&quot;SP&quot; in perlapi</a></code>. (Available for backward source code compatibility with the old (Perl 5.005) thread model.)</p>

<pre><code>                djSP;</code></pre>

</dd>
<dt id="LVRET">LVRET </dt>
<dd>

<p>True if this op will be the return value of an lvalue subroutine</p>

</dd>
</dl>

<h1 id="SV-Manipulation-Functions">SV Manipulation Functions</h1>

<p>An SV (or AV, HV, etc.) is allocated in two parts: the head (struct sv, av, hv...) contains type and reference count information, and for many types, a pointer to the body (struct xrv, xpv, xpviv...), which contains fields specific to each type. Some types store all they need in the head, so don&#39;t have a body.</p>

<p>In all but the most memory-paranoid configurations (ex: PURIFY), heads and bodies are allocated out of arenas, which by default are approximately 4K chunks of memory parcelled up into N heads or bodies. Sv-bodies are allocated by their sv-type, guaranteeing size consistency needed to allocate safely from arrays.</p>

<p>For SV-heads, the first slot in each arena is reserved, and holds a link to the next arena, some flags, and a note of the number of slots. Snaked through each arena chain is a linked list of free items; when this becomes empty, an extra arena is allocated and divided up into N items which are threaded into the free list.</p>

<p>SV-bodies are similar, but they use arena-sets by default, which separate the link and info from the arena itself, and reclaim the 1st slot in the arena. SV-bodies are further described later.</p>

<p>The following global variables are associated with arenas:</p>

<pre><code> PL_sv_arenaroot     pointer to list of SV arenas
 PL_sv_root          pointer to list of free SV structures

 PL_body_arenas      head of linked-list of body arenas
 PL_body_roots[]     array of pointers to list of free bodies of svtype
                     arrays are indexed by the svtype needed</code></pre>

<p>A few special SV heads are not allocated from an arena, but are instead directly created in the interpreter structure, eg PL_sv_undef. The size of arenas can be changed from the default by setting PERL_ARENA_SIZE appropriately at compile time.</p>

<p>The SV arena serves the secondary purpose of allowing still-live SVs to be located and destroyed during final cleanup.</p>

<p>At the lowest level, the macros new_SV() and del_SV() grab and free an SV head. (If debugging with -DD, del_SV() calls the function S_del_sv() to return the SV to the free list with error checking.) new_SV() calls more_sv() / sv_add_arena() to add an extra arena if the free list is empty. SVs in the free list have their SvTYPE field set to all ones.</p>

<p>At the time of very final cleanup, sv_free_arenas() is called from perl_destruct() to physically free all the arenas allocated since the start of the interpreter.</p>

<p>The function visit() scans the SV arenas list, and calls a specified function for each SV it finds which is still live - ie which has an SvTYPE other than all 1&#39;s, and a non-zero SvREFCNT. visit() is used by the following functions (specified as [function that calls visit()] / [function called by visit() for each SV]):</p>

<pre><code>    sv_report_used() / do_report_used()
                        dump all remaining SVs (debugging aid)

    sv_clean_objs() / do_clean_objs(),do_clean_named_objs(),
                      do_clean_named_io_objs(),do_curse()
                        Attempt to free all objects pointed to by RVs,
                        try to do the same for all objects indir-
                        ectly referenced by typeglobs too, and
                        then do a final sweep, cursing any
                        objects that remain.  Called once from
                        perl_destruct(), prior to calling sv_clean_all()
                        below.

    sv_clean_all() / do_clean_all()
                        SvREFCNT_dec(sv) each remaining SV, possibly
                        triggering an sv_free(). It also sets the
                        SVf_BREAK flag on the SV to indicate that the
                        refcnt has been artificially lowered, and thus
                        stopping sv_free() from giving spurious warnings
                        about SVs which unexpectedly have a refcnt
                        of zero.  called repeatedly from perl_destruct()
                        until there are no SVs left.</code></pre>

<dl>

<dt id="anonymise_cv_maybe">anonymise_cv_maybe </dt>
<dd>

<p>We&#39;re about to free a GV which has a CV that refers back to us. If that CV will outlive us, make it anonymous (i.e. fix up its CvGV field)</p>

<pre><code>        void    anonymise_cv_maybe(GV *gv, CV *cv)</code></pre>

</dd>
<dt id="sv_2num">sv_2num </dt>
<dd>

<p>NOTE: this function is experimental and may change or be removed without notice.</p>

<p>Return an SV with the numeric value of the source SV, doing any necessary reference or overload conversion. The caller is expected to have handled get-magic already.</p>

<pre><code>        SV*     sv_2num(SV *const sv)</code></pre>

</dd>
<dt id="sv_add_arena">sv_add_arena </dt>
<dd>

<p>Given a chunk of memory, link it to the head of the list of arenas, and split it into a list of free SVs.</p>

<pre><code>        void    sv_add_arena(char *const ptr, const U32 size,
                             const U32 flags)</code></pre>

</dd>
<dt id="sv_add_backref">sv_add_backref </dt>
<dd>

<p>Give tsv backref magic if it hasn&#39;t already got it, then push a back-reference to sv onto the array associated with the backref magic.</p>

<p>As an optimisation, if there&#39;s only one backref and it&#39;s not an AV, store it directly in the HvAUX or mg_obj slot, avoiding the need to allocate an AV. (Whether the slot holds an AV tells us whether this is active.)</p>

<p>A discussion about the backreferences array and its refcount:</p>

<p>The AV holding the backreferences is pointed to either as the <code>mg_obj</code> of <code>PERL_MAGIC_backref</code>, or in the specific case of a HV, from the <code>xhv_backreferences</code> field. The array is created with a refcount of 2. This means that if during global destruction the array gets picked on before its parent to have its refcount decremented by the random zapper, it won&#39;t actually be freed, meaning it&#39;s still there for when its parent gets freed.</p>

<p>When the parent SV is freed, the extra ref is killed by <a href="/cperl/perlintern.html#sv_kill_backrefs">&quot;sv_kill_backrefs&quot; in perlintern</a>. The other ref is killed, in the case of magic, by <a href="/cperl/perlapi.html#mg_free">&quot;mg_free&quot; in perlapi</a> / <code>MGf_REFCOUNTED</code>, or for a hash, by <a href="/cperl/perlintern.html#hv_kill_backrefs">&quot;hv_kill_backrefs&quot; in perlintern</a>.</p>

<p>When a single backref SV is stored directly, it is not reference counted.</p>

<pre><code>        void    sv_add_backref(SV *const tsv, SV *const sv)</code></pre>

</dd>
<dt id="sv_clean_all">sv_clean_all </dt>
<dd>

<p>Decrement the refcnt of each remaining SV, possibly triggering a cleanup. This function may have to be called multiple times to free SVs which are in complex self-referential hierarchies.</p>

<pre><code>        Size_t  sv_clean_all()</code></pre>

</dd>
<dt id="sv_del_backref">sv_del_backref </dt>
<dd>

<p>Delete a back-reference to ourselves from the backref magic associated with the SV we point to.</p>

<pre><code>        void    sv_del_backref(SV *const tsv, SV *const sv)</code></pre>

</dd>
<dt id="sv_free2">sv_free2 </dt>
<dd>

<p>NOTE: this function is experimental and may change or be removed without notice.</p>

<p>Private helper function for SvREFCNT_dec(). Called with rc set to original SvREFCNT(sv), where rc == 0 or 1</p>

<pre><code>        void    sv_free2(SV *const sv, const U32 refcnt)</code></pre>

</dd>
<dt id="sv_free_arenas">sv_free_arenas </dt>
<dd>

<p>Deallocate the memory used by all arenas. Note that all the individual SV heads and bodies within the arenas must already have been freed.</p>

<pre><code>        void    sv_free_arenas()</code></pre>

</dd>
<dt id="sv_kill_backrefs">sv_kill_backrefs </dt>
<dd>

<p>NOTE: this function is experimental and may change or be removed without notice.</p>

<p>Delete all back-references to ourselves from the backreferences array.</p>

<pre><code>        void    sv_kill_backrefs(SV *const sv, AV *const av)</code></pre>

</dd>
<dt id="sv_len_utf8_nomg">sv_len_utf8_nomg </dt>
<dd>

<p>Returns the number of characters in the string in an SV, counting wide UTF-8 bytes as a single character. Ignores get magic.</p>

<pre><code>        STRLEN  sv_len_utf8_nomg(SV *const sv)</code></pre>

</dd>
<dt id="SvTHINKFIRST">SvTHINKFIRST </dt>
<dd>

<p>A quick flag check to see whether an <code>sv</code> should be passed to <code>sv_force_normal</code> to be &quot;downgraded&quot; before <code>SvIVX</code> or <code>SvPVX</code> can be modified directly.</p>

<p>For example, if your scalar is a reference and you want to modify the <code>SvIVX</code> slot, you can&#39;t just do <code>SvROK_off</code>, as that will leak the referent.</p>

<p>This is used internally by various sv-modifying functions, such as <code>sv_setsv</code>, <code>sv_setiv</code> and <code>sv_pvn_force</code>.</p>

<p>One case that this does not handle is a gv without SvFAKE set. After</p>

<pre><code>    if (SvTHINKFIRST(gv)) sv_force_normal(gv);</code></pre>

<p>it will still be a gv.</p>

<p><code>SvTHINKFIRST</code> sometimes produces false positives. In those cases <code>sv_force_normal</code> does nothing.</p>

<pre><code>        U32     SvTHINKFIRST(SV *sv)</code></pre>

</dd>
</dl>

<h1 id="Unicode-Support">Unicode Support</h1>

<dl>

<dt id="find_uninit_var">find_uninit_var </dt>
<dd>

<p>NOTE: this function is experimental and may change or be removed without notice.</p>

<p>Find the name of the undefined variable (if any) that caused the operator to issue a &quot;Use of uninitialized value&quot; warning. If match is true, only return a name if its value matches <code>uninit_sv</code>. So roughly speaking, if a unary operator (such as <code>OP_COS</code>) generates a warning, then following the direct child of the op may yield an <code>OP_PADSV</code> or <code>OP_GV</code> that gives the name of the undefined variable. On the other hand, with <code>OP_ADD</code> there are two branches to follow, so we only print the variable name if we get an exact match. <code>desc_p</code> points to a string pointer holding the description of the op. This may be updated if needed.</p>

<p>The name is returned as a mortal SV.</p>

<p>Assumes that <code>PL_op</code> is the OP that originally triggered the error, and that <code>PL_comppad</code>/<code>PL_curpad</code> points to the currently executing pad.</p>

<pre><code>        SV*     find_uninit_var(const OP *const obase,
                                const SV *const uninit_sv,
                                bool match, const char **desc_p)</code></pre>

</dd>
<dt id="isSCRIPT_RUN">isSCRIPT_RUN </dt>
<dd>

<p>Returns a bool as to whether or not the sequence of bytes from <code>s</code> up to but not including <code>send</code> form a &quot;script run&quot;. <code>utf8_target</code> is TRUE iff the sequence starting at <code>s</code> is to be treated as UTF-8. To be precise, except for two degenerate cases given below, this function returns TRUE iff all code points in it come from any combination of three &quot;scripts&quot; given by the Unicode &quot;Script Extensions&quot; property: Common, Inherited, and possibly one other. Additionally all decimal digits must come from the same consecutive sequence of 10.</p>

<p>For example, if all the characters in the sequence are Greek, or Common, or Inherited, this function will return TRUE, provided any decimal digits in it are from the same block of digits in Common. (These are the ASCII digits &quot;0&quot;..&quot;9&quot; and additionally a block for full width forms of these, and several others used in mathematical notation.) For scripts (unlike Greek) that have their own digits defined this will accept either digits from that set or from one of the Common digit sets, but not a combination of the two. Some scripts, such as Arabic, have more than one set of digits. All digits must come from the same set for this function to return TRUE.</p>

<p><code>*ret_script</code>, if <code>ret_script</code> is not NULL, will on return of TRUE contain the script found, using the <code>SCX_enum</code> typedef. Its value will be <code>SCX_INVALID</code> if the function returns FALSE.</p>

<p>If the sequence is empty, TRUE is returned, but <code>*ret_script</code> (if asked for) will be <code>SCX_INVALID</code>.</p>

<p>If the sequence contains a single code point which is unassigned to a character in the version of Unicode being used, the function will return TRUE, and the script will be <code>SCX_Unknown</code>. Any other combination of unassigned code points in the input sequence will result in the function treating the input as not being a script run.</p>

<p>The returned script will be <code>SCX_Inherited</code> iff all the code points in it are from the Inherited script.</p>

<p>Otherwise, the returned script will be <code>SCX_Common</code> iff all the code points in it are from the Inherited or Common scripts.</p>

<pre><code>        bool    isSCRIPT_RUN(const U8 *s, const U8 *send,
                             const bool utf8_target)</code></pre>

</dd>
<dt id="is_utf8_non_invariant_string">is_utf8_non_invariant_string </dt>
<dd>

<p>Returns TRUE if <a href="/cperl/perlapi.html#is_utf8_invariant_string">&quot;is_utf8_invariant_string&quot; in perlapi</a> returns FALSE for the first <code>len</code> bytes of the string <code>s</code>, but they are, nonetheless, legal Perl-extended UTF-8; otherwise returns FALSE.</p>

<p>A TRUE return means that at least one code point represented by the sequence either is a wide character not representable as a single byte, or the representation differs depending on whether the sequence is encoded in UTF-8 or not.</p>

<p>See also <code><a href="/cperl/perlapi.html#is_utf8_invariant_string">&quot;is_utf8_invariant_string&quot; in perlapi</a></code>, <code><a href="/cperl/perlapi.html#is_utf8_string">&quot;is_utf8_string&quot; in perlapi</a></code></p>

<pre><code>        bool    is_utf8_non_invariant_string(const U8* const s,
                                             STRLEN len)</code></pre>

</dd>
<dt id="report_uninit">report_uninit </dt>
<dd>

<p>Print appropriate &quot;Use of uninitialized variable&quot; warning.</p>

<pre><code>        void    report_uninit(const SV *uninit_sv)</code></pre>

</dd>
<dt id="utf8_add_script">utf8_add_script </dt>
<dd>

<p>Adds the given ASCIIZ script to %utf8::SCRIPTS, and initializes it lazily.</p>

<pre><code>        void    utf8_add_script(const char* script)</code></pre>

</dd>
<dt id="utf8_check_script">utf8_check_script </dt>
<dd>

<p>NOTE: this function is experimental and may change or be removed without notice.</p>

<p>Check if the script property of the unicode character was declared via <code>use utf8 &#39;Script&#39;</code>. If this character is the first of a not excluded valid script, add the script to the list of allowed scripts, otherwise error.</p>

<p>Note that the argument is guaranteed to be not of the Common or Latin script property.</p>

<pre><code>        void    utf8_check_script(const U8 *s)</code></pre>

</dd>
<dt id="utf8_error_script">utf8_error_script </dt>
<dd>

<p>If this character is the first non-Latin or non-Common character, and no other scripts were declared, and the script is either member of %VALID_SCRIPTS, or is not member of %utf8::EXCLUDED_SCRIPTS, then add the script to the list of allowed scripts, otherwise error.</p>

<p>%utf8::EXCLUDED_SCRIPTS map the Moderately Restrictive Level for identifiers. i.e. Allow Recommended scripts except Cyrillic and Greek.</p>

<p>Also allow Latin + :Japanese, Latin + :Hanb and Latin + :Korean, but always only the first encounter of such a combination.</p>

<p>Use an extra error message for %utf8::LIMITED_SCRIPTS errors, as this is a new restriction since v5.29.2c.</p>

<p>Note that the argument is guaranteed to be not of the Common or Latin script property.</p>

<pre><code>        void    utf8_error_script(const U8 *s,
                                  const char* script, UV uv)</code></pre>

</dd>
<dt id="uvuni_get_script">uvuni_get_script </dt>
<dd>

<p>Returns the script property as string of the unicode character.</p>

<pre><code>        char*   uvuni_get_script(const UV uv)</code></pre>

</dd>
<dt id="variant_under_utf8_count">variant_under_utf8_count </dt>
<dd>

<p>This function looks at the sequence of bytes between <code>s</code> and <code>e</code>, which are assumed to be encoded in ASCII/Latin1, and returns how many of them would change should the string be translated into UTF-8. Due to the nature of UTF-8, each of these would occupy two bytes instead of the single one in the input string. Thus, this function returns the precise number of bytes the string would expand by when translated to UTF-8.</p>

<p>Unlike most of the other functions that have <code>utf8</code> in their name, the input to this function is NOT a UTF-8-encoded string. The function name is slightly <i>odd</i> to emphasize this.</p>

<p>This function is internal to Perl because khw thinks that any XS code that would want this is probably operating too close to the internals. Presenting a valid use case could change that.</p>

<p>See also <code><a href="/cperl/perlapi.html#is_utf8_invariant_string">&quot;is_utf8_invariant_string&quot; in perlapi</a></code> and <code><a href="/cperl/perlapi.html#is_utf8_invariant_string_loc">&quot;is_utf8_invariant_string_loc&quot; in perlapi</a></code>,</p>

<pre><code>        Size_t  variant_under_utf8_count(const U8* const s,
                                         const U8* const e)</code></pre>

</dd>
</dl>

<h1 id="Warning-and-Dieing">Warning and Dieing</h1>

<dl>

<dt id="find_script">find_script </dt>
<dd>

<p>Searches for the executable script.</p>

<p>If <code>dosearch</code>, i.e. &lt;-S&gt; is true and if scriptname does not contain path delimiters, search the PATH for scriptname.</p>

<p>If SEARCH_EXTS is also defined, will look for each scriptname{SEARCH_EXTS} whenever scriptname is not found while searching the PATH.</p>

<p>Assuming SEARCH_EXTS is <code>&quot;.foo&quot;,&quot;.bar&quot;,NULL</code>, PATH search proceeds as follows:</p>

<pre><code>  If DOSISH or VMSISH:
    + look for ./scriptname{,.foo,.bar}
    + search the PATH for scriptname{,.foo,.bar}

  If !DOSISH:
    + look *only* in the PATH for scriptname{,.foo,.bar} (note
      this will not look in &#39;.&#39; if it&#39;s not in the PATH)</code></pre>

<p>This is called by <a href="#open_script">&quot;open_script&quot;</a> when <code>-e</code> was not specified.</p>

<pre><code>        char*   find_script(
                    const char *scriptname, bool dosearch,
                    const char *const *const search_ext,
                    I32 flags
                )</code></pre>

</dd>
<dt id="vwarner_security">vwarner_security </dt>
<dd>

<p>The vwarner variant which adds security specific prefix and suffices, and ignores any $SIG{__WARN__} hooks.</p>

<pre><code>        void    vwarner_security(U32 err, const char* pat,
                                 va_list* args)</code></pre>

</dd>
</dl>

<h1 id="Undocumented-functions">Undocumented functions</h1>

<p>The following functions are currently undocumented. If you use one of them, you may wish to consider creating and submitting documentation for it.</p>

<dl>

<dt id="PerlIO_restore_errno">PerlIO_restore_errno </dt>
<dd>

</dd>
<dt id="PerlIO_save_errno">PerlIO_save_errno </dt>
<dd>

</dd>
<dt id="PerlLIO_dup2_cloexec">PerlLIO_dup2_cloexec </dt>
<dd>

</dd>
<dt id="PerlLIO_dup_cloexec">PerlLIO_dup_cloexec </dt>
<dd>

</dd>
<dt id="PerlLIO_open3_cloexec">PerlLIO_open3_cloexec </dt>
<dd>

</dd>
<dt id="PerlLIO_open_cloexec">PerlLIO_open_cloexec </dt>
<dd>

</dd>
<dt id="PerlProc_pipe_cloexec">PerlProc_pipe_cloexec </dt>
<dd>

</dd>
<dt id="PerlSock_accept_cloexec">PerlSock_accept_cloexec </dt>
<dd>

</dd>
<dt id="PerlSock_socket_cloexec">PerlSock_socket_cloexec </dt>
<dd>

</dd>
<dt id="PerlSock_socketpair_cloexec">PerlSock_socketpair_cloexec </dt>
<dd>

</dd>
<dt id="Slab_to_ro">Slab_to_ro </dt>
<dd>

</dd>
<dt id="Slab_to_rw">Slab_to_rw </dt>
<dd>

</dd>
<dt id="add_range_to_invlist">_add_range_to_invlist </dt>
<dd>

</dd>
<dt id="byte_dump_string">_byte_dump_string </dt>
<dd>

</dd>
<dt id="get_encoding">_get_encoding </dt>
<dd>

</dd>
<dt id="get_regclass_nonbitmap_data">_get_regclass_nonbitmap_data </dt>
<dd>

</dd>
<dt id="inverse_folds">_inverse_folds </dt>
<dd>

</dd>
<dt id="invlistEQ">_invlistEQ </dt>
<dd>

</dd>
<dt id="invlist_array_init">_invlist_array_init </dt>
<dd>

</dd>
<dt id="invlist_contains_cp">_invlist_contains_cp </dt>
<dd>

</dd>
<dt id="invlist_dump">_invlist_dump </dt>
<dd>

</dd>
<dt id="invlist_intersection">_invlist_intersection </dt>
<dd>

</dd>
<dt id="invlist_intersection_maybe_complement_2nd">_invlist_intersection_maybe_complement_2nd </dt>
<dd>

</dd>
<dt id="invlist_invert">_invlist_invert </dt>
<dd>

</dd>
<dt id="invlist_len">_invlist_len </dt>
<dd>

</dd>
<dt id="invlist_search">_invlist_search </dt>
<dd>

</dd>
<dt id="invlist_subtract">_invlist_subtract </dt>
<dd>

</dd>
<dt id="invlist_union">_invlist_union </dt>
<dd>

</dd>
<dt id="invlist_union_maybe_complement_2nd">_invlist_union_maybe_complement_2nd </dt>
<dd>

</dd>
<dt id="is_grapheme">_is_grapheme </dt>
<dd>

</dd>
<dt id="is_in_locale_category">_is_in_locale_category </dt>
<dd>

</dd>
<dt id="mem_collxfrm">_mem_collxfrm </dt>
<dd>

</dd>
<dt id="new_invlist">_new_invlist </dt>
<dd>

</dd>
<dt id="new_invlist_C_array">_new_invlist_C_array </dt>
<dd>

</dd>
<dt id="setup_canned_invlist">_setup_canned_invlist </dt>
<dd>

</dd>
<dt id="to_fold_latin1">_to_fold_latin1 </dt>
<dd>

</dd>
<dt id="to_upper_title_latin1">_to_upper_title_latin1 </dt>
<dd>

</dd>
<dt id="warn_problematic_locale">_warn_problematic_locale </dt>
<dd>

</dd>
<dt id="abort_execution">abort_execution </dt>
<dd>

</dd>
<dt id="add_cp_to_invlist">add_cp_to_invlist </dt>
<dd>

</dd>
<dt id="allocmy">allocmy </dt>
<dd>

</dd>
<dt id="amagic_is_enabled">amagic_is_enabled </dt>
<dd>

</dd>
<dt id="append_utf8_from_native_byte">append_utf8_from_native_byte </dt>
<dd>

</dd>
<dt id="apply">apply </dt>
<dd>

</dd>
<dt id="av_extend_guts">av_extend_guts </dt>
<dd>

</dd>
<dt id="av_nonelem">av_nonelem </dt>
<dd>

</dd>
<dt id="boot_core_PerlIO">boot_core_PerlIO </dt>
<dd>

</dd>
<dt id="boot_core_UNIVERSAL">boot_core_UNIVERSAL </dt>
<dd>

</dd>
<dt id="boot_core_mro">boot_core_mro </dt>
<dd>

</dd>
<dt id="boot_core_xsutils">boot_core_xsutils </dt>
<dd>

</dd>
<dt id="cando">cando </dt>
<dd>

</dd>
<dt id="check_utf8_print">check_utf8_print </dt>
<dd>

</dd>
<dt id="ck_entersub_args_core">ck_entersub_args_core </dt>
<dd>

</dd>
<dt id="ck_join">ck_join </dt>
<dd>

</dd>
<dt id="ck_null">ck_null </dt>
<dd>

</dd>
<dt id="ck_open">ck_open </dt>
<dd>

</dd>
<dt id="ck_prototype">ck_prototype </dt>
<dd>

</dd>
<dt id="ck_refassign">ck_refassign </dt>
<dd>

</dd>
<dt id="ck_repeat">ck_repeat </dt>
<dd>

</dd>
<dt id="ck_require">ck_require </dt>
<dd>

</dd>
<dt id="ck_return">ck_return </dt>
<dd>

</dd>
<dt id="ck_select">ck_select </dt>
<dd>

</dd>
<dt id="ck_shift">ck_shift </dt>
<dd>

</dd>
<dt id="ck_sort">ck_sort </dt>
<dd>

</dd>
<dt id="ck_split">ck_split </dt>
<dd>

</dd>
<dt id="ck_stringify">ck_stringify </dt>
<dd>

</dd>
<dt id="compute_EXACTish">compute_EXACTish </dt>
<dd>

</dd>
<dt id="core_type_name">core_type_name </dt>
<dd>

</dd>
<dt id="croak_caller">croak_caller </dt>
<dd>

</dd>
<dt id="croak_no_mem">croak_no_mem </dt>
<dd>

</dd>
<dt id="croak_popstack">croak_popstack </dt>
<dd>

</dd>
<dt id="croak_shaped_array">croak_shaped_array </dt>
<dd>

</dd>
<dt id="ctz">ctz </dt>
<dd>

</dd>
<dt id="current_re_engine">current_re_engine </dt>
<dd>

</dd>
<dt id="custom_op_get_field">custom_op_get_field </dt>
<dd>

</dd>
<dt id="cv_ckproto_len_flags">cv_ckproto_len_flags </dt>
<dd>

</dd>
<dt id="cv_clone_into">cv_clone_into </dt>
<dd>

</dd>
<dt id="cv_const_sv_or_av">cv_const_sv_or_av </dt>
<dd>

</dd>
<dt id="cv_undef_flags">cv_undef_flags </dt>
<dd>

</dd>
<dt id="cvgv_from_hek">cvgv_from_hek </dt>
<dd>

</dd>
<dt id="cvgv_set">cvgv_set </dt>
<dd>

</dd>
<dt id="cvstash_set">cvstash_set </dt>
<dd>

</dd>
<dt id="deb_stack_all">deb_stack_all </dt>
<dd>

</dd>
<dt id="defelem_target">defelem_target </dt>
<dd>

</dd>
<dt id="delimcpy_no_escape">delimcpy_no_escape </dt>
<dd>

</dd>
<dt id="die_unwind">die_unwind </dt>
<dd>

</dd>
<dt id="do_aexec">do_aexec </dt>
<dd>

</dd>
<dt id="do_aexec5">do_aexec5 </dt>
<dd>

</dd>
<dt id="do_eof">do_eof </dt>
<dd>

</dd>
<dt id="do_exec">do_exec </dt>
<dd>

</dd>
<dt id="do_exec3">do_exec3 </dt>
<dd>

</dd>
<dt id="do_ipcctl">do_ipcctl </dt>
<dd>

</dd>
<dt id="do_ipcget">do_ipcget </dt>
<dd>

</dd>
<dt id="do_msgrcv">do_msgrcv </dt>
<dd>

</dd>
<dt id="do_msgsnd">do_msgsnd </dt>
<dd>

</dd>
<dt id="do_ncmp">do_ncmp </dt>
<dd>

</dd>
<dt id="do_open6">do_open6 </dt>
<dd>

</dd>
<dt id="do_open_raw">do_open_raw </dt>
<dd>

</dd>
<dt id="do_print">do_print </dt>
<dd>

</dd>
<dt id="do_readline">do_readline </dt>
<dd>

</dd>
<dt id="do_seek">do_seek </dt>
<dd>

</dd>
<dt id="do_semop">do_semop </dt>
<dd>

</dd>
<dt id="do_shmio">do_shmio </dt>
<dd>

</dd>
<dt id="do_sysseek">do_sysseek </dt>
<dd>

</dd>
<dt id="do_tell">do_tell </dt>
<dd>

</dd>
<dt id="do_trans">do_trans </dt>
<dd>

</dd>
<dt id="do_vecget">do_vecget </dt>
<dd>

</dd>
<dt id="do_vecset">do_vecset </dt>
<dd>

</dd>
<dt id="do_vop">do_vop </dt>
<dd>

</dd>
<dt id="does_utf8_overflow">does_utf8_overflow </dt>
<dd>

</dd>
<dt id="dofile">dofile </dt>
<dd>

</dd>
<dt id="drand48_init_r">drand48_init_r </dt>
<dd>

</dd>
<dt id="drand48_r">drand48_r </dt>
<dd>

</dd>
<dt id="dtrace_probe_call">dtrace_probe_call </dt>
<dd>

</dd>
<dt id="dtrace_probe_glob">dtrace_probe_glob </dt>
<dd>

</dd>
<dt id="dtrace_probe_hash">dtrace_probe_hash </dt>
<dd>

</dd>
<dt id="dtrace_probe_load">dtrace_probe_load </dt>
<dd>

</dd>
<dt id="dtrace_probe_op">dtrace_probe_op </dt>
<dd>

</dd>
<dt id="dtrace_probe_phase">dtrace_probe_phase </dt>
<dd>

</dd>
<dt id="dump_sv_child">dump_sv_child </dt>
<dd>

</dd>
<dt id="dup_warnings">dup_warnings </dt>
<dd>

</dd>
<dt id="emulate_cop_io">emulate_cop_io </dt>
<dd>

</dd>
<dt id="feature_is_enabled">feature_is_enabled </dt>
<dd>

</dd>
<dt id="fields_padoffset">fields_padoffset </dt>
<dd>

</dd>
<dt id="find_lexical_cv">find_lexical_cv </dt>
<dd>

</dd>
<dt id="find_runcv_where">find_runcv_where </dt>
<dd>

</dd>
<dt id="find_rundefsv2">find_rundefsv2 </dt>
<dd>

</dd>
<dt id="foldEQ_latin1_s2_folded">foldEQ_latin1_s2_folded </dt>
<dd>

</dd>
<dt id="form_short_octal_warning">form_short_octal_warning </dt>
<dd>

</dd>
<dt id="free_tied_hv_pool">free_tied_hv_pool </dt>
<dd>

</dd>
<dt id="get_and_check_backslash_N_name">get_and_check_backslash_N_name </dt>
<dd>

</dd>
<dt id="get_debug_opts">get_debug_opts </dt>
<dd>

</dd>
<dt id="get_hash_seed">get_hash_seed </dt>
<dd>

</dd>
<dt id="get_invlist_iter_addr">get_invlist_iter_addr </dt>
<dd>

</dd>
<dt id="get_invlist_offset_addr">get_invlist_offset_addr </dt>
<dd>

</dd>
<dt id="get_invlist_previous_index_addr">get_invlist_previous_index_addr </dt>
<dd>

</dd>
<dt id="get_no_modify">get_no_modify </dt>
<dd>

</dd>
<dt id="get_opargs">get_opargs </dt>
<dd>

</dd>
<dt id="get_re_arg">get_re_arg </dt>
<dd>

</dd>
<dt id="getenv_len">getenv_len </dt>
<dd>

</dd>
<dt id="grok_bslash_c">grok_bslash_c </dt>
<dd>

</dd>
<dt id="grok_bslash_o">grok_bslash_o </dt>
<dd>

</dd>
<dt id="grok_bslash_x">grok_bslash_x </dt>
<dd>

</dd>
<dt id="gv_fetchmeth_internal">gv_fetchmeth_internal </dt>
<dd>

</dd>
<dt id="gv_override">gv_override </dt>
<dd>

</dd>
<dt id="gv_setref">gv_setref </dt>
<dd>

</dd>
<dt id="gv_stashpvn_internal">gv_stashpvn_internal </dt>
<dd>

</dd>
<dt id="gv_stashsvpvn_cached">gv_stashsvpvn_cached </dt>
<dd>

</dd>
<dt id="handle_named_backref">handle_named_backref </dt>
<dd>

</dd>
<dt id="handle_user_defined_property">handle_user_defined_property </dt>
<dd>

</dd>
<dt id="hfree_next_entry">hfree_next_entry </dt>
<dd>

</dd>
<dt id="hv_pushkv">hv_pushkv </dt>
<dd>

</dd>
<dt id="init_argv_symbols">init_argv_symbols </dt>
<dd>

</dd>
<dt id="init_constants">init_constants </dt>
<dd>

</dd>
<dt id="init_dbargs">init_dbargs </dt>
<dd>

</dd>
<dt id="init_debugger">init_debugger </dt>
<dd>

</dd>
<dt id="init_named_cv">init_named_cv </dt>
<dd>

</dd>
<dt id="init_uniprops">init_uniprops </dt>
<dd>

</dd>
<dt id="invlist_array">invlist_array </dt>
<dd>

</dd>
<dt id="invlist_clear">invlist_clear </dt>
<dd>

</dd>
<dt id="invlist_clone">invlist_clone </dt>
<dd>

</dd>
<dt id="invlist_highest">invlist_highest </dt>
<dd>

</dd>
<dt id="invlist_is_iterating">invlist_is_iterating </dt>
<dd>

</dd>
<dt id="invlist_iterfinish">invlist_iterfinish </dt>
<dd>

</dd>
<dt id="invlist_iterinit">invlist_iterinit </dt>
<dd>

</dd>
<dt id="invlist_max">invlist_max </dt>
<dd>

</dd>
<dt id="invlist_previous_index">invlist_previous_index </dt>
<dd>

</dd>
<dt id="invlist_set_len">invlist_set_len </dt>
<dd>

</dd>
<dt id="invlist_set_previous_index">invlist_set_previous_index </dt>
<dd>

</dd>
<dt id="invlist_trim">invlist_trim </dt>
<dd>

</dd>
<dt id="io_close">io_close </dt>
<dd>

</dd>
<dt id="isFF_OVERLONG">isFF_OVERLONG </dt>
<dd>

</dd>
<dt id="isFOO_lc">isFOO_lc </dt>
<dd>

</dd>
<dt id="is_invlist">is_invlist </dt>
<dd>

</dd>
<dt id="is_utf8_common">is_utf8_common </dt>
<dd>

</dd>
<dt id="is_utf8_common_with_len">is_utf8_common_with_len </dt>
<dd>

</dd>
<dt id="is_utf8_overlong_given_start_byte_ok">is_utf8_overlong_given_start_byte_ok </dt>
<dd>

</dd>
<dt id="isinfnansv">isinfnansv </dt>
<dd>

</dd>
<dt id="keyword">keyword </dt>
<dd>

</dd>
<dt id="keyword_plugin_standard">keyword_plugin_standard </dt>
<dd>

</dd>
<dt id="magic_clear_all_env">magic_clear_all_env </dt>
<dd>

</dd>
<dt id="magic_cleararylen_p">magic_cleararylen_p </dt>
<dd>

</dd>
<dt id="magic_clearenv">magic_clearenv </dt>
<dd>

</dd>
<dt id="magic_clearisa">magic_clearisa </dt>
<dd>

</dd>
<dt id="magic_clearpack">magic_clearpack </dt>
<dd>

</dd>
<dt id="magic_clearsig">magic_clearsig </dt>
<dd>

</dd>
<dt id="magic_copycallchecker">magic_copycallchecker </dt>
<dd>

</dd>
<dt id="magic_existspack">magic_existspack </dt>
<dd>

</dd>
<dt id="magic_freearylen_p">magic_freearylen_p </dt>
<dd>

</dd>
<dt id="magic_freeovrld">magic_freeovrld </dt>
<dd>

</dd>
<dt id="magic_get">magic_get </dt>
<dd>

</dd>
<dt id="magic_getarylen">magic_getarylen </dt>
<dd>

</dd>
<dt id="magic_getdebugvar">magic_getdebugvar </dt>
<dd>

</dd>
<dt id="magic_getdefelem">magic_getdefelem </dt>
<dd>

</dd>
<dt id="magic_getnkeys">magic_getnkeys </dt>
<dd>

</dd>
<dt id="magic_getpack">magic_getpack </dt>
<dd>

</dd>
<dt id="magic_getpos">magic_getpos </dt>
<dd>

</dd>
<dt id="magic_getsig">magic_getsig </dt>
<dd>

</dd>
<dt id="magic_getsubstr">magic_getsubstr </dt>
<dd>

</dd>
<dt id="magic_gettaint">magic_gettaint </dt>
<dd>

</dd>
<dt id="magic_getuvar">magic_getuvar </dt>
<dd>

</dd>
<dt id="magic_getvec">magic_getvec </dt>
<dd>

</dd>
<dt id="magic_killbackrefs">magic_killbackrefs </dt>
<dd>

</dd>
<dt id="magic_nextpack">magic_nextpack </dt>
<dd>

</dd>
<dt id="magic_regdata_cnt">magic_regdata_cnt </dt>
<dd>

</dd>
<dt id="magic_regdatum_get">magic_regdatum_get </dt>
<dd>

</dd>
<dt id="magic_regdatum_set">magic_regdatum_set </dt>
<dd>

</dd>
<dt id="magic_scalarpack">magic_scalarpack </dt>
<dd>

</dd>
<dt id="magic_set">magic_set </dt>
<dd>

</dd>
<dt id="magic_set_all_env">magic_set_all_env </dt>
<dd>

</dd>
<dt id="magic_setarylen">magic_setarylen </dt>
<dd>

</dd>
<dt id="magic_setcollxfrm">magic_setcollxfrm </dt>
<dd>

</dd>
<dt id="magic_setdbline">magic_setdbline </dt>
<dd>

</dd>
<dt id="magic_setdebugvar">magic_setdebugvar </dt>
<dd>

</dd>
<dt id="magic_setdefelem">magic_setdefelem </dt>
<dd>

</dd>
<dt id="magic_setenv">magic_setenv </dt>
<dd>

</dd>
<dt id="magic_setisa">magic_setisa </dt>
<dd>

</dd>
<dt id="magic_setlvref">magic_setlvref </dt>
<dd>

</dd>
<dt id="magic_setmglob">magic_setmglob </dt>
<dd>

</dd>
<dt id="magic_setnkeys">magic_setnkeys </dt>
<dd>

</dd>
<dt id="magic_setnonelem">magic_setnonelem </dt>
<dd>

</dd>
<dt id="magic_setpack">magic_setpack </dt>
<dd>

</dd>
<dt id="magic_setpos">magic_setpos </dt>
<dd>

</dd>
<dt id="magic_setregexp">magic_setregexp </dt>
<dd>

</dd>
<dt id="magic_setsig">magic_setsig </dt>
<dd>

</dd>
<dt id="magic_setsubstr">magic_setsubstr </dt>
<dd>

</dd>
<dt id="magic_settaint">magic_settaint </dt>
<dd>

</dd>
<dt id="magic_setutf8">magic_setutf8 </dt>
<dd>

</dd>
<dt id="magic_setuvar">magic_setuvar </dt>
<dd>

</dd>
<dt id="magic_setvec">magic_setvec </dt>
<dd>

</dd>
<dt id="magic_sizepack">magic_sizepack </dt>
<dd>

</dd>
<dt id="magic_wipepack">magic_wipepack </dt>
<dd>

</dd>
<dt id="malloc_good_size">malloc_good_size </dt>
<dd>

</dd>
<dt id="malloced_size">malloced_size </dt>
<dd>

</dd>
<dt id="mem_collxfrm1">mem_collxfrm </dt>
<dd>

</dd>
<dt id="mem_log_alloc">mem_log_alloc </dt>
<dd>

</dd>
<dt id="mem_log_free">mem_log_free </dt>
<dd>

</dd>
<dt id="mem_log_realloc">mem_log_realloc </dt>
<dd>

</dd>
<dt id="mg_find_mglob">mg_find_mglob </dt>
<dd>

</dd>
<dt id="mode_from_discipline">mode_from_discipline </dt>
<dd>

</dd>
<dt id="more_bodies">more_bodies </dt>
<dd>

</dd>
<dt id="mro_meta_dup">mro_meta_dup </dt>
<dd>

</dd>
<dt id="mro_meta_init">mro_meta_init </dt>
<dd>

</dd>
<dt id="munge_qwlist_to_paren_list">munge_qwlist_to_paren_list </dt>
<dd>

</dd>
<dt id="my_clearenv">my_clearenv </dt>
<dd>

</dd>
<dt id="my_lstat_flags">my_lstat_flags </dt>
<dd>

</dd>
<dt id="my_memrchr">my_memrchr </dt>
<dd>

</dd>
<dt id="my_mkostemp">my_mkostemp </dt>
<dd>

</dd>
<dt id="my_mkstemp">my_mkstemp </dt>
<dd>

</dd>
<dt id="my_mkstemp_cloexec">my_mkstemp_cloexec </dt>
<dd>

</dd>
<dt id="my_stat_flags">my_stat_flags </dt>
<dd>

</dd>
<dt id="my_strerror">my_strerror </dt>
<dd>

</dd>
<dt id="my_unexec">my_unexec </dt>
<dd>

</dd>
<dt id="newGP">newGP </dt>
<dd>

</dd>
<dt id="newMETHOP_internal">newMETHOP_internal </dt>
<dd>

</dd>
<dt id="newSTUB">newSTUB </dt>
<dd>

</dd>
<dt id="newSVavdefelem">newSVavdefelem </dt>
<dd>

</dd>
<dt id="newXS_deffile">newXS_deffile </dt>
<dd>

</dd>
<dt id="new_entersubop">new_entersubop </dt>
<dd>

</dd>
<dt id="new_warnings_bitfield">new_warnings_bitfield </dt>
<dd>

</dd>
<dt id="nextargv">nextargv </dt>
<dd>

</dd>
<dt id="noperl_die">noperl_die </dt>
<dd>

</dd>
<dt id="oopsAV">oopsAV </dt>
<dd>

</dd>
<dt id="oopsHV">oopsHV </dt>
<dd>

</dd>
<dt id="op_destroy">op_destroy </dt>
<dd>

</dd>
<dt id="op_refcnt_dec">op_refcnt_dec </dt>
<dd>

</dd>
<dt id="op_refcnt_inc">op_refcnt_inc </dt>
<dd>

</dd>
<dt id="op_typed">op_typed </dt>
<dd>

</dd>
<dt id="opmethod_stash">opmethod_stash </dt>
<dd>

</dd>
<dt id="package_version">package_version </dt>
<dd>

</dd>
<dt id="pad_add_weakref">pad_add_weakref </dt>
<dd>

</dd>
<dt id="padlist_dump">padlist_dump </dt>
<dd>

</dd>
<dt id="padlist_store">padlist_store </dt>
<dd>

</dd>
<dt id="padname_free">padname_free </dt>
<dd>

</dd>
<dt id="padnamelist_free">padnamelist_free </dt>
<dd>

</dd>
<dt id="parse_unicode_opts">parse_unicode_opts </dt>
<dd>

</dd>
<dt id="parse_uniprop_string">parse_uniprop_string </dt>
<dd>

</dd>
<dt id="parser_free">parser_free </dt>
<dd>

</dd>
<dt id="parser_free_nexttoke_ops">parser_free_nexttoke_ops </dt>
<dd>

</dd>
<dt id="pmruntime">pmruntime </dt>
<dd>

</dd>
<dt id="pn_peek">pn_peek </dt>
<dd>

</dd>
<dt id="pnl_dump">pnl_dump </dt>
<dd>

</dd>
<dt id="populate_isa">populate_isa </dt>
<dd>

</dd>
<dt id="ptr_hash">ptr_hash </dt>
<dd>

</dd>
<dt id="qerror">qerror </dt>
<dd>

</dd>
<dt id="re_exec_indentf">re_exec_indentf </dt>
<dd>

</dd>
<dt id="re_indentf">re_indentf </dt>
<dd>

</dd>
<dt id="re_printf">re_printf </dt>
<dd>

</dd>
<dt id="reg_named_buff">reg_named_buff </dt>
<dd>

</dd>
<dt id="reg_named_buff_iter">reg_named_buff_iter </dt>
<dd>

</dd>
<dt id="reg_numbered_buff_fetch">reg_numbered_buff_fetch </dt>
<dd>

</dd>
<dt id="reg_numbered_buff_length">reg_numbered_buff_length </dt>
<dd>

</dd>
<dt id="reg_numbered_buff_store">reg_numbered_buff_store </dt>
<dd>

</dd>
<dt id="reg_qr_package">reg_qr_package </dt>
<dd>

</dd>
<dt id="reg_skipcomment">reg_skipcomment </dt>
<dd>

</dd>
<dt id="regcurly">regcurly </dt>
<dd>

</dd>
<dt id="report_evil_fh">report_evil_fh </dt>
<dd>

</dd>
<dt id="report_wrongway_fh">report_wrongway_fh </dt>
<dd>

</dd>
<dt id="rsignal_restore">rsignal_restore </dt>
<dd>

</dd>
<dt id="rsignal_save">rsignal_save </dt>
<dd>

</dd>
<dt id="rxres_save">rxres_save </dt>
<dd>

</dd>
<dt id="same_dirent">same_dirent </dt>
<dd>

</dd>
<dt id="save_strlen">save_strlen </dt>
<dd>

</dd>
<dt id="save_to_buffer">save_to_buffer </dt>
<dd>

</dd>
<dt id="scalar">scalar </dt>
<dd>

</dd>
<dt id="set_caret_X">set_caret_X </dt>
<dd>

</dd>
<dt id="set_numeric_standard">set_numeric_standard </dt>
<dd>

</dd>
<dt id="set_numeric_underlying">set_numeric_underlying </dt>
<dd>

</dd>
<dt id="set_padlist">set_padlist </dt>
<dd>

</dd>
<dt id="setfd_cloexec">setfd_cloexec </dt>
<dd>

</dd>
<dt id="setfd_cloexec_for_nonsysfd">setfd_cloexec_for_nonsysfd </dt>
<dd>

</dd>
<dt id="setfd_cloexec_or_inhexec_by_sysfdness">setfd_cloexec_or_inhexec_by_sysfdness </dt>
<dd>

</dd>
<dt id="setfd_inhexec">setfd_inhexec </dt>
<dd>

</dd>
<dt id="setfd_inhexec_for_sysfd">setfd_inhexec_for_sysfd </dt>
<dd>

</dd>
<dt id="should_warn_nl">should_warn_nl </dt>
<dd>

</dd>
<dt id="sighandler">sighandler </dt>
<dd>

</dd>
<dt id="skipspace_flags">skipspace_flags </dt>
<dd>

</dd>
<dt id="ssc_add_range">ssc_add_range </dt>
<dd>

</dd>
<dt id="ssc_clear_locale">ssc_clear_locale </dt>
<dd>

</dd>
<dt id="ssc_cp_and">ssc_cp_and </dt>
<dd>

</dd>
<dt id="ssc_intersection">ssc_intersection </dt>
<dd>

</dd>
<dt id="ssc_union">ssc_union </dt>
<dd>

</dd>
<dt id="sub_crush_depth">sub_crush_depth </dt>
<dd>

</dd>
<dt id="sv_buf_to_ro">sv_buf_to_ro </dt>
<dd>

</dd>
<dt id="sv_magicext_mglob">sv_magicext_mglob </dt>
<dd>

</dd>
<dt id="sv_mortalcopy_flags">sv_mortalcopy_flags </dt>
<dd>

</dd>
<dt id="sv_only_taint_gmagic">sv_only_taint_gmagic </dt>
<dd>

</dd>
<dt id="sv_or_pv_pos_u2b">sv_or_pv_pos_u2b </dt>
<dd>

</dd>
<dt id="sv_resetpvn">sv_resetpvn </dt>
<dd>

</dd>
<dt id="sv_sethek">sv_sethek </dt>
<dd>

</dd>
<dt id="sv_setsv_cow">sv_setsv_cow </dt>
<dd>

</dd>
<dt id="sv_unglob">sv_unglob </dt>
<dd>

</dd>
<dt id="swash_fetch">swash_fetch </dt>
<dd>

</dd>
<dt id="swash_init">swash_init </dt>
<dd>

</dd>
<dt id="tied_method">tied_method </dt>
<dd>

</dd>
<dt id="tmps_grow_p">tmps_grow_p </dt>
<dd>

</dd>
<dt id="translate_substr_offsets">translate_substr_offsets </dt>
<dd>

</dd>
<dt id="try_amagic_bin">try_amagic_bin </dt>
<dd>

</dd>
<dt id="try_amagic_un">try_amagic_un </dt>
<dd>

</dd>
<dt id="uiv_2buf">uiv_2buf </dt>
<dd>

</dd>
<dt id="utilize">utilize </dt>
<dd>

</dd>
<dt id="varname">varname </dt>
<dd>

</dd>
<dt id="vivify_defelem">vivify_defelem </dt>
<dd>

</dd>
<dt id="vivify_ref">vivify_ref </dt>
<dd>

</dd>
<dt id="wait4pid">wait4pid </dt>
<dd>

</dd>
<dt id="was_lvalue_sub">was_lvalue_sub </dt>
<dd>

</dd>
<dt id="watch">watch </dt>
<dd>

</dd>
<dt id="win32_croak_not_implemented">win32_croak_not_implemented </dt>
<dd>

</dd>
<dt id="write_to_stderr">write_to_stderr </dt>
<dd>

</dd>
<dt id="xs_boot_epilog">xs_boot_epilog </dt>
<dd>

</dd>
<dt id="yyerror">yyerror </dt>
<dd>

</dd>
<dt id="yyerror_pv">yyerror_pv </dt>
<dd>

</dd>
<dt id="yyerror_pvn">yyerror_pvn </dt>
<dd>

</dd>
<dt id="yyparse">yyparse </dt>
<dd>

</dd>
<dt id="yyquit">yyquit </dt>
<dd>

</dd>
<dt id="yyunlex">yyunlex </dt>
<dd>

</dd>
</dl>

<h1 id="AUTHORS">AUTHORS</h1>

<p>The autodocumentation system was originally added to the Perl core by Benjamin Stuhl. Documentation is by whoever was kind enough to document their functions.</p>

<h1 id="SEE-ALSO">SEE ALSO</h1>

<p><a href="/cperl/perlguts.html">perlguts</a>, <a href="/cperl/perlapi.html">perlapi</a>, <a href="/cperl/perlapio.html">perlapio</a></p>


</body>

</html>


