<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title></title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:root@osx201.apple.com" />
</head>

<body style="background-color: white">



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#USAGE">USAGE</a></li>
  <li><a href="#FUNCTIONS">FUNCTIONS</a></li>
  <li><a href="#PERFORMANCE">PERFORMANCE</a></li>
  <li><a href="#AUTHOR">AUTHOR</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>ExtUtils::Constant - generate XS code to import C header constants</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code>    use ExtUtils::Constant qw (WriteConstants);
    WriteConstants(
        NAME =&gt; &#39;Foo&#39;,
        NAMES =&gt; [qw(FOO BAR BAZ)],
    );
    # Generates wrapper code to make the values of the constants FOO BAR BAZ
    #  available to perl</code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>ExtUtils::Constant facilitates generating C and XS wrapper code to allow perl modules to AUTOLOAD constants defined in C library header files. It is principally used by the <code>h2xs</code> utility, on which this code is based. It doesn&#39;t contain the routines to scan header files to extract these constants.</p>

<p>Memory footprint and run-time performance is not as good as specialized perfect hashes as with <a>XSConfig</a> or <a>Win32::GUI::Constants</a>.</p>

<h1 id="USAGE">USAGE</h1>

<p>Generally one only needs to call the <code>WriteConstants</code> function, and then</p>

<pre><code>    #include &quot;const-c.inc&quot;</code></pre>

<p>in the C section of <code>Foo.xs</code></p>

<pre><code>    INCLUDE: const-xs.inc</code></pre>

<p>in the XS section of <code>Foo.xs</code>.</p>

<p>For greater flexibility use <code>constant_types()</code>, <code>C_constant</code> and <code>XS_constant</code>, with which <code>WriteConstants</code> is implemented.</p>

<p>Currently this module understands the following types. h2xs may only know a subset. The sizes of the numeric types are chosen by the <code>Configure</code> script at compile time.</p>

<dl>

<dt id="IV">IV</dt>
<dd>

<p>signed integer, at least 32 bits.</p>

</dd>
<dt id="UV">UV</dt>
<dd>

<p>unsigned integer, the same size as <i>IV</i></p>

</dd>
<dt id="NV">NV</dt>
<dd>

<p>floating point type, probably <code>double</code>, possibly <code>long double</code></p>

</dd>
<dt id="PV">PV</dt>
<dd>

<p>NUL terminated string, length will be determined with <code>strlen</code></p>

</dd>
<dt id="PVN">PVN</dt>
<dd>

<p>A fixed length thing, given as a [pointer, length] pair. If you know the length of a string at compile time you may use this instead of <i>PV</i></p>

</dd>
<dt id="SV">SV</dt>
<dd>

<p>A <b>mortal</b> SV.</p>

</dd>
<dt id="YES">YES</dt>
<dd>

<p>Truth. (<code>PL_sv_yes</code>) The value is not needed (and ignored).</p>

</dd>
<dt id="NO">NO</dt>
<dd>

<p>Defined Falsehood. (<code>PL_sv_no</code>) The value is not needed (and ignored).</p>

</dd>
<dt id="UNDEF">UNDEF</dt>
<dd>

<p><code>undef</code>. The value of the macro is not needed.</p>

</dd>
</dl>

<h1 id="FUNCTIONS">FUNCTIONS</h1>

<dl>

<dt id="constant_types">constant_types</dt>
<dd>

<p>A function returning a single scalar with <code>#define</code> definitions for the constants used internally between the generated C and XS functions.</p>

</dd>
<dt id="C_constant">C_constant</dt>
<dd>

<p>A function to generate the C code in <i>const-c.inc</i> to implement the perl subroutine <i>PACKAGE</i>::constant.</p>

<p>The <code>$what</code> paramater should be given either as a comma separated list of types that the C subroutine <code>constant</code> will generate or as a reference to a hash. It should be the same list of types as <code>XS_constant</code> was given. Otherwise <code>XS_constant</code> and <code>C_constant</code> may have different ideas about the number of parameters passed to the C function <code>constant</code>.</p>

</dd>
<dt id="XS_constant-PACKAGE-TYPES-XS_SUBNAME-C_SUBNAME">XS_constant PACKAGE, TYPES, XS_SUBNAME, C_SUBNAME</dt>
<dd>

<p>A function to generate the XS code to implement the perl subroutine <i>PACKAGE</i>::constant used by <i>PACKAGE</i>::AUTOLOAD to load constants. This XS code is a wrapper around a C subroutine usually generated by <code>C_constant</code>, and usually named <code>constant</code>.</p>

<p><i>TYPES</i> should be given either as a comma separated list of types that the C subroutine <code>constant</code> will generate or as a reference to a hash. It should be the same list of types as <code>C_constant</code> was given. Otherwise <code>XS_constant</code> and <code>C_constant</code> may have different ideas about the number of parameters passed to the C function <code>constant</code>.</p>

<p>You can call the perl visible subroutine something other than <code>constant</code> if you give the parameter <i>XS_SUBNAME</i>. The C subroutine it calls defaults to the name of the perl visible subroutine, unless you give the parameter <i>C_SUBNAME</i>.</p>

</dd>
<dt id="autoload-PACKAGE-VERSION-AUTOLOADER">autoload PACKAGE, VERSION, AUTOLOADER</dt>
<dd>

<p>A function to generate the AUTOLOAD subroutine for the module <i>PACKAGE</i> <i>VERSION</i> is the perl version the code should be backwards compatible with. It defaults to the version of perl running the subroutine. If <i>AUTOLOADER</i> is true, the AUTOLOAD subroutine falls back on AutoLoader::AUTOLOAD for all names that the constant() routine doesn&#39;t recognise.</p>

<p>This is needed unless you use <code>PROXYSUBS =</code> {autoload=&gt;1}&gt;, but which generates code unusable earlier than 5.8.</p>

</dd>
<dt id="WriteMakefileSnippet">WriteMakefileSnippet</dt>
<dd>

<p>WriteMakefileSnippet ATTRIBUTE =&gt; VALUE [, ...]</p>

<p>A function to generate perl code for Makefile.PL that will regenerate the constant subroutines. Parameters are named as passed to <code>WriteConstants</code>, with the addition of <code>INDENT</code> to specify the number of leading spaces (default 2).</p>

<p>Currently only <code>INDENT</code>, <code>NAME</code>, <code>DEFAULT_TYPE</code>, <code>NAMES</code>, <code>C_FILE</code> and <code>XS_FILE</code> are recognised.</p>

</dd>
<dt id="WriteConstants-ATTRIBUTE-VALUE">WriteConstants ATTRIBUTE =&gt; VALUE [, ...]</dt>
<dd>

<p>Writes a file of C code and a file of XS code which you should <code>#include</code> and <code>INCLUDE</code> in the C and XS sections respectively of your module&#39;s XS code. You probably want to do this in your <code>Makefile.PL</code>, so that you can easily edit the list of constants without touching the rest of your module. The attributes supported are</p>

<dl>

<dt id="NAME1"><code>NAME</code></dt>
<dd>

<p>Name of the module. This must be specified</p>

</dd>
<dt id="DEFAULT_TYPE"><code>DEFAULT_TYPE</code></dt>
<dd>

<p>The default type for the constants. If not specified <code>IV</code> is assumed.</p>

</dd>
<dt id="BREAKOUT_AT"><code>BREAKOUT_AT</code></dt>
<dd>

<p>The names of the constants are grouped by length. Generate child subroutines for each group with this number or more names in.</p>

</dd>
<dt id="NAMES"><code>NAMES</code></dt>
<dd>

<p>An array of constants&#39; names, either scalars containing names, or hashrefs as detailed in <a href="#C_constant">&quot;C_constant&quot;</a>.</p>

</dd>
<dt id="PROXYSUBS"><code>PROXYSUBS</code></dt>
<dd>

<p>If true, uses proxy subs. See <a href="/cperl/lib/ExtUtils/Constant/ProxySubs.html">ExtUtils::Constant::ProxySubs</a>. PROXYSUBS create CONSTSUB&#39;s for each defined constant upfront, while without PROXYSUBS every constant is looked up at run-time. Thus it trades memory footprint for faster run-time performance.</p>

<p>Options: autoload, push, croak_on_error or croak_on_read with most of the options being exclusive, and croak_on_read usable since 5.24.</p>

</dd>
<dt id="C_FH"><code>C_FH</code></dt>
<dd>

<p>A filehandle to write the C code to. If not given, then <i>C_FILE</i> is opened for writing.</p>

</dd>
<dt id="C_FILE"><code>C_FILE</code></dt>
<dd>

<p>The name of the file to write containing the C code. The default is <code>const-c.inc</code>. The <code>-</code> in the name ensures that the file can&#39;t be mistaken for anything related to a legitimate perl package name, and not naming the file <code>.c</code> avoids having to override Makefile.PL&#39;s <code>.xs</code> to <code>.c</code> rules.</p>

</dd>
<dt id="XS_FH"><code>XS_FH</code></dt>
<dd>

<p>A filehandle to write the XS code to. If not given, then <i>XS_FILE</i> is opened for writing.</p>

</dd>
<dt id="XS_FILE"><code>XS_FILE</code></dt>
<dd>

<p>The name of the file to write containing the XS code. The default is <code>const-xs.inc</code>.</p>

</dd>
<dt id="XS_SUBNAME"><code>XS_SUBNAME</code></dt>
<dd>

<p>The perl visible name of the XS subroutine generated which will return the constants. The default is <code>constant</code>.</p>

</dd>
<dt id="C_SUBNAME"><code>C_SUBNAME</code></dt>
<dd>

<p>The name of the C subroutine generated which will return the constants. The default is <i>XS_SUBNAME</i>. Child subroutines have <code>_</code> and the name length appended, so constants with 10 character names would be in <code>constant_10</code> with the default <i>XS_SUBNAME</i>.</p>

</dd>
</dl>

</dd>
</dl>

<h1 id="PERFORMANCE">PERFORMANCE</h1>

<p>You can calculate simple performance numbers with <code>perl -Mblib t/Constant.t --bench --memtest </code>/dev/null 2&gt;bench.lst&gt; and <code>grep ^# bench.lst</code> for 19 constants.</p>

<pre><code>    Option              Memory [b]   Time [s]
    &lt;none&gt;              1612758      0.023946
    PROXYSUBS           1593553      0.020061
    PROXYSUBS autoload  1588555      0.024906
    PROXYSUBS push      1608709      0.023361
    PROXYSUBS 
    croak_on_error      1590267      0.023052
    PROXYSUBS
    croak_on_read       1599747      0.021710
    PROXYSUBS
    autoload push       1589737      0.021917
    PROXYSUBS
    croak_on_error push 1590606      0.021669</code></pre>

<p>PROXYSUBS without any option is the fastest, and on the lower side of memory.</p>

<p>PROXYSUBS autoload is the slowest, but easiest to use.</p>

<p>The old method without PROXYSUBS uses the most memory and is 2nd slowest.</p>

<p>With &gt;500 constants:</p>

<pre><code>    Option              Memory [b]   Time [s]
    &lt;none&gt;              2572650      0.025867
    PROXYSUBS           2145701      0.024928
    PROXYSUBS autoload  2133418      0.024154
    PROXYSUBS push      2173807      0.030029
    PROXYSUBS 
    croak_on_error      2142773      0.025776
    PROXYSUBS
    croak_on_read       2144780      0.027649
    PROXYSUBS
    autoload push       2161453      0.026092
    PROXYSUBS
    croak_on_error push 2170791      0.027433</code></pre>

<p>There are no numbers compared to perfect hashes yet. The estimation is that EU-C is ~50% slower and bigger, as seen with <a>Win32::GUI::Constants</a> and <a>XSConfig</a>. See also <a>Perfect::Hash</a>.</p>

<h1 id="AUTHOR">AUTHOR</h1>

<p>Reini Urban &lt;rurban@cpan.org&gt; fixed up ProxySubs and took over maintainance. Nicholas Clark &lt;nick@ccl4.org&gt; wrote it based on the code in <code>h2xs</code> by Larry Wall and others.</p>


</body>

</html>


