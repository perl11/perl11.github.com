<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title></title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:rurban@cpan.org" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a>
    <ul>
      <li><a href="#Statement-Profiling">Statement Profiling</a></li>
      <li><a href="#Subroutine-Profiling">Subroutine Profiling</a>
        <ul>
          <li><a href="#Subroutine-Recursion">Subroutine Recursion</a></li>
          <li><a href="#Goto-Subroutine">Goto &amp;Subroutine</a></li>
          <li><a href="#accept">accept()</a></li>
        </ul>
      </li>
      <li><a href="#Application-Profiling">Application Profiling</a></li>
      <li><a href="#Fast-Profiling">Fast Profiling</a></li>
      <li><a href="#Apache-Profiling">Apache Profiling</a></li>
    </ul>
  </li>
  <li><a href="#PROFILING">PROFILING</a></li>
  <li><a href="#NYTPROF-ENVIRONMENT-VARIABLE">NYTPROF ENVIRONMENT VARIABLE</a>
    <ul>
      <li><a href="#addpid-1">addpid=1</a></li>
      <li><a href="#addtimestamp-1">addtimestamp=1</a></li>
      <li><a href="#trace-N">trace=N</a></li>
      <li><a href="#log-F">log=F</a></li>
      <li><a href="#start">start=...</a></li>
      <li><a href="#optimize-0">optimize=0</a></li>
      <li><a href="#subs-0">subs=0</a></li>
      <li><a href="#blocks-1">blocks=1</a></li>
      <li><a href="#stmts-0">stmts=0</a></li>
      <li><a href="#calls-N">calls=N</a></li>
      <li><a href="#leave-0">leave=0</a></li>
      <li><a href="#findcaller-1">findcaller=1</a></li>
      <li><a href="#use_db_sub-1">use_db_sub=1</a></li>
      <li><a href="#savesrc-0">savesrc=0</a></li>
      <li><a href="#slowops-N">slowops=N</a></li>
      <li><a href="#usecputime-1">usecputime=1</a></li>
      <li><a href="#file">file=...</a></li>
      <li><a href="#compress">compress=...</a></li>
      <li><a href="#clock-N">clock=N</a></li>
      <li><a href="#sigexit-1">sigexit=1</a></li>
      <li><a href="#posix_exit-1">posix_exit=1</a></li>
      <li><a href="#libcexit-1">libcexit=1</a></li>
      <li><a href="#endatexit-1">endatexit=1</a></li>
      <li><a href="#forkdepth-N">forkdepth=N</a></li>
      <li><a href="#nameevals-0">nameevals=0</a></li>
      <li><a href="#nameanonsubs-0">nameanonsubs=0</a></li>
    </ul>
  </li>
  <li><a href="#RUN-TIME-CONTROL-OF-PROFILING">RUN-TIME CONTROL OF PROFILING</a>
    <ul>
      <li><a href="#disable_profile">disable_profile</a></li>
      <li><a href="#enable_profile">enable_profile</a></li>
      <li><a href="#finish_profile">finish_profile</a></li>
    </ul>
  </li>
  <li><a href="#DATA-COLLECTION-AND-INTERPRETATION">DATA COLLECTION AND INTERPRETATION</a>
    <ul>
      <li><a href="#If-Statement-and-Subroutine-Timings-Dont-Match">If Statement and Subroutine Timings Don&#39;t Match</a></li>
      <li><a href="#If-Headline-Subroutine-Timings-Dont-Match-the-Called-Subs">If Headline Subroutine Timings Don&#39;t Match the Called Subs</a></li>
      <li><a href="#Perl-5.10.1-or-else-5.8.9-is-Recommended">Perl 5.10.1+ (or else 5.8.9+) is Recommended</a></li>
      <li><a href="#eval-string">eval $string</a>
        <ul>
          <li><a href="#Merging-Evals">Merging Evals</a></li>
          <li><a href="#Merging-Anonymous-Subroutines">Merging Anonymous Subroutines</a></li>
          <li><a href="#Timing">Timing</a></li>
        </ul>
      </li>
      <li><a href="#Calls-from-XSUBs-and-Opcodes">Calls from XSUBs and Opcodes</a></li>
    </ul>
  </li>
  <li><a href="#MAKING-NYTPROF-FASTER">MAKING NYTPROF FASTER</a></li>
  <li><a href="#REPORTS">REPORTS</a>
    <ul>
      <li><a href="#nytprofhtml">nytprofhtml</a></li>
      <li><a href="#nytprofcg">nytprofcg</a></li>
      <li><a href="#nytprofcalls">nytprofcalls</a></li>
      <li><a href="#nytprofmerge">nytprofmerge</a></li>
    </ul>
  </li>
  <li><a href="#LIMITATIONS">LIMITATIONS</a>
    <ul>
      <li><a href="#Threads-and-Multiplicity">Threads and Multiplicity</a></li>
      <li><a href="#Coro">Coro</a></li>
      <li><a href="#FCGI::Engine">FCGI::Engine</a></li>
      <li><a href="#For-perl-5.8.8-it-may-change-what-caller-returns">For perl &lt; 5.8.8 it may change what caller() returns</a></li>
      <li><a href="#For-perl-5.10.1-it-cant-see-some-implicit-calls-and-callbacks">For perl &lt; 5.10.1 it can&#39;t see some implicit calls and callbacks</a></li>
      <li><a href="#line-directives">#line directives</a></li>
      <li><a href="#Freed-values-in-_-may-be-mutated">Freed values in @_ may be mutated</a></li>
      <li><a href="#Lvalue-subroutines-arent-profiled-when-using-use_db_sub-1">Lvalue subroutines aren&#39;t profiled when using use_db_sub=1</a></li>
    </ul>
  </li>
  <li><a href="#CLOCKS">CLOCKS</a>
    <ul>
      <li><a href="#POSIX-Clocks">POSIX Clocks</a>
        <ul>
          <li><a href="#CLOCK_MONOTONIC">CLOCK_MONOTONIC</a></li>
          <li><a href="#CLOCK_REALTIME">CLOCK_REALTIME</a></li>
          <li><a href="#CLOCK_VIRTUAL">CLOCK_VIRTUAL</a></li>
          <li><a href="#CLOCK_PROF">CLOCK_PROF</a></li>
          <li><a href="#CLOCK_PROCESS_CPUTIME_ID">CLOCK_PROCESS_CPUTIME_ID</a></li>
          <li><a href="#CLOCK_THREAD_CPUTIME_ID">CLOCK_THREAD_CPUTIME_ID</a></li>
          <li><a href="#Finding-Available-POSIX-Clocks">Finding Available POSIX Clocks</a></li>
        </ul>
      </li>
      <li><a href="#Other-Clocks">Other Clocks</a>
        <ul>
          <li><a href="#gettimeofday">gettimeofday</a></li>
          <li><a href="#mach_absolute_time">mach_absolute_time</a></li>
          <li><a href="#Time::HiRes">Time::HiRes</a></li>
        </ul>
      </li>
      <li><a href="#Clock-References">Clock References</a></li>
    </ul>
  </li>
  <li><a href="#CAVEATS">CAVEATS</a>
    <ul>
      <li><a href="#SMP-Systems">SMP Systems</a>
        <ul>
          <li><a href="#Processor-Affinity">Processor Affinity</a></li>
          <li><a href="#Windows">Windows</a></li>
        </ul>
      </li>
      <li><a href="#Virtual-Machines">Virtual Machines</a></li>
    </ul>
  </li>
  <li><a href="#BUGS">BUGS</a></li>
  <li><a href="#SEE-ALSO">SEE ALSO</a></li>
  <li><a href="#TROUBLESHOOTING">TROUBLESHOOTING</a>
    <ul>
      <li><a href="#Profile-data-incomplete-...-or-Profile-format-error">&quot;Profile data incomplete, ...&quot; or &quot;Profile format error: ...&quot;</a></li>
      <li><a href="#Some-source-files-dont-have-profile-information">Some source files don&#39;t have profile information</a></li>
      <li><a href="#Eval-...-has-unknown-invoking-fid">Eval ... has unknown invoking fid</a></li>
      <li><a href="#Warning:-d-subroutine-calls-had-negative-time">Warning: %d subroutine calls had negative time</a></li>
      <li><a href="#panic:-buffer-overflow">panic: buffer overflow ...</a></li>
    </ul>
  </li>
  <li><a href="#AUTHORS-AND-CONTRIBUTORS">AUTHORS AND CONTRIBUTORS</a></li>
  <li><a href="#COPYRIGHT-AND-LICENSE">COPYRIGHT AND LICENSE</a>
    <ul>
      <li><a href="#Background">Background</a></li>
    </ul>
  </li>
</ul>

<h1 id="NAME">NAME</h1>

<p>Devel::NYTProf - Powerful fast feature-rich Perl source code profiler</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code>  # profile code and write database to ./nytprof.out
  perl -d:NYTProf some_perl.pl

  # convert database into a set of html files, e.g., ./nytprof/index.html
  # and open a web browser on the nytprof/index.html file
  nytprofhtml --open

  # or into comma separated files, e.g., ./nytprof/*.csv
  nytprofcsv</code></pre>

<p>I give talks on profiling perl code, including a detailed look at how to use NYTProf and how to optimize your code, every year. A video of my YAPC::NA 2014 talk can be found at <a href="https://youtu.be/T7EK6RZAnEA">https://youtu.be/T7EK6RZAnEA</a></p>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>Devel::NYTProf is a powerful, fast, feature-rich perl source code profiler.</p>

<ul>

<li><p>Performs per-line statement profiling for fine detail</p>

</li>
<li><p>Performs per-subroutine statement profiling for overview</p>

</li>
<li><p>Performs per-opcode profiling for slow perl builtins</p>

</li>
<li><p>Performs per-block statement profiling (the first profiler to do so)</p>

</li>
<li><p>Accounts correctly for time spent after calls return</p>

</li>
<li><p>Performs inclusive and exclusive timing of subroutines</p>

</li>
<li><p>Subroutine times are per calling location (a powerful feature)</p>

</li>
<li><p>Can profile compile-time activity, just run-time, or just END time</p>

</li>
<li><p>Uses novel techniques for efficient profiling</p>

</li>
<li><p>Sub-microsecond (100ns) resolution on supported systems</p>

</li>
<li><p>Very fast - the fastest statement and subroutine profilers for perl</p>

</li>
<li><p>Handles applications that fork, with no performance cost</p>

</li>
<li><p>Immune from noise caused by profiling overheads and I/O</p>

</li>
<li><p>Program being profiled can stop/start the profiler</p>

</li>
<li><p>Generates richly annotated and cross-linked html reports</p>

</li>
<li><p>Captures source code, including string evals, for stable results</p>

</li>
<li><p>Trivial to use with mod_perl - add one line to httpd.conf</p>

</li>
<li><p>Includes an extensive test suite</p>

</li>
<li><p>Tested on very large codebases</p>

</li>
</ul>

<p>NYTProf is effectively two profilers in one: a statement profiler, and a subroutine profiler.</p>

<h2 id="Statement-Profiling">Statement Profiling</h2>

<p>The statement profiler measures the time between entering one perl statement and entering the next. Whenever execution reaches a new statement, the time since entering the previous statement is calculated and added to the time associated with the line of the source file that the previous statement starts on.</p>

<p>By default the statement profiler also determines the first line of the current block and the first line of the current statement, and accumulates times associated with those.</p>

<p>Another innovation unique to NYTProf is automatic compensation for a problem inherent in simplistic statement-to-statement timing. Consider a statement that calls a subroutine and then performs some other work that doesn&#39;t execute new statements, for example:</p>

<pre><code>  foo(...) + mkdir(...);</code></pre>

<p>In all other statement profilers the time spent in remainder of the expression (mkdir in the example) will be recorded as having been spent <i>on the last statement executed in foo()</i>! Here&#39;s another example:</p>

<pre><code>  while (&lt;&gt;) {
     ...
     1;
  }</code></pre>

<p>After the first time around the loop, any further time spent evaluating the condition (waiting for input in this example) would be recorded as having been spent <i>on the last statement executed in the loop</i>! (Until perl bug #60954 is fixed this problem still applies to some loops. For more information see <a href="http://rt.perl.org/rt3/Ticket/Display.html?id=60954">http://rt.perl.org/rt3/Ticket/Display.html?id=60954</a>)</p>

<p>NYTProf avoids these problems by intercepting the opcodes which indicate that control is returning into some previous statement and adjusting the profile accordingly.</p>

<p>The statement profiler naturally generates a lot of data which is streamed out to a file in a very compact format. NYTProf takes care to not include the measurement and writing overheads in the profile times (some profilers produce &#39;noisy&#39; data due to periodic stdio flushing).</p>

<h2 id="Subroutine-Profiling">Subroutine Profiling</h2>

<p>The subroutine profiler measures the time between entering a subroutine and leaving it. It then increments a call count and accumulates the duration. For each subroutine called, separate counts and durations are stored <i>for each location that called the subroutine</i>.</p>

<p>Subroutine entry is detected by intercepting the <code>entersub</code> opcode. Subroutine exit is detected via perl&#39;s internal save stack. As a result the subroutine profiler is both fast and robust.</p>

<h3 id="Subroutine-Recursion">Subroutine Recursion</h3>

<p>For subroutines that recurse directly or indirectly, such as Error::try, the inclusive time is only measured for the outer-most call.</p>

<p>The inclusive times of recursive calls are still measured and are accumulated separately. Also the &#39;maximum recursion depth&#39; per calling location is recorded.</p>

<h3 id="Goto-Subroutine">Goto &amp;Subroutine</h3>

<p>Perl implements a <code>goto &amp;destination</code> as a <code>return</code> followed by a call to <code>&amp;destination</code>, so that&#39;s how it will appear in the report.</p>

<p>The <code>goto</code> will be shown with a very short time because it&#39;s effectively just a <code>return</code>. The <code>&amp;destination</code> sub will show a call <i>not</i> from the location of the <code>goto</code> but from the location of the call to the sub that performed the <code>goto</code>.</p>

<h3 id="accept">accept()</h3>

<p>The perl built-in accept() function waits listening for a connection on a socket, and so is a key part of pure-perl network service applications.</p>

<p>The time spent waiting for a remotely initiated connection can be relatively high but is not relevant to the performance of the application. So the accept() function is treated as a special case. The subroutine profiler discounts the time spent in the accept() function. It does this in a way that also discounts that time from all the callers up the call stack. The effect on the reports is that all accept() calls appear to be instant.</p>

<p>The <i>statement</i> profiler still shows the time actually spent in the statement that executed the accept() call.</p>

<h2 id="Application-Profiling">Application Profiling</h2>

<p>NYTProf records extra information in the data file to capture details that may be useful when analyzing the performance. It also records the filename and line ranges of all the subroutines.</p>

<p>NYTProf can profile applications that fork, and does so with no loss of performance. NYTProf detects the fork and starts writing a new profile file with the pid appended to the filename. Since <a>nytprofhtml</a> only works with a single profile file you may want to merge multiple files using <a>nytprofmerge</a>.</p>

<h2 id="Fast-Profiling">Fast Profiling</h2>

<p>The NYTProf profiler is written almost entirely in C and great care has been taken to ensure it&#39;s very efficient.</p>

<h2 id="Apache-Profiling">Apache Profiling</h2>

<p>Just add one line near the start of your httpd.conf file:</p>

<pre><code>  PerlModule Devel::NYTProf::Apache</code></pre>

<p>By default you&#39;ll get a <i>/tmp/nytprof.$$.out</i> file for the parent process and a <i>/tmp/nytprof.$parent.out.$$</i> file for each worker process.</p>

<p>NYTProf takes care to detect when control is returning back from perl to mod_perl so time spent in mod_perl (such as waiting for the next request) does not get allocated to the last statement executed.</p>

<p>Works with mod_perl 1 and 2. See <a href="/cperl/lib/Devel/NYTProf/Apache.html">Devel::NYTProf::Apache</a> for more information.</p>

<h1 id="PROFILING">PROFILING</h1>

<p>Usually you&#39;d load Devel::NYTProf on the command line using the perl -d option:</p>

<pre><code>  perl -d:NYTProf some_perl.pl</code></pre>

<p>To save typing the &#39;:NYTProf&#39; you could set the PERL5DB env var</p>

<pre><code>  PERL5DB=&#39;use Devel::NYTProf&#39;</code></pre>

<p>and then just perl -d would work:</p>

<pre><code>  perl -d some_perl.pl</code></pre>

<p>Or you can avoid the need to add the -d option at all by using the <code>PERL5OPT</code> env var:</p>

<pre><code>  PERL5OPT=-d:NYTProf</code></pre>

<p>That&#39;s also very handy when you can&#39;t alter the perl command line being used to run the script you want to profile. Usually you&#39;ll want to enable the <a href="#addpid-1">&quot;addpid=1&quot;</a> option to ensure any nested invocations of perl don&#39;t overwrite the profile.</p>

<h1 id="NYTPROF-ENVIRONMENT-VARIABLE">NYTPROF ENVIRONMENT VARIABLE</h1>

<p>The behavior of Devel::NYTProf may be modified by setting the environment variable <code>NYTPROF</code>. It is possible to use this environment variable to effect multiple setting by separating the values with a <code>:</code>. For example:</p>

<pre><code>  export NYTPROF=trace=2:start=init:file=/tmp/nytprof.out</code></pre>

<p>Any colon or equal characters in a value can be escaped by preceding them with a backslash.</p>

<h2 id="addpid-1">addpid=1</h2>

<p>Append the current process id to the end of the filename.</p>

<p>This avoids concurrent, or consecutive, processes from overwriting the same file. If a fork is detected during profiling then the child process will automatically add the process id to the filename.</p>

<h2 id="addtimestamp-1">addtimestamp=1</h2>

<p>Append the current time, as integer epoch seconds, to the end of the filename.</p>

<h2 id="trace-N">trace=N</h2>

<p>Set trace level to N. 0 is off (the default). Higher values cause more detailed trace output. Trace output is written to STDERR or wherever the <a href="#log-F">&quot;log=F&quot;</a> option has specified.</p>

<h2 id="log-F">log=F</h2>

<p>Specify the name of the file that <a href="#trace-N">&quot;trace=N&quot;</a> output should be written to.</p>

<h2 id="start">start=...</h2>

<p>Specify at which phase of program execution the profiler should be enabled:</p>

<pre><code>  start=begin - start immediately (the default)
  start=init  - start at beginning of INIT phase (after compilation/use/BEGIN)
  start=end   - start at beginning of END phase
  start=no    - don&#39;t automatically start</code></pre>

<p>The start=no option is handy if you want to explicitly control profiling by calling DB::enable_profile() and DB::disable_profile() yourself. See <a href="#RUN-TIME-CONTROL-OF-PROFILING">&quot;RUN-TIME CONTROL OF PROFILING&quot;</a>.</p>

<p>The start=init option is handy if you want to avoid profiling the loading and initialization of modules.</p>

<h2 id="optimize-0">optimize=0</h2>

<p>Disable the perl optimizer.</p>

<p>By default NYTProf leaves perl&#39;s optimizer enabled. That gives you more accurate profile timing overall, but can lead to <i>odd</i> statement counts for individual sets of lines. That&#39;s because the perl&#39;s peephole optimizer has effectively rewritten the statements but you can&#39;t see what the rewritten version looks like.</p>

<p>For example:</p>

<pre><code>  1     if (...) {
  2         return;
  3     }</code></pre>

<p>may be rewritten as</p>

<pre><code>  1    return if (...)</code></pre>

<p>so the profile won&#39;t show a statement count for line 2 in your source code because the <code>return</code> was merged into the <code>if</code> statement on the preceding line.</p>

<p>Also &#39;empty&#39; statements like <code>1;</code> are removed entirely. Such statements are empty because the optimizer has already removed the pointless constant in void context. It then goes on to remove the now empty statement (in perl &gt;= 5.13.7).</p>

<p>Using the <code>optimize=0</code> option disables the optimizer so you&#39;ll get lower overall performance but more accurately assigned statement counts.</p>

<p>If you find any other examples of the effect of optimizer on NYTProf output (other than performance, obviously) please let us know.</p>

<h2 id="subs-0">subs=0</h2>

<p>Set to 0 to disable the collection of subroutine caller and timing details.</p>

<h2 id="blocks-1">blocks=1</h2>

<p>Set to 1 to enable the determination of block and subroutine location per statement. This makes the profiler about 50% slower (as of July 2008) and produces larger output files, but you gain some valuable insight in where time is spent in the blocks within large subroutines and scripts.</p>

<h2 id="stmts-0">stmts=0</h2>

<p>Set to 0 to disable the statement profiler. (Implies <code>blocks=0</code>.) The reports won&#39;t contain any statement timing detail.</p>

<p>This significantly reduces the overhead of the profiler and can also be useful for profiling large applications that would normally generate a very large profile data file.</p>

<h2 id="calls-N">calls=N</h2>

<p>This option is <i>new and experimental</i>.</p>

<p>With calls=1 (the default) subroutine call <i>return</i> events are emitted into the data stream as they happen. With calls=2 subroutine call <i>entry</i> events are also emitted. With calls=0 no subroutine call events are produced. This option depends on the <code>subs</code> option being enabled, which it is by default.</p>

<p>The <a>nytprofcalls</a> utility can be used to process this data. It too is <i>new and experimental</i> and so likely to change.</p>

<p>The subroutine profiler normally gathers data in memory and outputs a summary when the profile data is being finalized, usually when the program has finished. The summary contains aggregate information for all the calls from one location to another, but the details of individual calls have been lost. The calls option enables the recording of individual call events and thus more detailed analysis and reporting of that data.</p>

<h2 id="leave-0">leave=0</h2>

<p>Set to 0 to disable the extra work done by the statement profiler to allocate times accurately when returning into the middle of statement. For example leaving a subroutine and returning into the middle of statement, or re-evaluating a loop condition.</p>

<p>This feature also ensures that in embedded environments, such as mod_perl, the last statement executed doesn&#39;t accumulate the time spent &#39;outside perl&#39;.</p>

<h2 id="findcaller-1">findcaller=1</h2>

<p>Force NYTProf to recalculate the name of the caller of the each sub instead of &#39;inheriting&#39; the name calculated when the caller was entered. (Rarely needed, but might be useful in some odd cases.)</p>

<h2 id="use_db_sub-1">use_db_sub=1</h2>

<p>Set to 1 to enable use of the traditional DB::DB() subroutine to perform profiling, instead of the faster &#39;opcode redirection&#39; technique that&#39;s used by default. Also effectively sets <code>leave=0</code> (see above).</p>

<p>The default &#39;opcode redirection&#39; technique can&#39;t profile subroutines that were compiled before NYTProf was loaded. So using use_db_sub=1 can be useful in cases where you can&#39;t load the profiler early in the life of the application.</p>

<p>Another side effect of <code>use_db_sub=1</code> is that it enables recording of the source code of the <code>perl -e &#39;...&#39;</code> and <code>perl -</code> input for old versions of perl. See also <a href="#savesrc-0">&quot;savesrc=0&quot;</a>.</p>

<h2 id="savesrc-0">savesrc=0</h2>

<p>Disable the saving of source code.</p>

<p>By default NYTProf saves a copy of all source code into the profile data file. This makes the file self-contained, so the reporting tools no longer depend on having the unmodified source code files available.</p>

<p>With <code>savesrc=0</code> some source code is still saved: the arguments to the <code>perl -e</code> option, the script fed to perl via STDIN when using <code>perl -</code>, and the source code of string evals.</p>

<p>Saving the source code of string evals requires perl version 5.8.9+, 5.10.1+, or 5.12 or later.</p>

<p>Saving the source code of the <code>perl -e &#39;...&#39;</code> or <code>perl -</code> input requires either a recent perl version, as above, or setting the <a href="#use_db_sub-1">&quot;use_db_sub=1&quot;</a> option.</p>

<h2 id="slowops-N">slowops=N</h2>

<p>Profile perl opcodes that can be slow. These include opcodes that make system calls, such as <code>print</code>, <code>read</code>, <code>sysread</code>, <code>socket</code> etc., plus regular expression opcodes like <code>subst</code> and <code>match</code>.</p>

<p>If <code>N</code> is 0 then slowops profiling is disabled.</p>

<p>If <code>N</code> is 1 then all the builtins are treated as being defined in the <code>CORE</code> package. So times for <code>print</code> calls from anywhere in your code are merged and accounted for as calls to an xsub called <code>CORE::print</code>.</p>

<p>If <code>N</code> is 2 (the default) then builtins are treated as being defined in the package that calls them. So calls to <code>print</code> from package <code>Foo</code> are treated as calls to an xsub called <code>Foo::CORE:print</code>. Note the single colon after CORE.</p>

<p>The opcodes are currently profiled using their internal names, so <code>printf</code> is <code>prtf</code> and the <code>-x</code> file test is <code>fteexec</code>. This may change in future.</p>

<p>Opcodes that call subroutines, perhaps by triggering a FETCH from a tied variable, currently appear in the call tree as the caller of the sub. This is likely to change in future.</p>

<h2 id="usecputime-1">usecputime=1</h2>

<p>This option has been removed. Profiling won&#39;t be enabled if set.</p>

<p>Use the <a href="#clock-N">&quot;clock=N&quot;</a> option to select a high-resolution CPU time clock, if available on your system, instead. That will give you higher resolution and work for the subroutine profiler as well.</p>

<h2 id="file">file=...</h2>

<p>Specify the output file to write profile data to (default: &#39;./nytprof.out&#39;).</p>

<h2 id="compress">compress=...</h2>

<p>Specify the compression level to use, if NYTProf is compiled with compression support. Valid values are 0 to 9, with 0 disabling compression. The default is 6 as higher values yield little extra compression but the cpu cost starts to rise significantly. Using level 1 still gives you a significant reduction in file size.</p>

<p>If NYTProf was not compiled with compression support, this option is silently ignored.</p>

<h2 id="clock-N">clock=N</h2>

<p>Systems which support the <code>clock_gettime()</code> system call typically support several clocks. By default NYTProf uses CLOCK_MONOTONIC.</p>

<p>This option enables you to select a different clock by specifying the integer id of the clock (which may vary between operating system types). If the clock you select isn&#39;t available then CLOCK_REALTIME is used.</p>

<p>See <a href="#CLOCKS">&quot;CLOCKS&quot;</a> for more information.</p>

<h2 id="sigexit-1">sigexit=1</h2>

<p>When perl exits normally it runs any code defined in <code>END</code> blocks. NYTProf defines an END block that finishes profiling and writes out the final profile data.</p>

<p>If the process ends due to a signal then END blocks are not executed so the profile will be incomplete and unusable. The <code>sigexit</code> option tells NYTProf to catch some signals (e.g. INT, HUP, PIPE, SEGV, BUS) and ensure a usable profile by executing:</p>

<pre><code>    DB::finish_profile();
    exit 1;</code></pre>

<p>You can also specify which signals to catch in this way by listing them, separated by commas, as the value of the option (case is not significant):</p>

<pre><code>    sigexit=int,hup</code></pre>

<h2 id="posix_exit-1">posix_exit=1</h2>

<p>The NYTProf subroutine profiler normally detects calls to <code>POSIX::_exit()</code> (which exits the process without running END blocks) and automatically calls <code>DB::finish_profile()</code> for you, so NYTProf &#39;just works&#39;.</p>

<p>When using the <code>subs=0</code> option to disable the subroutine profiler the <code>posix_exit</code> option can be used to tell NYTProf to take other steps to arrange for <code>DB::finish_profile()</code> to be called before <code>POSIX::_exit()</code>.</p>

<h2 id="libcexit-1">libcexit=1</h2>

<p>Arranges for <a href="#finish_profile">&quot;finish_profile&quot;</a> to be called via the C library <code>atexit()</code> function. This may help some tricky cases where the process may exit without perl executing the <code>END</code> block that NYTProf uses to call /finish_profile().</p>

<h2 id="endatexit-1">endatexit=1</h2>

<p>Sets the PERL_EXIT_DESTRUCT_END flag in the PL_exit_flags of the perl interpreter. This makes perl run <code>END</code> blocks in perl_destruct() instead of perl_run() which may help in cases, like Apache, where perl is embedded but perl_run() isn&#39;t called.</p>

<h2 id="forkdepth-N">forkdepth=N</h2>

<p>When a perl process that is being profiled executes a fork() the child process is also profiled. The forkdepth option can be used to control this. If forkdepth is zero then profiling will be disabled in the child process.</p>

<p>If forkdepth is greater than zero then profiling will be enabled in the child process and the forkdepth value in that process is decremented by one.</p>

<p>If forkdepth is -1 (the default) then there&#39;s no limit on the number of generations of children that are profiled.</p>

<h2 id="nameevals-0">nameevals=0</h2>

<p>The &#39;file name&#39; of a string eval is normally a string like &quot;<code>(eval N)</code>&quot;, where <code>N</code> is a sequence number. By default NYTProf asks perl to give evals more informative names like &quot;<code>(eval N)[file:line]</code>&quot;, where <code>file</code> and <code>line</code> are the file and line number where the string <code>eval</code> was executed.</p>

<p>The <code>nameevals=0</code> option can be used to disable the more informative names and return to the default behaviour. This may be need in rare cases where the application code is sensitive to the name given to a <code>eval</code>. (The most common case in when running test suites undef NYTProf.)</p>

<p>The downside is that the NYTProf reporting tools are less useful and may get confused if this option is used.</p>

<h2 id="nameanonsubs-0">nameanonsubs=0</h2>

<p>The name of a anonymous subroutine is normally &quot;<code>__ANON__</code>&quot;. By default NYTProf asks perl to give anonymous subroutines more informative names like &quot;<code>__ANON__[file:line]</code>&quot;, where <code>file</code> and <code>line</code> are the file and line number where the anonymous subroutine was defined.</p>

<p>The <code>nameanonsubs=0</code> option can be used to disable the more informative names and return to the default behaviour. This may be need in rare cases where the application code is sensitive to the name given to a anonymous subroutines. (The most common case in when running test suites undef NYTProf.)</p>

<p>The downside is that the NYTProf reporting tools are less useful and may get confused if this option is used.</p>

<p>With cperl since 5.28 and its <b>usenamedanoncv</b> option most anon subs keep their old name, just with an <code>@</code> appended. This is mostly used for import methods, which are skipped with perl5. The <code>nameanonsubs=0</code> option is in these cases ignored.</p>

<h1 id="RUN-TIME-CONTROL-OF-PROFILING">RUN-TIME CONTROL OF PROFILING</h1>

<p>You can profile only parts of an application by calling DB::disable_profile() to stop collecting profile data, and calling DB::enable_profile() to start collecting profile data.</p>

<p>Using the <code>start=no</code> option lets you leave the profiler disabled initially until you call DB::enable_profile() at the right moment. You still need to load Devel::NYTProf as early as possible, even if you don&#39;t call DB::enable_profile() until much later. That&#39;s because any code that&#39;s compiled before Devel::NYTProf is loaded will not be profiled by default. See also <a href="#use_db_sub-1">&quot;use_db_sub=1&quot;</a>.</p>

<p>The profile output file can&#39;t be used until it&#39;s been properly completed and closed. Calling DB::disable_profile() doesn&#39;t do that. To make a profile file usable before the profiled application has completed you can call DB::finish_profile(). Alternatively you could call DB::enable_profile($newfile).</p>

<p>Always call the DB::enable_profile(), DB::disable_profile() or DB::finish_profile() function with the <code>DB::</code> prefix as shown because you can&#39;t import them. They&#39;re provided automatically when NYTProf is in use.</p>

<h2 id="disable_profile">disable_profile</h2>

<pre><code>  DB::disable_profile()</code></pre>

<p>Stops collection of profile data until DB:enable_profile() is called.</p>

<p>Subroutine calls which were made while profiling was enabled and are still on the call stack (have not yet exited) will still have their profile data collected when they exit. Compare with <a href="#finish_profile">&quot;finish_profile&quot;</a> below.</p>

<h2 id="enable_profile">enable_profile</h2>

<pre><code>  DB::enable_profile($newfile)
  DB::enable_profile()</code></pre>

<p>Enables collection of profile data. If $newfile is specified the profile data will be written to $newfile (after completing and closing the previous file, if any). If $newfile already exists it will be deleted first. If DB::enable_profile() is called without a filename argument then profile data will continue to be written to the current file (nytprof.out by default).</p>

<h2 id="finish_profile">finish_profile</h2>

<pre><code>  DB::finish_profile()</code></pre>

<p>Calls DB::disable_profile(), then completes the profile data file by writing subroutine profile data, and then closes the file. The in memory subroutine profile data is then discarded.</p>

<p>Normally NYTProf arranges to call finish_profile() for you via an END block.</p>

<h1 id="DATA-COLLECTION-AND-INTERPRETATION">DATA COLLECTION AND INTERPRETATION</h1>

<p>NYTProf tries very hard to gather accurate information. The nature of the internals of perl mean that, in some cases, the information that&#39;s gathered is accurate but surprising. In some cases it can appear to be misleading. (Of course, in some cases it may actually be plain wrong. Caveat lector.)</p>

<h2 id="If-Statement-and-Subroutine-Timings-Dont-Match">If Statement and Subroutine Timings Don&#39;t Match</h2>

<p>NYTProf has two profilers: a statement profiler that&#39;s invoked when perl moves from one perl statement to another, and a subroutine profiler that&#39;s invoked when perl calls or returns from a subroutine.</p>

<p>The individual statement timings for a subroutine usually add up to slightly less than the exclusive time for the subroutine. That&#39;s because the handling of the subroutine call and return overheads is included in the exclusive time for the subroutine. The difference may only be a few microseconds but that may become noticeable for subroutines that are called hundreds of thousands of times.</p>

<p>The statement profiler keeps track how much time was spent on overheads, like writing statement profile data to disk. The subroutine profiler subtracts the overheads that have accumulated between entering and leaving the subroutine in order to give a more accurate profile. The statement profiler is generally very fast because most writes get buffered for zip compression so the profiler overhead per statement tends to be very small, often a single &#39;tick&#39;. The result is that the accumulated overhead is quite noisy. This becomes more significant for subroutines that are called frequently and are also fast. This may be another, smaller, contribution to the discrepancy between statement time and exclusive times.</p>

<h2 id="If-Headline-Subroutine-Timings-Dont-Match-the-Called-Subs">If Headline Subroutine Timings Don&#39;t Match the Called Subs</h2>

<p>Overall subroutine times are reported with a headline like <code>spent 10s (2+8) within ...</code>. In this example, 10 seconds were spent inside the subroutine (the &quot;inclusive time&quot;) and, of that, 8 seconds were spent in subroutines called by this one. That leaves 2 seconds as the time spent in the subroutine code itself (the &quot;exclusive time&quot;, sometimes also called the &quot;self time&quot;).</p>

<p>The report shows the source code of the subroutine. Lines that make calls to other subroutines are annotated with details of the time spent in those calls.</p>

<p>Sometimes the sum of the times for calls made by the lines of code in the subroutine is less than the inclusive-exclusive time reported in the headline (10-2 = 8 seconds in the example above).</p>

<p>What&#39;s happening here is that calls to other subroutines are being made but NYTProf isn&#39;t able to determine the calling location correctly so the calls don&#39;t appear in the report in the correct place.</p>

<p>Using an old version of perl is one cause (see below). Another is calling subroutines that exit via <code>goto &amp;sub;</code> - most frequently encountered in AUTOLOAD subs and code using the <a href="/cperl/lib/Memoize.html">Memoize</a> module.</p>

<p>In general the overall subroutine timing is accurate and should be trusted more than the sum of statement or nested sub call timings.</p>

<h2 id="Perl-5.10.1-or-else-5.8.9-is-Recommended">Perl 5.10.1+ (or else 5.8.9+) is Recommended</h2>

<p>These versions of perl yield much more detailed information about calls to BEGIN, CHECK, INIT, and END blocks, the code handling tied or overloaded variables, and callbacks from XS code.</p>

<p>Perl 5.12 will hopefully also fix an inaccuracy in the timing of the last statement and the condition clause of some kinds of loops: <a href="http://rt.perl.org/rt3/Ticket/Display.html?id=60954">http://rt.perl.org/rt3/Ticket/Display.html?id=60954</a></p>

<h2 id="eval-string">eval $string</h2>

<p>Perl treats each execution of a string eval (<code>eval $string;</code> not <code>eval { ... }</code>) as a distinct file, so NYTProf does as well. The &#39;files&#39; are given names with this structure:</p>

<pre><code>        (eval $sequence)[$filename:$line]</code></pre>

<p>for example &quot;<code>(eval 93)[/foo/bar.pm:42]</code>&quot; would be the name given to the 93rd execution of a string eval by that process and, in this case, the 93rd eval happened to be one at line 42 of &quot;/foo/bar.pm&quot;.</p>

<p>Nested string evals can give rise to file names like</p>

<pre><code>        (eval 1047)[(eval 93)[/foo/bar.pm:42]:17]</code></pre>

<h3 id="Merging-Evals">Merging Evals</h3>

<p>Some applications execute a great many string eval statements. If NYTProf generated a report page for each one it would not only slow report generation but also make the overall report less useful by scattering performance data too widely. On the other hand, being able to see the actual source code executed by an eval, along with the timing details, is often <i>very</i> useful.</p>

<p>To try to balance these conflicting needs, NYTProf currently <i>merges uninteresting string eval siblings</i>.</p>

<p>What does that mean? Well, for each source code line that executed any string evals, NYTProf first gathers the corresponding eval &#39;files&#39; for that line (known as the &#39;siblings&#39;) into groups keyed by distinct source code.</p>

<p>Then, for each of those groups of siblings, NYTProf will &#39;merge&#39; a group that shares the same source code and doesn&#39;t execute any string evals itself. Merging means to pick one sibling as the survivor and merge and delete all the data from the others into it.</p>

<p>If there are a large number of sibling groups then the data for all of them are merged into one regardless.</p>

<p>The report annotations will indicate when evals have been merged together.</p>

<h3 id="Merging-Anonymous-Subroutines">Merging Anonymous Subroutines</h3>

<p>Anonymous subroutines defined within string evals have names like this:</p>

<pre><code>        main::__ANON__[(eval 75)[/foo/bar.pm:42]:12]</code></pre>

<p>That anonymous subroutine was defined on line 12 of the source code executed by the string eval on line 42 of <i>/foo/bar.pm</i>. That was the 75th string eval executed by the program.</p>

<p>Anonymous subroutines <i>defined on the same line of sibling evals that get merged</i> are also merged. That is, the profile information is merged into one and the others are discarded.</p>

<h3 id="Timing">Timing</h3>

<p>Care should be taken when interpreting the report annotations associated with a string eval statement. Normally the report annotations embedded into the source code related to timings from the <i>subroutine</i> profiler. This isn&#39;t (currently) true of annotations for string eval statements.</p>

<p>This makes a significant different if the eval defines any subroutines that get called <i>after</i> the eval has returned. Because the time shown for a string eval is based on the <i>statement</i> times it will include time spent executing statements within the subs defined by the eval.</p>

<p>In future NYTProf may involve the subroutine profiler in timings evals and so be able to avoid this issue.</p>

<h2 id="Calls-from-XSUBs-and-Opcodes">Calls from XSUBs and Opcodes</h2>

<p>Calls record the current filename and line number of the perl code at the time the call was made. That&#39;s fine and accurate for calls from perl code. For calls that originate from C code however, such as an XSUB or an opcode, the filename and line number recorded are still those of the last <i>perl</i> statement executed.</p>

<p>For example, a line that calls an xsub will appear in reports to also have also called any subroutines that that xsub called. This can be construed as a feature.</p>

<p>As an extreme example, the first time a regular expression that uses character classes is executed on a unicode string you&#39;ll find profile data like this:</p>

<pre><code>      # spent 1ms within main::BEGIN@4 which was called
      #    once (1ms+0s) by main::CORE:subst at line 0
  4   s/ (?: [A-Z] | [\d] )+ (?= [\s] ) //x;
      # spent  38.8ms making 1 call to main::CORE:subst
      # spent  25.4ms making 2 calls to utf8::SWASHNEW, avg 12.7ms/call
      # spent  12.4ms making 1 call to utf8::AUTOLOAD</code></pre>

<h1 id="MAKING-NYTPROF-FASTER">MAKING NYTPROF FASTER</h1>

<p>You can reduce the cost of profiling by adjusting some options. The trade-off is reduced detail and/or accuracy in reports.</p>

<p>If you don&#39;t need statement-level profiling then you can disable it via <a href="#stmts-0">&quot;stmts=0&quot;</a>. To further boost statement-level profiling performance try <a href="#leave-0">&quot;leave=0&quot;</a> but note that <i>will</i> apportion timings for some kinds of statements less accurate).</p>

<p>If you don&#39;t need call stacks or flamegraph then disable it via <a href="#calls-0">&quot;calls=0&quot;</a>. If you don&#39;t need subroutine profiling then you can disable it via <a href="#subs-0">&quot;subs=0&quot;</a>. If you do need it but don&#39;t need timings for perl opcodes then set <a href="#slowops-0">&quot;slowops=0&quot;</a>.</p>

<p>Generally speaking, setting calls=0 and slowops=0 will give you a useful boost with the least loss of detail.</p>

<p>Another approach is to only enable NYTProf in the sections of code that interest you. See <a href="#RUN-TIME-CONTROL-OF-PROFILING">&quot;RUN-TIME CONTROL OF PROFILING&quot;</a> for more details.</p>

<p>To speed up <a>nytprofhtml</a> try using the --minimal (-m) or --no-flame options.</p>

<h1 id="REPORTS">REPORTS</h1>

<p>The <a href="/cperl/lib/Devel/NYTProf/Data.html">Devel::NYTProf::Data</a> module provides a low-level interface for loading the profile data.</p>

<p>The <a>Devel::NYTProf::Reader</a> module provides an interface for generating arbitrary reports. This means that you can implement your own output format in perl. (Though the module is in a state of flux and may be deprecated soon.)</p>

<p>Included in the bin directory of this distribution are some scripts which turn the raw profile data into more useful formats:</p>

<h2 id="nytprofhtml">nytprofhtml</h2>

<p>Creates attractive, richly annotated, and fully cross-linked html reports (including statistics, source code and color highlighting). This is the main report generation tool for NYTProf.</p>

<h2 id="nytprofcg">nytprofcg</h2>

<p>Translates a profile into a format that can be loaded into KCachegrind <a href="http://kcachegrind.github.io/">http://kcachegrind.github.io/</a></p>

<h2 id="nytprofcalls">nytprofcalls</h2>

<p>Reads a profile and processes the calls events it contains.</p>

<h2 id="nytprofmerge">nytprofmerge</h2>

<p>Reads multiple profile data files and writes out a new file containing the merged profile data.</p>

<h1 id="LIMITATIONS">LIMITATIONS</h1>

<h2 id="Threads-and-Multiplicity">Threads and Multiplicity</h2>

<p><code>Devel::NYTProf</code> is not currently thread safe or multiplicity safe. If you&#39;d be interested in helping to fix that then please get in touch with us. Meanwhile, profiling is disabled when a thread is created, and NYTProf tries to ignore any activity from perl interpreters other than the first one that loaded it.</p>

<h2 id="Coro">Coro</h2>

<p>The <code>Devel::NYTProf</code> subroutine profiler gets confused by the stack gymnastics performed by the <a>Coro</a> module and aborts. When profiling applications that use Coro you should disable the subroutine profiler using the <a href="#subs-0">&quot;subs=0&quot;</a> option.</p>

<h2 id="FCGI::Engine">FCGI::Engine</h2>

<p>Using <code>open(&#39;-|&#39;)</code> in code running under <a>FCGI::Engine</a> causes a panic in nytprofcalls. See https://github.com/timbunce/devel-nytprof/issues/20 for more information.</p>

<h2 id="For-perl-5.8.8-it-may-change-what-caller-returns">For perl &lt; 5.8.8 it may change what caller() returns</h2>

<p>For example, the <a>Readonly</a> module croaks with &quot;Invalid tie&quot; when profiled with perl versions before 5.8.8. That&#39;s because <a>Readonly</a> explicitly checking for certain values from caller(). The <a href="/cperl/lib/NEXT.html">NEXT</a> module is also affected.</p>

<h2 id="For-perl-5.10.1-it-cant-see-some-implicit-calls-and-callbacks">For perl &lt; 5.10.1 it can&#39;t see some implicit calls and callbacks</h2>

<p>For perl versions prior to 5.8.9 and 5.10.1, some implicit subroutine calls can&#39;t be seen by the <i>subroutine</i> profiler. Technically this affects calls made via the various perl <code>call_*()</code> internal APIs.</p>

<p>For example, BEGIN/CHECK/INIT/END blocks, the <code>TIE</code><i>whatever</i> subroutine called by <code>tie()</code>, all calls made via operator overloading, and callbacks from XS code, are not seen.</p>

<p>The effect is that time in those subroutines is accumulated by the subs that triggered the call to them. So time spent in calls invoked by perl to handle overloading are accumulated by the subroutines that trigger overloading (so it is measured, but the cost is dispersed across possibly many calling locations).</p>

<p>Although the calls aren&#39;t seen by the subroutine profiler, the individual <i>statements</i> executed by the code in the called subs are profiled by the statement profiler.</p>

<h2 id="line-directives">#line directives</h2>

<p>The reporting code currently doesn&#39;t handle #line directives, but at least it warns about them. Patches welcome.</p>

<h2 id="Freed-values-in-_-may-be-mutated">Freed values in @_ may be mutated</h2>

<p>Perl has a class of bugs related to the fact that values placed in the stack are not reference counted. Consider this example:</p>

<pre><code>  @a = (1..9);  sub s { undef @a; print $_ for @_ }  s(@a);</code></pre>

<p>The <code>undef @a</code> frees the values that <code>@_</code> refers to. Perl can sometimes detect when a freed value is accessed and treats it as an undef. However, if the freed value is assigned some new value then @_ is effectively corrupted.</p>

<p>NYTProf allocates new values while it&#39;s profiling, in order to record program activity, and so may appear to corrupt <code>@_</code> in this (rare) situation. If this happens, NYTProf is simply exposing an existing problem in the code.</p>

<h2 id="Lvalue-subroutines-arent-profiled-when-using-use_db_sub-1">Lvalue subroutines aren&#39;t profiled when using use_db_sub=1</h2>

<p>Currently &#39;lvalue&#39; subroutines (subs that can be assigned to, like <code>foo() = 42</code>) are not profiled when using use_db_sub=1.</p>

<h1 id="CLOCKS">CLOCKS</h1>

<p>Here we discuss the way NYTProf gets high-resolution timing information from your system and related issues.</p>

<h2 id="POSIX-Clocks">POSIX Clocks</h2>

<p>These are the clocks that your system may support if it supports the POSIX <code>clock_gettime()</code> function. Other clock sources are listed in the <a href="#Other-Clocks">&quot;Other Clocks&quot;</a> section below.</p>

<p>The <code>clock_gettime()</code> interface allows clocks to return times to nanosecond precision. Of course few offer nanosecond <i>accuracy</i> but the extra precision helps reduce the cumulative error that naturally occurs when adding together many timings. When using these clocks NYTProf outputs timings as a count of 100 nanosecond ticks.</p>

<h3 id="CLOCK_MONOTONIC">CLOCK_MONOTONIC</h3>

<p>CLOCK_MONOTONIC represents the amount of time since an unspecified point in the past (typically system start-up time). It increments uniformly independent of adjustments to &#39;wallclock time&#39;. NYTProf will use this clock by default, if available.</p>

<h3 id="CLOCK_REALTIME">CLOCK_REALTIME</h3>

<p>CLOCK_REALTIME is typically the system&#39;s main high resolution &#39;wall clock time&#39; source. The same source as used for the gettimeofday() call used by most kinds of perl benchmarking and profiling tools.</p>

<p>The problem with real time is that it&#39;s far from simple. It tends to drift and then be reset to match &#39;reality&#39;, either sharply or by small adjustments (via the adjtime() system call).</p>

<p>Surprisingly, it can also go backwards, for reasons explained in http://preview.tinyurl.com/5wawnn so CLOCK_MONOTONIC is preferred.</p>

<h3 id="CLOCK_VIRTUAL">CLOCK_VIRTUAL</h3>

<p>CLOCK_VIRTUAL increments only when the CPU is running in user mode on behalf of the calling process.</p>

<h3 id="CLOCK_PROF">CLOCK_PROF</h3>

<p>CLOCK_PROF increments when the CPU is running in user <i>or</i> kernel mode.</p>

<h3 id="CLOCK_PROCESS_CPUTIME_ID">CLOCK_PROCESS_CPUTIME_ID</h3>

<p>CLOCK_PROCESS_CPUTIME_ID represents the amount of execution time of the process associated with the clock.</p>

<h3 id="CLOCK_THREAD_CPUTIME_ID">CLOCK_THREAD_CPUTIME_ID</h3>

<p>CLOCK_THREAD_CPUTIME_ID represents the amount of execution time of the thread associated with the clock.</p>

<h3 id="Finding-Available-POSIX-Clocks">Finding Available POSIX Clocks</h3>

<p>On unix-like systems you can find the CLOCK_* clocks available on you system using a command like:</p>

<pre><code>  grep -r &#39;define *CLOCK_&#39; /usr/include</code></pre>

<p>Look for a group that includes CLOCK_REALTIME. The integer values listed are the clock ids that you can use with the <code>clock=N</code> option.</p>

<p>A future version of NYTProf should be able to list the supported clocks.</p>

<h2 id="Other-Clocks">Other Clocks</h2>

<p>This section lists other clock sources that NYTProf may use.</p>

<p>If your system doesn&#39;t support clock_gettime() then NYTProf will use gettimeofday(), or the nearest equivalent,</p>

<h3 id="gettimeofday">gettimeofday</h3>

<p>This is the traditional high resolution time of day interface for most unix-like systems. With this clock NYTProf outputs timings as a count of 1 microsecond ticks.</p>

<h3 id="mach_absolute_time">mach_absolute_time</h3>

<p>On Mac OS X the mach_absolute_time() function is used. With this clock NYTProf outputs timings as a count of 100 nanosecond ticks.</p>

<h3 id="Time::HiRes">Time::HiRes</h3>

<p>On systems which don&#39;t support other clocks, NYTProf falls back to using the <a href="/cperl/lib/Time/HiRes.html">Time::HiRes</a> module. With this clock NYTProf outputs timings as a count of 1 microsecond ticks.</p>

<h2 id="Clock-References">Clock References</h2>

<p>Relevant specifications and manual pages:</p>

<pre><code>  http://www.opengroup.org/onlinepubs/000095399/functions/clock_getres.html
  http://linux.die.net/man/3/clock_gettime</code></pre>

<p>Why &#39;realtime&#39; can appear to go backwards:</p>

<pre><code>  http://preview.tinyurl.com/5wawnn</code></pre>

<p>The PostgreSQL pg_test_timing utility documentation has a good summary of timing issues:</p>

<pre><code>  http://www.postgresql.org/docs/9.2/static/pgtesttiming.html</code></pre>

<h1 id="CAVEATS">CAVEATS</h1>

<h2 id="SMP-Systems">SMP Systems</h2>

<p>On systems with multiple processors, which includes most modern machines, (from Linux docs though applicable to most SMP systems):</p>

<pre><code>  The CLOCK_PROCESS_CPUTIME_ID and CLOCK_THREAD_CPUTIME_ID clocks are realized on
  many platforms using timers from the CPUs (TSC on i386, AR.ITC on Itanium).
  These registers may differ between CPUs and as a consequence these clocks may
  return bogus results if a process is migrated to another CPU.

  If the CPUs in an SMP system have different clock sources then there is no way
  to maintain a correlation between the timer registers since each CPU will run
  at a slightly different frequency. If that is the case then
  clock_getcpuclockid(0) will return ENOENT to signify this condition. The two
  clocks will then only be useful if it can be ensured that a process stays on a
  certain CPU.

  The processors in an SMP system do not start all at exactly the same time and
  therefore the timer registers are typically running at an offset. Some
  architectures include code that attempts to limit these offsets on bootup.
  However, the code cannot guarantee to accurately tune the offsets. Glibc
  contains no provisions to deal with these offsets (unlike the Linux Kernel).
  Typically these offsets are small and therefore the effects may be negligible
  in most cases.</code></pre>

<p>In summary, SMP systems are likely to give &#39;noisy&#39; profiles. Setting a <a href="#Processor-Affinity">&quot;Processor Affinity&quot;</a> may help.</p>

<h3 id="Processor-Affinity">Processor Affinity</h3>

<p>Processor affinity is an aspect of task scheduling on SMP systems. &quot;Processor affinity takes advantage of the fact that some remnants of a process may remain in one processor&#39;s state (in particular, in its cache) from the last time the process ran, and so scheduling it to run on the same processor the next time could result in the process running more efficiently than if it were to run on another processor.&quot; (From http://en.wikipedia.org/wiki/Processor_affinity)</p>

<p>Setting an explicit processor affinity can avoid the problems described in <a href="#SMP-Systems">&quot;SMP Systems&quot;</a>.</p>

<p>Processor affinity can be set using the <code>taskset</code> command on Linux.</p>

<p>Note that processor affinity is inherited by child processes, so if the process you&#39;re profiling spawns cpu intensive sub processes then your process will be impacted by those more than it otherwise would.</p>

<h3 id="Windows">Windows</h3>

<p><b>THIS SECTION DOESN&#39;T MATCH THE CODE</b></p>

<p>On Windows NYTProf uses Time::HiRes which uses the windows QueryPerformanceCounter() API with some extra logic to adjust for the current clock speed and try to resync the raw counter to wallclock time every so often (every 30 seconds or if the timer drifts by more than 0.5 of a seconds). This extra logic may lead to occasional spurious results.</p>

<p>(It would be great if someone could contribute a patch to NYTProf to use QueryPerformanceCounter() directly and avoid the overheads and resyncing behaviour of Time::HiRes.)</p>

<h2 id="Virtual-Machines">Virtual Machines</h2>

<p>I recommend you don&#39;t do performance profiling while running in a virtual machine. If you do you&#39;re likely to find inexplicable spikes of real-time appearing at unreasonable places in your code. You should pay less attention to the statement timings and rely more on the subroutine timings. They will still be noisy but less so than the statement times.</p>

<p>You could also try using the <code>clock=N</code> option to select a high-resolution <i>cpu-time</i> clock instead of a real-time one. That should be much less noisy, though you will lose visibility of wait-times due to network and disk I/O, for example.</p>

<h1 id="BUGS">BUGS</h1>

<p>Possibly. All complex software has bugs. Let me know if you find one.</p>

<h1 id="SEE-ALSO">SEE ALSO</h1>

<p>Screenshots of <a>nytprofhtml</a> v2.01 reports can be seen at <a href="http://timbunce.files.wordpress.com/2008/07/nytprof-perlcritic-index.png">http://timbunce.files.wordpress.com/2008/07/nytprof-perlcritic-index.png</a> and <a href="http://timbunce.files.wordpress.com/2008/07/nytprof-perlcritic-all-perl-files.png">http://timbunce.files.wordpress.com/2008/07/nytprof-perlcritic-all-perl-files.png</a>. A writeup of the new features of NYTProf v2 can be found at <a href="http://blog.timbunce.org/2008/07/15/nytprof-v2-a-major-advance-in-perl-profilers/">http://blog.timbunce.org/2008/07/15/nytprof-v2-a-major-advance-in-perl-profilers/</a> and the background story, explaining the &quot;why&quot;, can be found at <a href="http://blog.timbunce.org/2008/07/16/nytprof-v2-the-background-story/">http://blog.timbunce.org/2008/07/16/nytprof-v2-the-background-story/</a>.</p>

<p>Mailing list and discussion at <a href="http://groups.google.com/group/develnytprof-dev">http://groups.google.com/group/develnytprof-dev</a></p>

<p>Blog posts <a href="http://blog.timbunce.org/tag/nytprof/">http://blog.timbunce.org/tag/nytprof/</a></p>

<p>Public Github Repository and hacking instructions at <a href="https://github.com/timbunce/devel-nytprof/">https://github.com/timbunce/devel-nytprof/</a></p>

<p><a>nytprofhtml</a> is a script included that produces html reports. <a>nytprofcsv</a> is another script included that produces plain text CSV reports.</p>

<p><a>Devel::NYTProf::Reader</a> is the module that powers the report scripts. You might want to check this out if you plan to implement a custom report (though it&#39;s very likely to be deprecated in a future release).</p>

<p><a href="/cperl/lib/Devel/NYTProf/ReadStream.html">Devel::NYTProf::ReadStream</a> is the module that lets you read a profile data file as a stream of chunks of data.</p>

<p>Other tools:</p>

<p>DTrace <a href="https://speakerdeck.com/mrallen1/perl-dtrace-and-you">https://speakerdeck.com/mrallen1/perl-dtrace-and-you</a></p>

<h1 id="TROUBLESHOOTING">TROUBLESHOOTING</h1>

<h2 id="Profile-data-incomplete-...-or-Profile-format-error">&quot;Profile data incomplete, ...&quot; or &quot;Profile format error: ...&quot;</h2>

<p>This error message means the file doesn&#39;t contain all the expected data or the data has been corrupted in some way. That may be because it was truncated (perhaps the filesystem was full) or, more commonly, because the all the expected data hasn&#39;t been written.</p>

<p>NYTProf writes some important data to the data file when <i>finishing</i> profiling. If you read the file before the profiling has finished you&#39;ll get this error.</p>

<p>If the process being profiled is still running you&#39;ll need to wait until it exits cleanly (runs <code>END</code> blocks or <a href="#finish_profile">&quot;finish_profile&quot;</a> is called explicitly).</p>

<p>If the process being profiled has exited then it&#39;s likely that it met with a sudden and unnatural death that didn&#39;t give NYTProf a chance to finish the profile. If the sudden death was due to a signal, like SIGTERM, or a SIGINT from pressing Ctrl-C, then the <a href="#sigexit-1">&quot;sigexit=1&quot;</a> option may help.</p>

<p>If the sudden death was due to calling <code>POSIX::_exit($status)</code> then you&#39;ll need to call <a href="#finish_profile">&quot;finish_profile&quot;</a> before calling <code>POSIX::_exit</code>.</p>

<p>You&#39;ll also get this error if the code trying to read the profile is itself being profiled. That&#39;s most likely to happen if you enable profiling via the <code>PERL5OPT</code> environment variable and have forgotten to unset it.</p>

<p>If you&#39;ve encountered this error message, and you&#39;re sure you&#39;ve understood the concerns described above, and you&#39;re sure they don&#39;t apply in your case, then please open an issue. Be sure to include sufficient information so I can see how you&#39;ve addressed these likely causes.</p>

<h2 id="Some-source-files-dont-have-profile-information">Some source files don&#39;t have profile information</h2>

<p>This is usually due to NYTProf being initialized after some perl files have already been compiled.</p>

<p>If you can&#39;t alter the command line to add &quot;<code>-d:NYTProf</code>&quot; you could try using the <code>PERL5OPT</code> environment variable. See <a href="#PROFILING">&quot;PROFILING&quot;</a>.</p>

<p>You could also try using the <a href="#use_db_sub-1">&quot;use_db_sub=1&quot;</a> option.</p>

<h2 id="Eval-...-has-unknown-invoking-fid">Eval ... has unknown invoking fid</h2>

<p>When using the statement profiler you may see a warning message like this:</p>

<pre><code>  Eval &#39;(eval 2)&#39; (fid 9, flags:viastmt,savesrc) has unknown invoking fid 10
 </code></pre>

<p>Notice that the eval file id (fid 9 in this case) is lower than the file id that invoked the eval (fid 10 in this case). This is a known problem caused by the way perl works and how the profiler assigns and outputs the file ids. The invoking fid is known but gets assigned a fid and output after the fid for the eval, and that causes the warning when the file is read.</p>

<h2 id="Warning:-d-subroutine-calls-had-negative-time">Warning: %d subroutine calls had negative time</h2>

<p>There are two likely causes for this: clock instability, or accumulated timing errors.</p>

<p>Clock instability, if present on your system, is most likely to be noticeable on very small/fast subroutines that are called very few times.</p>

<p>Accumulated timing errors can arise because the subroutine profiler uses floating point values (NVs) to store the times. They are most likely to be noticed on subroutines that are called a few times but which make a large number of calls to very fast subroutines (such as opcodes). In this case the accumulated time apparently spent making those calls can be greater than the time spent in the calling subroutine.</p>

<p>If you rerun nytprofhtml (etc.) with the <a href="#trace-N">&quot;trace=N&quot;</a> option set &gt;0 you&#39;ll see trace messages like &quot;%s call has negative time: incl %fs, excl %fs&quot; for each affected subroutine.</p>

<p>Try profiling with the <a href="#slowops-N">&quot;slowops=N&quot;</a> option set to 0 to disable the profiling of opcodes. Since opcodes often execute in a few microseconds they are a common cause of this warning.</p>

<p>You could also try recompiling perl to use &#39;long doubles&#39; for the NV floating point type (use Configure -Duselongdouble). If you try this please let me know. I&#39;d also happily take a patch to use long doubles, if available, by default.</p>

<h2 id="panic:-buffer-overflow">panic: buffer overflow ...</h2>

<p>You have unusually long subroutine names in your code. You&#39;ll need to rebuild Devel::NYTProf with the NYTP_MAX_SUB_NAME_LEN environment variable set to a value longer than the longest subroutine names in your code.</p>

<h1 id="AUTHORS-AND-CONTRIBUTORS">AUTHORS AND CONTRIBUTORS</h1>

<p><b>Tim Bunce</b> (<a href="http://www.tim.bunce.name">http://www.tim.bunce.name</a> and <a href="http://blog.timbunce.org">http://blog.timbunce.org</a>) leads the project and has done most of the development work thus far.</p>

<p><b>Nicholas Clark</b> contributed zip compression and <code>nytprofmerge</code>. <b>Chia-liang Kao</b> contributed <code>nytprofcg</code>. <b>Peter (Stig) Edwards</b> contributed the VMS port. <b>Jan Dubois</b> contributed the Windows port. <b>Gisle Aas</b> contributed the Devel::NYTProf::ReadStream module. <b>Steve Peters</b> contributed greater perl version portability and use of POSIX high-resolution clocks. <b>Reini Urban</b> maintains the cperl fork, where it is in CORE. Other contributors are noted in the Changes file.</p>

<p>Many thanks to <b>Adam Kaplan</b> who created <code>NYTProf</code> initially by forking <code>Devel::FastProf</code> adding reporting from <code>Devel::Cover</code> and a test suite. For more details see <a href="#HISTORY">&quot;HISTORY&quot;</a> below.</p>

<h1 id="COPYRIGHT-AND-LICENSE">COPYRIGHT AND LICENSE</h1>

<pre><code>  Copyright (C) 2008 by Adam Kaplan and The New York Times Company.
  Copyright (C) 2008-2016 by Tim Bunce, Ireland.</code></pre>

<p>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself, either Perl version 5.8.8 or, at your option, any later version of Perl 5 you may have available.</p>

<h2 id="Background">Background</h2>

<p>Subroutine-level profilers:</p>

<pre><code>  Devel::DProf        | 1995-10-31 | ILYAZ
  Devel::AutoProfiler | 2002-04-07 | GSLONDON
  Devel::Profiler     | 2002-05-20 | SAMTREGAR
  Devel::Profile      | 2003-04-13 | JAW
  Devel::DProfLB      | 2006-05-11 | JAW
  Devel::WxProf       | 2008-04-14 | MKUTTER</code></pre>

<p>Statement-level profilers:</p>

<pre><code>  Devel::SmallProf    | 1997-07-30 | ASHTED
  Devel::FastProf     | 2005-09-20 | SALVA
  Devel::NYTProf      | 2008-03-04 | AKAPLAN
  Devel::Profit       | 2008-05-19 | LBROCARD</code></pre>

<p>Devel::NYTProf is a (now distant) fork of Devel::FastProf, which was itself an evolution of Devel::SmallProf.</p>

<p>Adam Kaplan forked Devel::FastProf and added html report generation (based on Devel::Cover) and a test suite - a tricky thing to do for a profiler. Meanwhile Tim Bunce had been extending Devel::FastProf to add novel per-sub and per-block timing, plus subroutine caller tracking.</p>

<p>When Devel::NYTProf was released Tim switched to working on Devel::NYTProf because the html report would be a good way to show the extra profile data, and the test suite made development much easier and safer.</p>

<p>Then Tim went a little crazy and added a slew of new features, in addition to per-sub and per-block timing and subroutine caller tracking. These included the &#39;opcode interception&#39; method of profiling, ultra-fast and robust inclusive subroutine timing, doubling performance, plus major changes to html reporting to display all the extra profile call and timing data in richly annotated and cross-linked reports.</p>

<p>Steve Peters came on board along the way with patches for portability and to keep NYTProf working with the latest development perl versions. Nicholas Clark added zip compression, many optimizations, and <code>nytprofmerge</code>. Jan Dubois contributed Windows support.</p>

<p>Adam&#39;s work was sponsored by The New York Times Co. <a href="http://open.nytimes.com">http://open.nytimes.com</a>. Tim&#39;s work was partly sponsored by Shopzilla <a href="http://www.shopzilla.com">http://www.shopzilla.com</a> during 2008 but hasn&#39;t been sponsored since then.</p>

<p>For the record, Tim has never worked for the New York Times nor has he received any kind of sponsorship or support from them in relation to NYTProf. The name of this module is simply result of the history outlined above, which can be summarised as: Adam forked an existing module when he added his enhancements and Tim didn&#39;t.</p>


</body>

</html>


